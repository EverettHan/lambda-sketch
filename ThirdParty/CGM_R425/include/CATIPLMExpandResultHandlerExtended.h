//===================================================================
// COPYRIGHT Dassault Systemes 2018/04/10
//===================================================================
// CATIPLMExpandResultHandlerExtended.cpp
// Header definition of class CATIPLMExpandResultHandlerExtended
//===================================================================
//
// Usage notes:
// /!\ IMPORTANT /!\
// Do NOT implement this class directly, use the adapter instead:
//  -> CATPLMExpandResultHandlerExtendedAdapter
// /!\ IMPORTANT /!\
//
//===================================================================
//  2018/04/10 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATIPLMExpandResultHandlerExtended_H
#define CATIPLMExpandResultHandlerExtended_H

#include "CATPLMServicesItf.h"
#include "CATIPLMExpandResultHandler.h"
#include "CATBaseUnknown.h"

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATPLMServicesItf IID IID_CATIPLMExpandResultHandlerExtended;
#else
extern "C" const IID IID_CATIPLMExpandResultHandlerExtended;
#endif

class CATPLMID;
class CATPLMSemanticRelation;

class ExportedByCATPLMServicesItf CATIPLMExpandResultHandlerExtended : public CATIPLMExpandResultHandler
{
  CATDeclareInterface;

public:
  /**
  * Receives notification of Broken Record data.
  * A Broken Record doesn't have a valid PLMID because of error(s).
  * You can retrieve the highest error with CATIPLMRecordRead::GetReport
  *
  * The Expand/3DIndex service will invoke this method for every Broken Record in the Path.
  * Don't keep ipBrokenRecord.
  *
  * @param ipBrokenRecord
  *   The broken record read
  */
  virtual HRESULT BrokenRecord(CATIPLMRecordRead* ipBrokenRecord) = 0;

  /**
  * Suppose following mode is used:
  * CATOmxQIPtr<CATIPLMQueryFilterAdditionalParams> spiFAdditionalParams(spFilter);
  * CATAssert(spiFAdditionalParams.Ref() != NULL);
  * spiFAdditionalParams->SetParameter("SR_Optimisation", "SRUsedDuringNavigation");
  * Navigation will only be made on SRs that are crossed.
  * In XML, we find following specific grammar:
  * <RELATIONSHIP OWNER="PLMIDv2(<UUID_A>,<UUID_A>,<UUID_A>,PLMSAMPLE2/PLMSample2Connection,PLM1)">SRv2(PLMIDv1([PLMIDv2(<UUID_B>,<UUID_B>,<UUID_B>,PLMSAMPLE2/PLMSample2Instance,PLM1)]),1,Reference,Default,0,z'IypQRAAGAAAAAAAAAAEAAAAAAQAAAQ==',[(Rel,Synch,7EE5282F000043DC634D63B70000BA53)])</RELATIONSHIP>
  * Suppose you have A - SR -> B with SR owned by A
  * Suppose you navigate from B to A. SR (owned by A) will be returned BEFORE record A
  */
  virtual HRESULT SRCrossed(const CATPLMID& iPlmId, const CATPLMSemanticRelation& iSR) = 0;
};

#endif
