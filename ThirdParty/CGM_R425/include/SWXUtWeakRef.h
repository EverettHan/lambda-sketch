//===================================================================

//===================================================================
// SWXUtWeakRef.cpp
// Header definition of class SWXUtWeakRef
//===================================================================
//
// Usage notes: template should be used with smart-pointer (*_var)
//              classes only
//
//===================================================================
//  2013/04/09 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUtWeakRef_H
#define SWXUtWeakRef_H

#include "CATBaseUnknown_var.h"
#include "CATSysWeakRef.h"
#include "CATSysMacros.h"

//-----------------------------------------------------------------------

template<class VALUETYPE> class SWXUtWeakRef
{
	public:

		SWXUtWeakRef() : mRef( NULL )
		{
			EnsureType();
		}

		SWXUtWeakRef( VALUETYPE& iSrc ) : mRef( NULL )
		{
			EnsureType();

			if ( !! iSrc )
				mRef = iSrc->GetComponentWeakRef();
		}

		SWXUtWeakRef( const CATBaseUnknown_var& iSrc ) : mRef( NULL )
		{
			EnsureType();

			// Check that passed in reference in castable to appropriate type
			VALUETYPE obj = iSrc;
			if ( !! obj )
				mRef = obj->GetComponentWeakRef();
		}

		SWXUtWeakRef( CATBaseUnknown* iSrc ) : mRef( NULL )
		{
			EnsureType();

			if ( NULL != iSrc && 1 != iSrc->IsNull() )
			{
				// Check that passed in reference in castable to appropriate type
				VALUETYPE obj = iSrc;
				if ( !! obj )
					mRef = obj->GetComponentWeakRef();
			}
		}

		SWXUtWeakRef( const SWXUtWeakRef<VALUETYPE>& iSrc ) : mRef( iSrc.mRef )
		{
			EnsureType();

			if ( NULL != mRef )
				mRef->AddRef();
		}

		virtual ~SWXUtWeakRef()
		{
			CATSysReleasePtr( mRef );
		}

	public:

		bool IsNull() const
		{
			bool res = true;
            if ( NULL != mRef )
            {
                CATBaseUnknown* pComp = mRef->GiveComponent();
                if ( NULL != pComp )
                        res = ( 1 == pComp->IsNull() );
            }
            return res;
		}

	public:

		VALUETYPE operator->() const
		{
			VALUETYPE res;
			if ( NULL != mRef )
            {
                CATBaseUnknown* pComp = mRef->GiveComponent();
                if ( NULL != pComp && 1 != pComp->IsNull() )
					res = pComp;
            }
			return res;
		}

		operator VALUETYPE() const
		{
			return operator->();
		}

		const SWXUtWeakRef<VALUETYPE>& operator=( const VALUETYPE& iSrc )
		{
			bool releaseWeakRef = true;

			if ( !! iSrc )
			{
				CATSysWeakRef* pSrcWeakRef = iSrc->GetComponentWeakRef();
				if ( NULL != pSrcWeakRef )
				{
					if ( mRef != pSrcWeakRef )
					{
						SetRef( pSrcWeakRef );
						pSrcWeakRef = NULL;
					}
					else
						CATSysReleasePtr( pSrcWeakRef );

					releaseWeakRef = false;
				}
			}
			
			if ( releaseWeakRef )
				CATSysReleasePtr( mRef );

			return *this;
		}

		const SWXUtWeakRef<VALUETYPE>& operator=( const CATBaseUnknown_var& iSrc )
		{
			VALUETYPE obj = iSrc;
			return operator=( obj );
		}

		const SWXUtWeakRef<VALUETYPE>& operator=( CATBaseUnknown* iSrc )
		{
			VALUETYPE obj = iSrc;
			return operator=( obj );
		}

		const SWXUtWeakRef<VALUETYPE>& operator=( const SWXUtWeakRef<VALUETYPE>& iSrc )
		{
			if ( &iSrc != this )
			{
				if ( mRef != iSrc.mRef )
					SetRef( iSrc.mRef );

				if ( NULL != mRef )
					mRef->AddRef();
			}
			return *this;
		}

		bool operator==( const VALUETYPE& iObj ) const
		{
			bool res = ( NULL == mRef );
			if ( !! iObj )
			{
				CATSysWeakRef* pObjWeakRef = iObj->GetComponentWeakRef();
				if ( NULL != pObjWeakRef )
				{
					res = ( mRef == pObjWeakRef );
					CATSysReleasePtr( pObjWeakRef );
				}
			}
			return res;
		}

		bool operator==( const CATBaseUnknown_var& iObj ) const
		{
			VALUETYPE obj = iObj;
			return operator==( obj );
		}

		bool operator==( CATBaseUnknown* iObj ) const
		{
			VALUETYPE obj = iObj;
			return operator==( obj );
		}

		bool operator==( const SWXUtWeakRef<VALUETYPE>& iObj ) const
		{
			return ( mRef == iObj.mRef );
		}

		bool operator!=( const VALUETYPE& iObj ) const
		{
			bool res = ( NULL != mRef );
			if ( !! iObj )
			{
				CATSysWeakRef* pObjWeakRef = iObj->GetComponentWeakRef();
				if ( NULL != pObjWeakRef )
				{
					res = ( mRef != pObjWeakRef );
					CATSysReleasePtr( pObjWeakRef );
				}
			}
			return res;
		}

		bool operator!=( const CATBaseUnknown_var& iObj ) const
		{
			VALUETYPE obj = iObj;
			return operator!=( obj );
		}

		bool operator!=( CATBaseUnknown* iObj ) const
		{
			VALUETYPE obj = iObj;
			return operator!=( obj );
		}

		bool operator!=( const SWXUtWeakRef<VALUETYPE>& iObj ) const
		{
			return ( mRef != iObj.mRef );
		}

		bool operator<( const SWXUtWeakRef<VALUETYPE>& iObj ) const
		{
			return mRef < iObj.mRef;
		}

	private:

		void SetRef( CATSysWeakRef* iRef )
		{
			if ( NULL != mRef )
				CATSysReleasePtr( mRef );

			mRef = iRef;
		}

		void EnsureType()
		{
			// This function does nothing, but limits use of the template to *_var classes only
			VALUETYPE obj;
			if ( !! obj )
				obj = static_cast<CATBaseUnknown_var>( obj );
		}

	private:

		CATSysWeakRef* mRef;
};

template<class VALUETYPE> bool operator==( const VALUETYPE& iObj1, const SWXUtWeakRef<VALUETYPE>& iObj2 )
{
	return iObj2.operator==( iObj1 );
}

template<class VALUETYPE> bool operator==( const CATBaseUnknown_var& iObj1, const SWXUtWeakRef<VALUETYPE>& iObj2 )
{
	return iObj2.operator==( iObj1 );
}

template<class VALUETYPE> bool operator==( CATBaseUnknown* iObj1, const SWXUtWeakRef<VALUETYPE>& iObj2 )
{
	return iObj2.operator==( iObj1 );
}

template<class VALUETYPE> bool operator!=( const VALUETYPE& iObj1, const SWXUtWeakRef<VALUETYPE>& iObj2 )
{
	return iObj2.operator!=( iObj1 );
}

template<class VALUETYPE> bool operator!=( const CATBaseUnknown_var& iObj1, const SWXUtWeakRef<VALUETYPE>& iObj2 )
{
	return iObj2.operator!=( iObj1 );
}

template<class VALUETYPE> bool operator!=( CATBaseUnknown* iObj1, const SWXUtWeakRef<VALUETYPE>& iObj2 )
{
	return iObj2.operator!=( iObj1 );
}

//-----------------------------------------------------------------------

#endif
