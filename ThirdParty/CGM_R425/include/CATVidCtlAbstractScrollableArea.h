// COPYRIGHT Dassault Systemes 2011
//=============================================================================
//
// CATVidCtlAbstractScrollableArea.h
// Header definition of CATVidCtlAbstractScrollableArea
//
//=============================================================================
//  Oct 2011  Creation: Code generated by the CAA wizard  LD5
//=============================================================================
#ifndef CATVidCtlAbstractScrollableArea_H
#define CATVidCtlAbstractScrollableArea_H
#include <CATVidCtl.h>
#include <CATVid.h>
#include <CATBoolean.h>
#include <CATISYPPresenter.h>
#include <CATVidCtlScrollbar.h>
#include <CATBaseUnknown_WR.h>
#include <CATMathPoint2Df.h>
#include <CATSYPEvent.h>
#include <CATSYPEventArgs.h>
#include <CATVidTouchEventArgs.h>
class CATVidLayGrid;
class CATVidWidget;
class CATSYPIntAnimation;
class CATSYPStoryboard;
class CATSYPBeginStoryboard;
class CATVidDnDEventArgs;

/**
 * @ingroup VIDControls
 *
 * @c CATVidCtlAbstractScrollableArea provides the abstraction of a basic 
 * scrollable area. This class is meant to be extended and cannot be used as 
 * is.
 * 
 * @par Composition
 * This scrollable area is composed, by default, of:
 *
 * @li a scrolled widget seen through a viewport; 
 * @li horizontal and vertical stretch policies for the scrolled widgets;
 * @li top, bottom, right and left margins; 
 * @li top, bottom, right and left surrounding widgets;
 * @li top-left, bottom-left, top-right and bottom-right corner widgets;
 * @li optional horizontal and vertical scrollbars (@ref CATVidCtlScrollbar);
 * @li visibility policies for both scrollbars, if any. 
 *
 * @image html CATVidCtlScrollableArea-schema.PNG "Abstract scrollable area architecture"
 *
 * @par Available templates
 * There are three templates for this class:
 * @li with scrollbars (@c Default template)
 * @li without scrollbars (@c NoScrollbars template)
 * @li with scroll indicators that appears only on scroll (@c ScrollIndicators template)
 *
 * @br The @c NoScrollbars template is proposed as a leightweight scrollable 
 * where scrollbars are not implemented and scrollbar policies have no effect.
 *
 * @par Possible tunings of a scrollable
 *
 * @par 
 * Dynamic scrollable with scrollbars appearing when needed:
 * @li Templates: @c Default
 * @li @c HStretchPolicy, @c VStretchPolicy: @ref CATVid#Stretch, @c CATVid#NoStretch
 * @li @c HScrollbarPolicy, @c VScrollbarPolicy: @ref CATVid#AsNeeded
 *
 * @par
 * Static scrollable with scrollbars always there or never there:
 * @li Templates: @c Default, @c NoScrollbars
 * @li @c HStretchPolicy, @c VStretchPolicy: @ref CATVid#Stretch, @c CATVid#NoStretch
 * @li @c HScrollbarPolicy, @c VScrollbarPolicy: @ref CATVid#AlwaysVisible
 *
 * @par
 * Touch scrollable with scroll indicators when moving or nothing:
 * @li Templates: @c ScrollIndicators, @c NoScrollbars
 * @li @c HStretchPolicy, @c VStretchPolicy: @ref CATVid#Stretch, @c CATVid#NoStretch
 * @li @c HScrollbarPolicy, @c VScrollbarPolicy: @ref CATVid#AsNeeded
 *
 * @par 
 * Horizontal ribbon with vertical scrollbar or nothing:
 * @li Templates: @c Default, @c ScrollIndicators
 * @li @c HStretchPolicy: @ref CATVid#Stretch, @c CATVid#NoStretch
 * @li @c VStretchPolicy: @ref CATVid#StretchFit, @c CATVid#NoStretchFit
 * @li @c HScrollbarPolicy: @ref CATVid#AlwaysVisible, @ref CATVid#AlwaysHidden
 * @li @c VScrollbarPolicy: @ref CATVid#AlwaysHidden
 * 
 * @par 
 * Vertical ribbon with horizontal scrollbar or nothing:
 * @li Templates: @c Default, @c ScrollIndicators
 * @li @c HStretchPolicy: @ref CATVid#StretchFit, @c CATVidNoStretchFit
 * @li @c VStretchPolicy: @ref CATVid#Stretch, @c CATVidNoStretch
 * @li @c HScrollbarPolicy: @ref CATVid#AlwaysHidden 
 * @li @c VScrollbarPolicy: @ref CATVid#AlwaysVisible, @ref CATVid#AlwaysHidden
 *
 * @par
 * Touch horizontal ribbon with vertical scroll indicator when moving or nothing:
 * @li Templates: @c ScrollIndicators, @c NoScrollbar
 * @li @c HStretchPolicy: @ref CATVid#Stretch, @c CATVidNoStretch
 * @li @c VStretchPolicy: @ref CATVid#StretchFit, @c CATVidNoStretchFit
 * @li @c HScrollbarPolicy: @ref CATVid#AlwaysVisible
 * @li @c VScrollbarPolicy: @ref CATVid#AlwaysHidden
 *
 * @par
 * Touch vertical ribbon with horizontal scroll indicator when moving or nothing:
 * @li Templates: @c ScrollIndicators, @c NoScrollbar
 * @li @c HStretchPolicy: @ref CATVid#StretchFit, @c CATVidNoStretchFit
 * @li @c VStretchPolicy: @ref CATVid#Stretch, @c CATVidNoStretch
 * @li @c HScrollbarPolicy: @ref CATVid#AlwaysHidden 
 * @li @c VScrollbarPolicy: @ref CATVid#AlwaysVisible
 *
 * @par Viewport
 * The viewport on the scrolled widget defines how many of the scrolled widget 
 * is visible inside the scrollable area depending on the current dimensions of 
 * the area. In order to account for the place taken by the scrollbars, 
 * the viewport shrinks when a scrollbar appears and extends when a scrollbar 
 * disappears. You can choose the attachment of your scrolled widget inside the
 * viewport. To avoid the shrinking of the viewport, set 
 * @c HScrollbarPlaceholderFlag and/or @c VScrollbarPlaceholderFlag to @c TRUE:
 * that way, space will be reserved for scrollbars even when they are not 
 * visible.
 *
 * @par Smart scrollbars
 * The visibility of the scrollbars depend on the chosen 
 * @ref CATVid#ScrollbarPolicy. By default, each scrollbar is visible only when 
 * needed; that is, when either minimum dimension of the scrolled widget 
 * (width for the horizontal scrollbar, height for the vertical one) 
 * is bigger than the corresponding dimension of the viewport 
 * (@ref CATVid#AsNeeded). 
 * Nonetheless, scrollbars can be made always hidden (@ref CATVid#AlwaysHidden) 
 * or always visible (@ref CATVid#AlwaysVisible). 
 * Finally, to ensure visibility on the scrolled widget, scrollbars are forced 
 * to invisibility on special cases, where the area defined by the margins and 
 * the viewport is extremely small compared to the dimensions of the 
 * scrollbars.
 *
 * @par Position of scrollbars
 * Scrollbars can be placed on either side of the viewport: 
 *
 * @li top or bottom for horizontal (@ref #SetHScrollbarSide)
 * @li right or left for vertical (@ref #SetVScrollbarSide) 
 *
 * @par Stretching the scrolled widget
 * Horizontal and vertical stretch policies control the appearance of the
 * scrolled widget inside the scrollable area (@ref CATVid#StretchPolicy). 
 * @li The default stretch policies are both @c Stretch (@ref CATVid#Stretch), 
 * meaning that the scrolled item will stretch in both dimensions if the 
 * scrollable is bigger than its minimum dimensions. 
 * @li The @c StretchFit policy corresponds to the same behaviour, except
 * that the scrollabre area is not allowed to be smaller than the minimum
 * dimension of the scrolled widget. This policy is fully compatible with
 * both scrollbar policies chosen among @c AlwaysHidden or @c AlwaysVisible. If
 * @c AsNeeded is used in any direction, the scrollable will not be allowed to 
 * be smaller that the minimum dimension of the scrolled widget minus the width 
 * of a scrollbar.
 * @li If using the @c NoStretch policy, the scrolled widget keep its minimum
 * dimensions even when the scrollable is bigger than the scrolled widget.
 * @li @c NoStretchFit is the same as @c StretchFit, except that the scrolled
 * widget cannot be stretched.
 * 
 * @par Scroll in one direction only
 * Horizontal and vertical policies can be different. For example, to create a
 * vertical scrollable ribbon, the vertical stretch policy must be put to
 * @c StretchFit, whereas the horizontal one can be either @c NoStretch or 
 * @c Stretch. 
 * 
 * @par Putting motionless widgets around the scrolled widget
 * Top, bottom, right and left margins define a length between the resp. 
 * top, bottom, right and left sides of the viewport on the scrolled widget and
 * the resp. top, bottom, left and right sides of the scrollable area. 
 * Those vacant spaces can be used to surround the viewport with widgets 
 * (@ref #SetTWidget, @ref #SetBWidget, @ref #SetRWidget, @ref #SetLWidget).
 * The visible height of top and bottom widgets is limited by top and bottom 
 * margins.
 * The visible width of top and bottom widgets is limited by right and left 
 * margins.
 * Similarly, corner widgets can be added in the top-left, bottom-left, 
 * top-right and bottom-right squares defined by the margins 
 * (@ref #SetTLWidget, @ref #SetBLWidget, @ref #SetTRWidget, 
 * @ref #SetBRWidget).
 *
 * @par Inheriting the abstract scrollable
 * When extending this class, scrolling has to be implemented 
 * (@ref #ScrollContentBy), as well as all needed events (keyboard, mouse...).
 * Each time that a scroll is performed, a ::Scroll() event with corresponding
 * scroll delta as argument must be sent.
 *
 * @par Styling your scrollable
 * Here are the mandatory "syp:named" objects that myst be found in the 
 * template of your ".sypstyle" file : 
 * @li Presenter [CATVidCtl]
 * @li StretchGrid [CATVidLayGrid]
 * @li ScrolledWidgetArea [CATVidCtl]
 * The optional ones are :
 * @li VScrollbar [CATVidCtlScrollbar]
 * @li HScrollbar [CATVidCtlScrollbar]
 * @li PresenterContainer [CATVidCtl]
 */
class ExportedByVisuDialog CATVidCtlAbstractScrollableArea: public CATVidCtl
{
  friend class l_CATVidCtlAbstractScrollableArea;
  CATDeclareClass;

public:
  static int const ScrollbarMovingState_NotMoving = 0;
  static int const ScrollbarMovingState_Moving = 1;

public:
  /** Constructor. */
  CATVidCtlAbstractScrollableArea();
  /** @copydoc CATVidCtl#SetChild 
  *
  * When you set the child of the scrollable area, it sets the scrolled
  * widget.
  */
  virtual void SetChild(CATBaseUnknown_var i_spToConnect);
  /**
   * Does nothing except sending a @ref #Scroll event.
   *
   * When inheriting @c CATVidCtlAbstractScrollableArea, you have to 
   * reimplement this function to allow the content to move on scroll. In 
   * case the child class has scrollbars, they must be synchronized with the 
   * movement of the content. When scrolling, the variables to be taken into 
   * account are: 
   *
   * @li the viewport on the scrolled widget, which represents how much of the 
   * scrolled widget is seen
   *
   * @li the minimum dimensions of the presenter, which are that of the 
   * scrolled widget
   *
   * @li the offset position of the presenter, which is the offset of the 
   * viewport on the scrolled widget: it must be updated after scrolling  
   *
   * You can call @ref CATVidCtlAbstractScrollableArea#ScrollContentBy
   * at the end of your reimplementation, so that a scroll event is sent, or
   * send it by yourself.
   *
   * @param i_iDeltaX the horizontal scrolling
   * @param i_iDeltaY the vertical scrolling
   *
   * @see #Scroll
   */
  virtual void ScrollContentBy(int i_iDeltaX, int i_iDeltaY);
  /**
   * Sets the side that the vertical scrollbar will be displayed on.
   * Default side is @ref CATVid#Right. 
   * Asserts that the side to set is either @c Right or @c Left.
   *
   * @param i_side the side of display (@ref CATVid#Left or @ref CATVid#Right). 
   */
  void SetVScrollbarSide(CATVid::Side i_side);
  /**
   * @return the side of the vertical scrollbar
   * (@ref CATVid#Left or @ref CATVid#Right). 
   */
  CATVid::Side GetVScrollbarSide() const;
 /**
  * Sets the side that the horizontal scrollbar will be displayed on. 
  * Default side is @ref CATVid#Bottom.
  * Asserts that the side to set is either @c Bottom or @c Top.
  *
  * @param the side of display (@ref CATVid#Bottom or @ref CATVid#Top).
  */
  void SetHScrollbarSide(CATVid::Side i_side);
  /** 
   * @return the side of the vertical scrollbar
   * (@ref CATVid#Bottom or @ref CATVid#Top). 
   */
  CATVid::Side GetHScrollbarSide() const;
  /**
   * Sets the vertical scrollbar policy (see @ref CATVid#ScrollbarPolicy).
   * Default policy is @c AsNeeded (see @ref CATVid#AsNeeded).
   *
   * @param i_policy the vertical scrollbar policy.
   */
  void SetVScrollbarPolicy(CATVid::ScrollbarPolicy i_policy);
  /**
   * @return the current vertical scrollbar policy 
   * (@ref CATVid#ScrollbarPolicy).
   */
  CATVid::ScrollbarPolicy GetVScrollbarPolicy() const;
  /**
   * Sets the horizontal scrollbar policy (see @ref CATVid#ScrollbarPolicy).
   * Default policy is @c AsNeeded (see @ref CATVid#AsNeeded).
   *
   * @param i_policy the horizontal scrollbar policy.
   */
  void SetHScrollbarPolicy(CATVid::ScrollbarPolicy i_policy);
  /**
   * @return the current horizontal scrollbar policy 
   * (@ref CATVid#ScrollbarPolicy).
   */
  CATVid::ScrollbarPolicy GetHScrollbarPolicy() const;
  /**
   * Sets the step of the horizontal scrollbar. Increment this value to 
   * speed-up mouse wheel, left arrow / right arrow presses and clicks on
   * horizontal scrollbar buttons. Default value is 10 (-1 if no scrollbar).
   *
   * @param i_iStep the new step of the scrollbar.
   */
  void SetHSingleStep(int i_iStep);
  /**
   * @return the @c SingleStep of the horizontal scrollbar, if any; -1
   * else.
   */
  int GetHSingleStep() const;
  /**
   * Sets the step of the vertical scrollbar. Increment this value to 
   * speed-up mouse wheel, up arrow / down arrow presses and clicks on
   * vertical scrollbar buttons. Default value is 10 (-1 if no scrollbar).
   *
   * @param i_iStep the new step of the scrollbar.
   */
  void SetVSingleStep(int i_iStep);
  /**
   * @return the @c SingleStep of the vertical scrollbar, if any; -1
   * else.
   */
  int GetVSingleStep() const;
  /**
   * Scroll is needed as soon as the area available for the scrolled widget
   * inside the scrolled widget area is smaller than said scrolled widget.
   *
   * @return @c TRUE if the viewport is wider than the scrolled widget.
   */
  CATBoolean GetHScrollNeededState();
  /**
   * Scroll is needed as soon as the area available for the scrolled widget
   * inside the scrolled widget area is smaller than said scrolled widget.
   *
   * @return @c TRUE if the viewport is higher than the scrolled widget.
   */
  CATBoolean GetVScrollNeededState();
  /**
   * The visibility of a scrollbar depends on the scrollbar policy, the size
   * of the viewport compared to the size of the scrolled widget and the
   * value of @c ScrollbarsOnlyOnScrollFlag. 
   *
   * @return @c TRUE if the vertical scrollbar is visible, @c FALSE else.
   */
  CATBoolean GetVScrollbarVisibleState() const;
  /**
   * The visibility of a scrollbar depends on the scrollbar policy, the size
   * of the viewport compared to the size of the scrolled widget and the
   * value of @c ScrollbarsOnlyOnScrollFlag. 
   *
   * @return @c TRUE if the horizontal scrollbar is visible, @c FALSE else.
   */
  CATBoolean GetHScrollbarVisibleState() const;
  /**
   * The vertical scroll indicator is visible when the vertical scrollbar 
   * should be visible and we are currently scrolling vertically.
   *
   * @return @c TRUE if the vertical scroll indicator is visible, 
   * @c FALSE else.
   */
  CATBoolean GetVScrollIndicatorVisibleState() const;
  /**
   * The horizontal scroll indicator is visible when the horizontal scrollbar 
   * should be visible and we are currently scrolling horizontally.
   *
   * @return @c TRUE if the horizontal scroll indicator is visible, 
   * @c FALSE else.
   */
  CATBoolean GetHScrollIndicatorVisibleState() const;

  /**
   * Returns the height of the horizontal scrollbar.
   */
  float GetHScrollbarHeight() const;

  /**
   * Returns the width of the vertical scrollbar.
   */
  float GetVScrollbarWidth() const;

  /**
   * Sets the horizontal alignment of the scrolled widget inside the scrollable 
   * area. Default is CATVid#AlignCenter.
   *
   * @param i_eAlignment CATVid#AlignLeft, CATVid#AlignCenter or 
   * CATVid#AlignRight.
   */
  void SetScrolledWidgetHAlignment(CATVid::Alignment i_eAlignment);
  /**
   * @return The horizontal alignment of the scrolled widget inside the 
   * scrollable area.
   */
  CATVid::Alignment GetScrolledWidgetHAlignment() const;
  /**
   * Sets the vertical alignment of the scrolled widget inside the scrollable 
   * area. Default is CATVid#VAlignCenter.
   *
   * @param i_eAlignment CATVid#VAlignTop, CATVid#VAlignCenter or 
   * CATVid#VAlignBottom.
   */
  void SetScrolledWidgetVAlignment(CATVid::VAlignment i_eAlignment);
  /**
   * @return The vertical alignment of the scrolled widget inside the 
   * scrollable area.
   */
  CATVid::VAlignment GetScrolledWidgetVAlignment() const;
  /**
   * @return the presenter of the scrolled widget. Used by the style processor.
   *
   * @see CATVidCtl#GetItem
   * @see CATISYPPresenter
   */
  virtual CATISYPPresenter_var GetItem();
  /**
   * Sets the bottom and right margins. Default margins are 0. <br/>
   * Asserts that the margins are positive.
   *
   * @param i_margins the margins : @c i_margins.x is the length of the right 
   * margin, @c i_margins.y the length of the bottom margin.
   */
  void SetBRMargins(const CATMathPoint2Df& i_margins);
  /**
   * @return the bottom and right margins as a point whose abscissa @c x is the
   * length of the right margin and whose ordinate @c y is the length of the 
   * bottom margin.
   */
  const CATMathPoint2Df& GetBRMargins() const;
  /**
   * Sets the top and left margins. Default margins are 0. <br/>
   * Asserts that the margins are positive.
   *
   * @param i_margins the margins : @c i_margins.x is the length of the left 
   * margin, @c i_margins.y the length of the top margin.
   */
  void SetTLMargins(const CATMathPoint2Df& i_margins);
  /**
   * @return the top and left margins as a point whose abscissa @c x is the 
   * length of the left margin and whose ordinate @c y is the length of the top 
   * margin.
   */
  const CATMathPoint2Df& GetTLMargins() const;
  /**
   * Sets the bottom margin. Default margin is 0. <br/>
   * Asserts that the margin is positive.
   *
   * @param i_length the length of the bottom margin.
   */
  void SetBMargin(int i_length);
  /**
   * @return the length of the bottom margin.
   */
  int GetBMargin() const;
  /**
   * Sets the right margin. Default margin is 0. <br/>
   * Asserts that the margin is positive.
   *
   * @param i_length the length of the right margin.
   */
  void SetRMargin(int i_length);
  /**
   * @return the length of the right margin.
   */
  int GetRMargin() const;
  /**
   * Sets the top margin. Default margin is 0. <br/>
   * Asserts that the margin is positive.
   *
   * @param i_length the length of the top margin.
   */
  void SetTMargin(int i_length);
  /**
   * @return the length of the top margin.
   */
  int GetTMargin() const;
  /**
   * Sets the left margin. Default margin is 0. <br/>
   * Asserts that the margin is positive.
   *
   * @param i_length the length of the left margin.
   */
  void SetLMargin(int i_length);
  /**
   * @return the length of the left margin.
   */
  int GetLMargin() const;
  /**
   * Sets the top widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetTWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the top widget.
   */
  CATVidWidget* GetTWidget() const;
  /**
   * Sets the bottom widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetBWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the bottom widget.
   */
  CATVidWidget* GetBWidget() const;
  /**
   * Sets the right widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetRWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the right widget.
   */
  CATVidWidget* GetRWidget() const;
  /**
   * Sets the left widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetLWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the left widget.
   */
  CATVidWidget* GetLWidget() const;
  /**
   * Sets the top-left widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetTLWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the top-left widget.
   */
  CATVidWidget* GetTLWidget() const;
  /**
   * Sets the bottom-left widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetBLWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the bottom-left widget.
   */
  CATVidWidget* GetBLWidget() const;
  /**
   * Sets the top-right widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetTRWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the top-right widget.
   */
  CATVidWidget* GetTRWidget() const;
  /**
   * Sets the bottom-right widget. Does not addref the widget.
   *
   * @param i_pWidget the widget to set.
   */
  void SetBRWidget(CATVidWidget* i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @returns the bottom-right widget.
   */
  CATVidWidget* GetBRWidget() const;
    /**
   * Sets a not pickable widget behind the scrolled widget. This not pickable
   * widget will be set as a fixed background for the scrollable area, inside
   * the margins. Does not addref the widget.
   *
   * @param
   * For example, this background can be a @c CATVidLayGrid filled with
   * @c CATVidGPSquare. The background will not move when the scrolled widget 
   * moves.
   * 
   * @param
   * By default, there is not background widget.
   *
   * @param i_pBackgroundWidget the background widget.
   */
  void SetBackgroundWidget(CATVidWidget * i_pWidget);
  /**
   * Does not addref the widget.
   *
   * @return the background widget.
   *
   * @see #SetBackgroundWidget
   */
  CATVidWidget * GetBackgroundWidget() const;
  /**
   * The size of the horizontal scroll extent on the widget in the
   * scrollable area is how much can be scrolled horizontally 
   * on the widget.
   *
   * @return the size of the horizontal scroll extent.
   */
  int GetHScrollExtent() const;
  /**
   * The size of the vertical scroll extent on the widget in the
   * scrollable area is how much can be scrolled vertically 
   * on the widget.
   *
   * @return the size of the vertical scroll extent.
   */
  int GetVScrollExtent() const;
    /**
   * Get the current horizontal scroll offset of the scrolled widget inside the 
   * scrollable area.
   * @return the current horizontal scroll offset.
   */
  int GetHScrollOffset() const;
  /**
   * Get the current vertical scroll offset of the scrolled widget inside the 
   * scrollable area.
   * @return the current vertical scroll offset.
   */
  int GetVScrollOffset() const;
  /**
   * Sets the horizontal scroll offset of the scrolled widget inside the 
   * scrollable area.
   * @param i_X the new abscissa of the offset position of the scrolled widget.
   */
  void SetHScrollOffset(int i_X);
  /**
   * Sets the vertical scroll offset of the scrolled widget inside the 
   * scrollable area.
   * @param i_X the new ordinate of the offset position of the scrolled widget.
   */
  void SetVScrollOffset(int i_Y);
  /**
   * Get the current horizontal scroll percentage (between 0 and 100) of the scrolled widget
   * inside the scrollable area.
   * @return the current horizontal percentage.
   */
  float GetHScrollPercentage() const;
  /**
   * Get the current vertical scroll percentage (between 0 and 100) of the scrolled widget
   * inside the scrollable area.
   * @return the current vertical percentage.
   */
  float GetVScrollPercentage() const;
  /**
   * Sets the horizontal scroll percentage (between 0 and 100) of the scrolled widget
   * inside the scrollable area.
   * @param i_X the new horizontal percentage of the position of the scrolled widget.
   */
  void SetHScrollPercentage(float i_HSP);
  /**
   * Sets the vertical scroll percentage (between 0 and 100) of the scrolled widget
   * inside the scrollable area.
   * @param i_X the new vertical percentage of the position of the scrolled widget.
   */
  void SetVScrollPercentage(float i_VSP);
  /**
   * Checks if the given child widget is visible inside the viewport of the scroll area
   * @parma i_pChildWidget the widget to make visible. 
   * This widget must be part of the scrolled widget hierarchy, otherwise this method will assert.
   * @return @c TRUE if the child widget is visible, @c FALSE else.
   */
  CATBoolean IsWidgetVisible(CATVidWidget * i_pChildWidget);
  /**
   * Scrolls the contents of the scroll area so that the given child widget is visible inside the viewport.
   * The contents are scrolled to the nearest valid position.
   * @parma i_pChildWidget the widget to make visible. 
   * This widget must be part of the scrolled widget hierarchy, otherwise this method will assert.
   * @see ScrollContentBy
   */
  void EnsureWidgetVisible(CATVidWidget * i_pChildWidget);
  /**
   * The viewport represents how much of the scrolled widget can be seen.
   *
   * @return the viewport width.
   */
  int GetViewportWidth() const;
  /**
   * The viewport represents how much of the scrolled widget can be seen.
   *
   * @return the viewport height.
   */
  int GetViewportHeight() const;
  /**
   * The width of the scrolled widget.
   *
   * @return the scrolled widget width.
   */
  int GetScrolledWidgetWidth() const;
  /**
   * The height of the scrolled widget.
   *
   * @return the scrolled widget height.
   */
  int GetScrolledWidgetHeight() const;
  /**
   * Sets the horizontal stretch policy (@ref CATVid#StretchPolicy).
   * By default, the stretch policy is @ref CATVid#Stretch. 
   *
   * @param i_policy the horizontal stretch policy.
   *
   * @see #SetHScrollbarPolicy
   */
  void SetHStretchPolicy(CATVid::StretchPolicy i_policy);
  /**
   * @return the current horizontal stretch policy (@ref CATVid#StretchPolicy).
   */
  CATVid::StretchPolicy GetHStretchPolicy() const;
    /**
   * Sets the vertical stretch policy (see @ref CATVid#StretchPolicy).
   * By default, the stretch policy is @ref CATVid#Stretch. 
   *
   * @param i_policy the vertical stretch policy.
   *
   * @see #SetVScrollbarPolicy
   */
  void SetVStretchPolicy(CATVid::StretchPolicy i_policy);
  /**
   * @return the current vertical stretch policy (@ref CATVid#StretchPolicy).
   */
  CATVid::StretchPolicy GetVStretchPolicy() const;
    /**
   * @param Default: scroll widget shrinks
   * By default, when the viewport gets smaller than the scrolled widget, the
   * scroll widget shranks until it gets to its minimum dimension. When the
   * viewport gets smaller than the minimum dimension of the scrolled widget,
   * we have a partial vision on the minimum scrolled widget and scroll is 
   * activated.
   * 
   * @param Deactivated: scroll widget never shrinks
   * If you need the dimension of the scrolled widget to be preserved, you can
   * set the @c ShrinkScrollWidgetFlag to @c FALSE. On that case, the 
   * scrollable area never shrinks the scrolled widget, even after it has
   * been stretched (in case the scrollbar policies are @ref CATVid#Stretch or
   * @ref CATVid#StretchFit).
   * Deactivation will not work if you do not use CID styles and do not
   * have a @c PresenterContainer syp-named object similar to that of the
   * default style in your scrollable style.
   *
   * @return @c TRUE if the scrolled widget is pickable, @c FALSE else.
   */
  CATBoolean GetShrinkScrolledWidgetFlag() const;
  /** 
   * @param @c TRUE if the scrollable area must shrink the scrolled widget,
   * @c FALSE else.
   *
   * @see #GetShrinkScrolledWidgetFlag
   */
  void SetShrinkScrolledWidgetFlag(const CATBoolean& i_bFlag);
  /**
   * The scrolled widget is pickable by default.
   *
   * @return @c TRUE if the scrolled widget is pickable, @c FALSE else.
   */
  CATBoolean GetPickAndScrollFlag() const;
  /**
   * Sets the pick and scroll flag. It is @c TRUE by default, allowing the user
   * to pick the scrolled widget and scroll it horizontally and vertically with 
   * mouse wheel and keyboard events. 
   *
   * Set it to @c FALSE to disallow picking the scrolled widget. 
   *
   * @param @c TRUE if the scrolled widget can be picked, @c FALSE else
   *
   * @see #SetMouseScrollFlag
   */
  void SetPickAndScrollFlag(CATBoolean i_bIsPickable);
  /**
   * @return @c TRUE if there is a scrollbar placeholder when the scrollbar
   * disappear, @c FALSE else.
   */
  CATBoolean GetHScrollbarPlaceholderFlag() const;
  /**
   * @c FALSE by default. Activate to have a scrollbar placeholder in your
   * scrollable area when the scrollbar is not visible.
   *
   * @param i_flag @c TRUE to have a scrollbar placeholder.
   */
  void SetHScrollbarPlaceholderFlag(const CATBoolean& i_flag);
  /**
   * @return @c TRUE if there is a scrollbar placeholder when the scrollbar
   * disappear, @c FALSE else.
   */
  CATBoolean GetVScrollbarPlaceholderFlag() const;
  /**
   * @c FALSE by default. Activate to have a scrollbar placeholder in your
   * scrollable area when the scrollbar is not visible.
   *
   * @param i_flag @c TRUE to have a scrollbar placeholder.
   */
  void SetVScrollbarPlaceholderFlag(const CATBoolean& i_flag);
 /**
  * @see #SetScrollbarsOnlyOnScrollFlag
  */
  CATBoolean GetScrollbarsOnlyOnScrollFlag() const;
  /**
   * @c TRUE if scrollbars must appear only when scrolling and when the 
   * scrollbar policy allows it. On that case, you must use the 
   * @c ScrollbarsOnlyOnScroll template of @c CATVidCtlAbstractScrollableArea.
   * 
   * @c FALSE by default.
   *
   * @param i_bScrollbarsOnlyOnScroll @c TRUE if scrollbars must be used as 
   * scroll indicators, @c FALSE else.
   */
  void SetScrollbarsOnlyOnScrollFlag(CATBoolean i_bScrollbarsOnlyOnScroll);
  /**
   * By default, you cannot scroll both directions in the same gesture.
   *
   * @return @c TRUE if only one direction at a time is locked, @c FALSE else.
   */
  CATBoolean GetLockOneDirectionOnScrollFlag() const;
  /**
   * Sets the @c LockOneDirectionOnTouchScrollFlag flag. It is @c TRUE by 
   * default, preventing the user from scrolling in both directions at the same 
   * time (diagonal scroll).
   *
   * Set it to @c FALSE to allow both directions scrolling. 
   */
  void SetLockOneDirectionOnScrollFlag(const CATBoolean& i_flag);
  /**
   * Inertia is activated in both directions by default.
   *
   * @return @c TRUE if inertia is activated in both directions, @c FALSE else.
   */
  CATBoolean GetInertiaFlag() const;
  /**
   * Sets the @c HInertiaFlag and the @c VInertiaFlag. Both are @c TRUE by 
   * default. Set it to @c FALSE to deactivate inertia in both directions. 
   */
  void SetInertiaFlag(const CATBoolean& i_flag);
  /**
   * Horizontal inertia is activated by default.
   *
   * @return @c TRUE if horizontal inertia is activated, @c FALSE else.
   */
  CATBoolean GetHInertiaFlag() const;
  /**
   * Sets the @c HInertiaFlag. It is @c TRUE by default.
   *
   * Set it to @c FALSE to deactivate horizontal inertia. 
   */
  void SetHInertiaFlag(const CATBoolean& i_flag);
  /**
   * Vertical inertia is activated by default.
   *
   * @return @c TRUE if vertical inertia is activated, @c FALSE else.
   */
  CATBoolean GetVInertiaFlag() const;
  /**
   * Sets the @c VInertiaFlag. It is @c TRUE by default.
   * 
   * @param i_flag the vertical flag
   */
  void SetVInertiaFlag(const CATBoolean& i_flag);
  /**
   * Rebound is activated by default. DOES NOT WORK YET.
   *
   * @return @c TRUE if horizontal rebound is activated, @c FALSE else.
   */
  CATBoolean GetHReboundFlag() const;
  /**
   * Sets the @c HReboundFlag. Rebound is activated by default. DOES NOT WORK 
   * YET.
   *
   * Set it to @c FALSE to deactivate horizontal rebound. 
   */
  void SetHReboundFlag(const CATBoolean& i_flag);
  /**
   * Rebound  is activated by default. DOES NOT WORK YET.
   *
   * @return @c TRUE if vertical rebound is activated, @c FALSE else.
   */
  CATBoolean GetVReboundFlag() const;
  /**
   * Sets the @c VReboundFlag. Rebound (indicators when the edge of the
   * scrollable is hit) is activated by default. DOES NOT WORK YET.
   * 
   * @param i_flag the vertical rebound flag
   */
  void SetVReboundFlag(const CATBoolean& i_flag);
  /**
   * Mouse scrolling by grabbing the scrolled area is activated by default.
   *
   * @return @c TRUE if mouse scrolling is activated, @c FALSE else.
   */
  CATBoolean GetMouseScrollFlag() const;
  /**
   * Sets the @c mouseScrollFlag. It is @c TRUE by default, allowing the user 
   * to scroll by grabbing the scrolled area with the mouse and drag it. The 
   * @c PickAndScrollFlag must also be @c TRUE for mouse drag to work.
   *
   * Set it to @c FALSE to deactivate mouse scrolling. 
   * 
   * @param i_flag the mouse scroll flag
   */
  void SetMouseScrollFlag(const CATBoolean& i_flag);
  /**
   * If activated, dispatch the limit-reached events (@ref #TopReached, 
   * @ref #BottomReached, @ref #RightReached, @ref #LeftReached) even when 
   * scrolling with the scrollbars or the mouse wheel. If not activated, the
   * limit-reached events can only be dispatched when using grab-and-scroll.
   *
   * @c FALSE by default.
   *
   * @return @c TRUE to sent limit-reached, @c FALSE else.
   */
  CATBoolean GetAlwaysDispatchLimitReachedFlag() const;
  /**
   * @param i_flag activate to allow the dispatch of limit-reached events even
   * when scrolling with scrollbars or the mouse wheel.
   *
   * @see #GetDispatchSendLimitReachedFlag
   */
  void SetAlwaysDispatchLimitReachedFlag(const CATBoolean& i_flag);
  /**
   * Default value is @ref CATVid#Vertical.
   *
   * @return the scrolling direction controlled by the mouse wheel
   */
  CATVid::Orientation GetMouseWheelOrientation() const;
  /**
   * @param i_orientation set to @ref CATVid#Horizontal to make the mouse
   * wheel scroll sideways instead of top-down.
   */
  void SetMouseWheelOrientation(CATVid::Orientation i_orientation);
  /**
   * @return the distance of the mouse pointer from right or left sides 
   * of the viewport under which the scrollable will autoscroll during
   * a drag-and-drop. Default value is 5 dp.
   */
  int GetHAutoscrollMargins() const;
  /**
   * @param i_margins the autoscroll margins. Default value is 5 dp.
   *
   * @see #GetHAutoscrollMargins
   */
  void SetHAutoscrollMargins(int i_margins);
  /**
   * @return the distance of the mouse pointer from top or bottom sides 
   * of the viewport under which the scrollable will autoscroll during
   * a drag-and-drop. Default value is 5 dp.
   */
  int GetVAutoscrollMargins() const;
  /**
   * @param i_margins the autoscroll margins. Default value is 5 dp.
   *
   * @see #GetHAutoscrollMargins
   */
  void SetVAutoscrollMargins(int i_margins);

  /**
   * @return @ref #ScrollbarMovingState_NotMoving if we are not currently 
   * scrolling, @ref #ScrollbarMovingState_Moving else.
   */
  int GetHScrollbarMovingState() const;
  /**
   * @return @ref #ScrollbarMovingState_NotMoving if we are not currently 
   * scrolling, @ref #ScrollbarMovingState_Moving else.
   */
  int GetVScrollbarMovingState() const;

  /** 
   * Locks the update lock, then updates the whole scrollable area, then 
   * release the update lock.
   * An update is launched each time a new scrolled widget is set or a 
   * scrollbar changes of policy, as well as each time that @ref CATVidWidget 
   * requires it.
   *
   * @see CATVidWidget#Update
   */
  virtual void Update();

  /** 
   * Get the @c Scroll event. This event is sent each time that a scroll
   * action is performed on the scrollable. Listen to it if you need to add
   * behaviour at each scroll.
   * 
   * @par EventProperties
   *   @li Name: @c "Scroll"
   *   @li Type of propagation: @c NoPropagation
   *   @li Type of argument: @ref CATVidScrollEventArgs
   *
   * @return the event instance. @c AddRef has NOT been called on the returned 
   * pointer.
   */
  static CATSYPEvent * Scroll();
  /** 
   * Get the @c TopReached event. This event is sent each time that a scroll
   * action is performed on the scrollable, if the top of the scrolled widget
   * has reached the top of the viewport at the end of the scroll action. It is
   * not send during inertia animation as we do not want anything to happen
   * during animation (such as the scrolled widget being modified): the user
   * has to scroll without letting the mouse go until the limit is reached for
   * the event to be sent.
   * 
   * @par EventProperties
   *   @li Name: @c "TopReached"
   *   @li Type of propagation: @c NoPropagation
   *   @li Type of argument: @ref CATSYPEventArgs
   *
   * @return the event instance. @c AddRef has NOT been called on the returned 
   * pointer.
   */
  static CATSYPEvent * TopReached();
  /**
   * @return similar event to the @ref TopReached event, except that it is sent
   * when the bottom of the viewport is reached.
   *
   * @see TopReached
   */
  static CATSYPEvent * BottomReached();
  /**
   * @return similar event to the @ref TopReached event, except that it is sent
   * when the left side of the viewport is reached.
   *
   * @see TopReached
   */
  static CATSYPEvent * LeftReached();
  /**
   * @return similar event to the @ref TopReached event, except that it is sent
   * when the right side of the viewport is reached.
   *
   * @see TopReached
   */
  static CATSYPEvent * RightReached();

  /**
   * Returns the @c HScrollbarVisibleStateChanged event.
   * The @c HScrollbarVisibleStateChanged event is emitted whenever the horizontal scrollbar visiblity has changed.
   * @see GetHScrollbarVisibleState
   * @par EventProperties
   *   - Name: @c "HScrollbarVisibleStateChanged"
   *   - Type of propagation: @c NoPropagation
   *   - Type of argument: @ref CATSYPEventArgs
   * 
   * @return the event instance. @c AddRef has NOT been called on the returned pointer.
   */
  static CATSYPEvent * HScrollbarVisibleStateChanged();

  /**
   * Returns the @c VScrollbarVisibleStateChanged event.
   * The @c VScrollbarVisibleStateChanged event is emitted whenever the horizontal scrollbar visiblity has changed.
   * @see GetVScrollbarVisibleState
   * @par EventProperties
   *   - Name: @c "VScrollbarVisibleStateChanged"
   *   - Type of propagation: @c NoPropagation
   *   - Type of argument: @ref CATSYPEventArgs
   * 
   * @return the event instance. @c AddRef has NOT been called on the returned pointer.
   */
  static CATSYPEvent * VScrollbarVisibleStateChanged();

  /**
   * Sets a flag indicating that the viewport filter will be used only when the dimension of the 
   * scrolledwidget are upper the dimension of the scroll area. 
   * It can't be set as default, as some layout could position their children out of their bounds.
   */
  void SetOptimizeViewportFilterUsageFlag(int i_optimizeViewportFilterUsageFlag);
  /** @return the flag indicating that the viewport filter will be used only when the dimension of the 
   * scrolledwidget are upper the dimension of the scroll area. */
  int GetOptimizeViewportFilterUsageFlag() const;


   /**
   * Flag which permit to destroy all children at the destruction of the scrollable
   *
   * @return @c TRUE if children has to be destroy when the scrollable is destroyed, @c FALSE else.
   */
  CATBoolean GetDestroyAllChildrenFlag() const;
  void SetDestroyAllChildrenFlag(const CATBoolean& i_flag);


  /**
   * Ensure the visibility of children widget. @copydoc CATIVidEnsureVisible#EnsureWidgetVisibility.
   */
  HRESULT EnsureWidgetVisibility(CATVidWidget* i_pWidget);

protected:
  /** Destructor. */
  virtual ~CATVidCtlAbstractScrollableArea();
  /** 
   * Updates the whole scrollable area without locking nor checking the update 
   * lock.
   */
  virtual void UpdateWithoutLock(CATBoolean i_bStopInertia = TRUE);
  /** 
   * @see CATVidWidget#UpdateComputedMinimumDimension
   */
  virtual void UpdateComputedMinimumDimension();  
  /**
   * @return @c TRUE if the scrollable is the scrollable is currently updating, 
   * @c FALSE else.
   */
  CATBoolean GetUpdateLock() const;
  /**
   * Sets the update lock. When up, this lock prevents updating from occuring 
   * even if #Update is called. <br/>
   *
   * This lock is used to avoid reentrance in the update function of the 
   * scrollable.
   */
  void SetUpdateLock(CATBoolean i_locked);
  /**
   * @copydoc l_CATVidCtl#TemplateDataUpdated
   * Here are the mandatory "syp:named" objects : 
   * @li Presenter [CATVidCtl]
   * @li StretchGrid [CATVidLayGrid]
   * @li ScrolledWidgetArea [CATVidCtl]
   * And the optional ones :
   * @li VScrollbar [CATVidCtlScrollbar]
   * @li HScrollbar [CATVidCtlScrollbar]
   */
  virtual void TemplateDataUpdated();
  /**
   * Set @c HScrollbarMovingState to @ref #ScrollbarMovingState_Moving and 
   * launch a timer that will set the state to 
   * @ref #ScrollbarMovingState_NotMoving after @c i_fDuration seconds.
   *
   * @param i_fDuration time during which the "HScrollbarMoving" state must 
   * be activated, in seconds
   */
  void HIsTemporarilyScrolling(float i_fDuration = 0.3f);
  /**
   * Set @c VScrollbarMovingState to @ref #ScrollbarMovingState_Moving and 
   * launch a timer that will set the state to 
   * @ref #ScrollbarMovingState_NotMoving after @c i_fDuration seconds.
   *
   * @param i_fDuration time during which the "VScrollbarMoving" state must be 
   * activated, in seconds
   */
  void VIsTemporarilyScrolling(float i_fDuration = 0.3f);
  /**
   * @param i_iIsScrolling @ref #ScrollbarMovingState_NotMoving if we are not
   * currently scrolling, @ref #ScrollbarMovingState_Moving else.
   */
  void SetHScrollbarMovingState(int i_iIsScrolling);
  /**
   * @param i_iIsScrolling @ref #ScrollbarMovingState_NotMoving if we are not
   * currently scrolling, @ref #ScrollbarMovingState_Moving else.
   */
  void SetVScrollbarMovingState(int i_iIsScrolling);
  /**
   * Callback method on Timeout to change the scrollbar moving state.
   */
  static void OnHScrollingTimerCB(CATCommand * iCmd, int iTime, void * iClientData);
  /**
   * Callback method on Timeout to change the scrollbar moving state.
   */
  static void OnVScrollingTimerCB(CATCommand * iCmd, int iTime, void * iClientData);
  /**
   * Dispatch top, left, right and bottom reached events if the scrolled widget
   * has reached the limits of the viewport.
   *
   * @param i_bHorizontal check horizontal position if @c TRUE .
   * @param i_bVertical check vertical position if @c TRUE .
   */
  void DispatchLimitReachedEvents(CATBoolean i_bHorizontal, CATBoolean i_bVertical);
  CATVidCtlAbstractScrollableArea(CreateLetterFunc i_pCreateLetterFunc);

  virtual int EnsureMinViewportOf(CATMathPoint2Df & o_sizeToFit);
private:
  CATVidCtlAbstractScrollableArea (CATVidCtlAbstractScrollableArea &);
  CATVidCtlAbstractScrollableArea& operator=(CATVidCtlAbstractScrollableArea&original);
  /**
   * @return @c TRUE if the @c HStretchPolicy is @c StretchFit or 
   * @c NoStretchFit, @c FALSE else.
   */
  CATBoolean HMustFitScrolledWidget() const;
  /**
   * @return @c TRUE if the @c VStretchPolicy is @c StretchFit or 
   * @c NoStretchFit, @c FALSE else.
   */
  CATBoolean VMustFitScrolledWidget() const;
  /**
   * The size of the horizontal scroll extent on the widget in the
   * scrollable area is how much can be scrolled horizontally 
   * on the widget.
   *
   * @param i_extent the size of the horizontal scroll extent.
   */
  void SetHScrollExtent(int i_extent);
  /**
   * The size of the vertical scroll extent on the widget in the
   * scrollable area is how much can be scrolled vertically 
   * on the widget.
   *
   * @param i_extent the size of the vertical scroll extent.
   */
  void SetVScrollExtent(int i_extent);
  /**
   * Sets the visibility of the horizontal scrollbar.
   *
   * @param @c TRUE if the horizontal scrollbar must be visible, @c FALSE else. 
   */ 
  void SetHScrollbarVisibleState(CATBoolean i_state);
  /**
   * Sets the visibility of the vertical scrollbar.
   * @param @c TRUE if the horizontal scrollbar must be visible, @c FALSE else. 
   */ 
  void SetVScrollbarVisibleState(CATBoolean i_state);
  /**
   * Sets the visibility of the horizontal scroll indicator.
   *
   * @param @c TRUE if we are currently horizontally scrolling and the 
   * horizontal scrollbar must be visible, @c FALSE else. 
   */ 
  void SetHScrollIndicatorVisibleState(CATBoolean i_state);
  /**
   * Sets the visibility of the vertical scroll indicator.
   *
   * @param @c TRUE if we are currently vertically scrolling and the 
   * vertical scrollbar must be visible, @c FALSE else. 
   */ 
  void SetVScrollIndicatorVisibleState(CATBoolean i_state);
  /**
   * Updates the visibility of the scrollbars. The scrollbars are layouted only 
   * when they are visible. The new visibility states depend on whether there 
   * are scrollbars, the scrollbar policies, the viewport and the minimum 
   * dimension of the widget. 
   */
  void UpdateScrollbarsVisibleStates();
  /** 
   * Updates the size of the horizontal scroll extent.
   */
  void UpdateHScrollExtent();
  /** 
   * Updates the size of the vertical scroll extent.
   */
  void UpdateVScrollExtent();
  /**
   * To preserve visibility on the scrolled widget, we suppress the horizontal 
   * scrollbar when the height of the presenter is inferior to twice the 
   * minimum horizontal scrollbar height. 
   * We also suppress the horizontal scrollbar in case the width of the
   * presenter + margins area is smaller than the minimum width of an 
   * horizontal scrollbar, because the horizontal scrollbar would be too small 
   * to be displayed.
   *
   * This decision is independant from the policy of the scrollbar.
   * @return @c TRUE if the horizontal scrollbar must be supressed, @c FALSE 
   * else.
   */
  CATBoolean DimensionTooSmallForHScrollbar();
  /**
   * To preserve visibility on the scrolled widget, we suppress the vertical 
   * scrollbar when the height of the presenter is inferior to twice the 
   * minimum vertical scrollbar height. 
   * We also suppress the vertical scrollbar in case the height of the
   * presenter + margins area is smaller than the minimum height of an vertical 
   * scrollbar, because the vertical scrollbar would be too small to be 
   * displayed.
   *
   * This decision is independant from the policy of the scrollbar.
   * @return @c TRUE if the vertical scrollbar must be supressed, @c FALSE 
   * else.
   */
  CATBoolean DimensionTooSmallForVScrollbar();
  /**
   * Handler for @ref CATVidGP#Press event
   * uses press event to compute the initialization of the scroll and the inertia.
   * Don't consume the event.
   *
   * This handler must only be registered on a CATVidCtlScrollableArea.
   */ 
  void HandlePress(CATBaseUnknown *i_pSender, CATVidMouseEventArgs *i_pArgs);
  /** 
   * Handler for @ref CATVidGP#Drag event
   * uses drag event to compute the scroll. Consumes the event.
   *
   * This handler must only be registered on a CATVidCtlScrollableArea.
   */ 
  void HandleDrag(CATBaseUnknown *i_pSender, CATVidMouseEventArgs *i_pArgs);
  /** 
   * TO REMOVE @see CATVidGP::TouchMove
   * Handler for @ref CATVidGP#TouchScroll event
   * uses move touch gesture to compute the scroll. Consumes the event.
   *
   * This handler must only be registered on a CATVidCtlScrollableArea.
   */ 
  void HandleTouchMove(CATBaseUnknown *i_pSender, CATVidTouchEventArgs *i_pArgs);
  /** 
   * Handler for @ref CATVidGP#Leave event
   * uses leave event to compute inertia if inertiaFlag is set
   * is set to TRUE. Don't consume the event.
   *
   * This handler must only be registered on a CATVidCtlScrollableArea.
   */ 
  void HandleReleaseEvt(CATBaseUnknown *i_pSender, CATVidMouseEventArgs *i_pArgs);
  /**
   * Add event handlers on the scrolledwidgetarea for touch scroll events. 
   */
  virtual void AddEventHandlers();
  /**
   * @param i_state @c TRUE if an horizontal scrolling is possible, @c FALSE 
   * else.
   *
   * @see #GetHScrollNeededState
   */
  void SetHScrollNeededState(const CATBoolean & i_state);
  /**
   * @param i_state @c TRUE if a vertical scrolling is possible, @c FALSE 
   * else.
   *
   * @see #GetVScrollNeededState
   */
  void SetVScrollNeededState(const CATBoolean & i_state);
  /** @see #GetHScrollNeededState */
  void UpdateHScrollNeededState(); 
  /** @see #GetVScrollNeededState */
  void UpdateVScrollNeededState();

  /**
   * Called during drag-and-drop when the mouse pointer moves over the
   * scrollable. Scroll if said pointer is near the top, bottom, left or right
   * end of the scrollable.
   * 
   * @param i_pSender the GP currently hovered
   * @param i_pArgs arguments of the event
   *
   * @see CATVidGP#PreDrop
   */
  void OnPreDrop(CATBaseUnknown * i_pSender, CATVidDnDEventArgs * i_pArgs);

  /** @see #EnsureWidgetVisible and #IsWidgetVisible */
  HRESULT GetWidgetDeltaInViewport(CATVidWidget *iChildWidget, int &oDeltaX, int &oDeltaY);

private:
  /**
   * The size of the horizontal scrolling extent on the widget in the
   * scrollable area, that is how much can be scrolled horizontally 
   * on the widget.
   */ 
  int _iHScrollExtent;
  /**
   * The size of the vertical scrolling extent on the widget in the
   * scrollable area, that is how much can be scrolled vertically on 
   * the widget.
   */
  int _iVScrollExtent;
  /**
   * The side of display of the horizontal scrollbar (@ref CATVid#Top or 
   * @ref CATVid#Bottom). 
   */
  CATVid::Side _eHScrollbarSide;
  /**
   * The side of display of the vertical scrollbar (@ref CATVid#Left or 
   * @ref CATVid#Right). 
   */
  CATVid::Side _eVScrollbarSide;
  /**
   * The horizontal scrollbar policy (see @ref CATVid#ScrollbarPolicy).
   * Not used for the template with no scrollbars.
   */
  CATVid::ScrollbarPolicy _eHScrollbarPolicy;
  /**
   * The vertical scrollbar policy (see @ref CATVid#ScrollbarPolicy).
   * Not used for the template with no scrollbars.
   */
  CATVid::ScrollbarPolicy _eVScrollbarPolicy;
  /**
   * @c TRUE if the horizontal scrollbar is visible, @c FALSE else. Depends on 
   * whether there are scrollbars, the scrollbar policy, the viewport and the 
   * minimum dimension of the widget.
   */ 
  CATBoolean _bHScrollbarVisibleState;
  /**
   * @c TRUE if the horizontal scrollbar is visible, @c FALSE else. Depends on 
   * whether there are scrollbars, the scrollbar policy, the viewport and the 
   * minimum dimension of the widget.
   */ 
  CATBoolean _bVScrollbarVisibleState;
  /**
   * @c TRUE if the horizontal scroll indicator is visible, @c FALSE else. 
   */ 
  CATBoolean _bHScrollIndicatorVisibleState;
  /**
   * @c TRUE if the horizontal scroll indicator is visible, @c FALSE else. 
   */ 
  CATBoolean _bVScrollIndicatorVisibleState;
  /**
   * @c TLMargins.x is the length of the left margin, 
   * @c TLMargins.y the length of the top margin.
   */
  CATMathPoint2Df _TLMargins;
  /**
   * @c BRMargins.x is the length of the right margin, 
   * @c BRMargins.y the length of the bottom margin.
   */
  CATMathPoint2Df _BRMargins;
  /**
   * Weak rek on the top widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrTWidget;
  /**
   * Weak rek on the bottom widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrBWidget;
  /**
   * Weak rek on the right widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrRWidget;
  /**
   * Weak rek on the left widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrLWidget;
  /**
   * Weak rek on the top-left widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrTLWidget;
  /**
   * Weak rek on the bottom-left widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrBLWidget;
  /**
   * Weak rek on the top-right widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrTRWidget;
  /**
   * Weak rek on the bottom-right widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrBRWidget;
  /**
   * Weak rek on the background widget. Contains a @c CATVidWidget.
   */
  CATBaseUnknown_WR _wrBackgroundWidget;
  /**
   * The horizontal stretch policy (see @ref CATVid#StretchPolicy).
   */
  CATVid::StretchPolicy _eHStretchPolicy;
  /**
   * The vertical stretch policy (see @ref CATVid#StretchPolicy).
   */
  CATVid::StretchPolicy _eVStretchPolicy;
  /**
   * Lock on the update. The scrollable area cannot update itself while it is 
   * already updating.
   */
  CATBoolean _bUpdateLock;
  /**
   * @c TRUE by default, allowing the user to pick the scroll widget and scroll
   * it horizontally and vertically with mouse and keyboard events.
   */
  CATBoolean _bPickAndScrollFlag;
  /**
   * @see #SetScrollbarsOnlyOnScrollFlag
   */
  CATBoolean _bScrollbarsOnlyOnScrollFlag;
  /**
   * Horizontal alignment of the scrolled widget inside the scrollable.
   */
  CATVid::Alignment _eHAlignment;

  /**
   * Fmag which permit to destroy all the scrollable children when the scrollable is destroyed
   */
  CATBoolean _destroyAllChildrenFlag;
  /**
   * Vertical alignment of the scrolled widget inside the scrollable.
   */
  CATVid::VAlignment _eVAlignment;
  /** @see #GetHSingleStep */
  int _iHSingleStep;
  /** @see #GetVSingleStep */
  int _iVSingleStep;
  /** @see #GetHAutoscrollMargins */
  int _hAutoscrollMargins;
  /** @see #GetVAutoscrollMargins */
  int _vAutoscrollMargins;

  /* Touch Scroll and Mouse Scroll private members */
  unsigned int _lockOneDirectionOnScrollFlag :1;  // see getter/setter
  unsigned int _vInertiaFlag :1;  // see getter/setter
  unsigned int _hInertiaFlag :1;  // see getter/setter
  unsigned int _vReboundFlag :1;  // see getter/setter
  unsigned int _hReboundFlag :1;  // see getter/setter
  unsigned int _hScrollNeeded :1; // see getter/setter
  unsigned int _vScrollNeeded :1; // see getter/setter
  unsigned int _mouseScrollFlag :1;  // see getter/setter
  unsigned int _hScrollbarPlaceholderFlag :1; // see getter/setter
  unsigned int _vScrollbarPlaceholderFlag :1; // see getter/setter
  unsigned int _shrinkScrolledWidgetFlag :1; // see getter/setter
  unsigned int _alwaysDispatchLimitReachedFlag :1; // see getter/setter

  CATVid::Orientation _mouseWheelOrientation;

  /** 
   * @ref #ScrollingState_Moving while scrolling, 
   * @ref #ScrollingState_NotMoving else. 
   */
  int _iHScrollbarMovingState;
  /** 
   * @ref #ScrollingState_Moving while scrolling, 
   * @ref #ScrollingState_NotMoving else. 
   */
  int _iVScrollbarMovingState;
  /** Last timeout used for @ref #HScrollingTimeOutCB */
  int _hScrollingTimeOut;
  /** Last command used for @ref #HScrollingTimeOutCB */
  CATCommand * _pHScrollingCommand;
  /** Last timeout used for @ref #HScrollingTimeOutCB */
  int _vScrollingTimeOut;
  /** Last command used for @ref #HScrollingTimeOutCB */
  CATCommand * _pVScrollingCommand;

  friend class CATVidCtlTreeColumn;
};

//-----------------------------------------------------------------------------

#endif

