//===================================================================
// COPYRIGHT Dassault Systemes 2020/06/16
//===================================================================
// CATOmbILockByteLoader.cpp
// Header definition of class CATOmbILockByteLoader
//===================================================================
//
// Usage notes:
//			this class is used to prepare CGR streams in visumode 
//			for parallel loading (FUN098013 - CGR multithread)
//
//===================================================================
//  2020/06/16 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATOmbILockByteLoader_H
#define CATOmbILockByteLoader_H

#include "CATOmbSelectiveLoading.h"
#include "CATObjectModelerBase.h"
#include "CATOmxList.h"
#include "CATOmxClassManager.h"
#include "CATOmxDefaultCollecManager.h"
#include "CATOmxArray.h"
#include "CATBaseUnknown.h"
#include "CATDocument.h"
#include "CATLISTP_CATOmiSwitchOperation.h"
#include "CATOmxSR.h"

//-----------------------------------------------------------------------
class CATDocument;
class CATILockBytes2;
class CATComponentId;
class CATVVSURLConnection;
struct CATOmbSwitchOperation;
class CATOmbStreamDescriptorObjectImpl;

enum CATOmbLoadingStatus
{
  ToLoad,
  LoadingFailed,
  AlreadyLoaded,
  Loaded,
  LoadedInPrepare
};



class ExportedByCATOmbSelectiveLoading CATOmbLoaderInfo : public CATBaseUnknown
{
public:
  // Copy constructor and equal operator
  // -----------------------------------
  CATOmbLoaderInfo();
  /**
  * Prepare an Sd by creating the associated CATDocument and return CATOmbLoaderinfo Object with the created CATDocument and associated LockByte.
  * <b>Role</b>
  * @param iSd [in]
  *   the StreamDescriptor pointer
  * @param iCID [in]
  *   the ComponentId
  * @param oCGRInfo [Out]
  *   the prepared Object containing the CATDocument (GetCATDocument()) and LockByte (GetLockByte())
  * @return <ul>
  *            <li> S_OK : if the preparation is succesfull
  *            <li> E_FAIL : unexpected error ie : Can't open document, can't get or establish connection etc ..
         <li> S_OK and oLoaderInfo is null : openned sequentially (in case of Converter usage) note : this return can be changed
  *         </ul>
  */
  static HRESULT PrepareLoaderInfo(CATOmbStreamDescriptorObjectImpl* iSd, const CATComponentId iCID, CATOmxSR<CATOmbLoaderInfo>& oLoaderInfo);
  /**
  * Opens a list of LockByte in Multithread et return result.
  * <b>Role</b>
  * @param ioLoaderInfoList [in]
  *   the CATOmbLoaderInfo list
  * @return <ul>
  *            <li> S_OK : if the open is succesfull all status is Loaded
  *            <li> E_FAIL : if every open operation failed all status is LoadingFailed
  *		  	 <li> S_FALSE : if some open operation failed in this case you must test on every CATOmbLoaderInfo item (GetStatus() != Loaded)
  */
  static HRESULT ParallelOpen(CATOmxList<CATOmbLoaderInfo>& ioLoaderInfoList);
  /**
  * Finalise Open after using ParallelOpen.
  * <b>Role</b>
  * @param ioLoaderInfoList [in]
  *   the CATOmbLoaderInfo list
  * @return <ul>
  *            <li> S_OK : finalise successfull
  *            <li> E_FAIL : Something went wrong
  */
  static HRESULT FinaliseOpen(CATOmxSR<CATOmbLoaderInfo>& oLoaderInfo);
  /**
  * Get the CATDocument (does not AddRef)
  */
  inline CATDocument* GetCATDocument() const { return const_cast<CATDocument*>(_pDoc.Ref()); }
  /**
  * Get the CATILockBytes2 (does not AddRef)
  */
  inline CATILockBytes2* GetLockByte() const { return const_cast<CATILockBytes2*>(_iLB.Ref()); }
  /**
  * Set the Loading status (Loaded/ToLoad/LoadingFailed)
  */
  inline void SetStatus(const CATOmbLoadingStatus iStatus) { _Status = iStatus; }
  /**
  * Get the Loading status
  */
  inline CATOmbLoadingStatus GetStatus() const { return _Status; }

  virtual ~CATOmbLoaderInfo();
private:
  CATOmbLoaderInfo(const CATOmbLoaderInfo&);
  CATOmbLoaderInfo& operator=(const CATOmbLoaderInfo&);
  //Data
  CATOmbStreamDescriptorObjectImpl* _Sd;
  CATVVSURLConnection* _pUrlConnection;
  CATBoolean _bNewConnection;
  CATBoolean _DocumentUnstreamedFromExternalFormat;
  CATOmxSR<CATDocument> _pDoc;
  CATOmxSR<CATILockBytes2> _iLB;
  CATOmbLoadingStatus _Status;

  CATBoolean WasLoadingSuccessfull() { return _Status >= Loaded; }

  CATBoolean CleanAfterLoading() { return (_Status == Loaded || _Status == LoadedInPrepare) ; }

  CATOmbLoaderInfo(
    CATOmbStreamDescriptorObjectImpl* iSd, CATDocument* pDoc
    , CATILockBytes2* iLB, const CATBoolean& newConnection
    , CATVVSURLConnection* pUrlConnection);

  CATOmbLoaderInfo(
    CATOmbStreamDescriptorObjectImpl* iSd, CATDocument* pDoc
    , CATILockBytes2* iLB, const CATBoolean& newConnection
    , CATVVSURLConnection* pUrlConnection
    , const CATOmbLoadingStatus& pStatus);

  CATOmbLoaderInfo(
      CATOmbStreamDescriptorObjectImpl* iSd
    , CATDocument* pDoc);
};

template<> CATOmxCollecManager& CATOmxDefaultCollecManager<CATOmbLoaderInfo>::manager();
//-----------------------------------------------------------------------

#endif
