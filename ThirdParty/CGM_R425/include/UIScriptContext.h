//===================================================================
// COPYRIGHT Dassault Systemes 2013/04/02
//===================================================================
// UIScriptContext.cpp
// Header definition of class UIScriptContext
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2013/04/02 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef UIScriptContext_H
#define UIScriptContext_H

#include "UIScriptBase.h"

// System
#include "CATUnicodeString.h"
#include "CATListPV.h"
#include "CATBaseUnknown_WR.h"

// ECMAScriptEngine
#include "ESUniverse.h"
#include "ESWorld.h"
#include "ESType.h"
#include "ESArray.h"

// UIVCoreTools
#include "CATSYPHashMap.h"
#include <CATSYPArray.h>

// UIScriptBase
class UIScriptBinderBase;

/**
 * <b>Role</b>: A context dedicated to run scripts with ready-to-use UI dedicated services.
 *
 * Create a context where you can run scripts with ready-to-use UI dedicated services
 *
 * Lifecycles of these contexts is performed through the UIScriptContextFactory unique instance.
 *
 * Several binders can be registered on contexts to provide additional features. 
 * For instance, registering a VID binder, will allow you to use VID specific features inside your scripts.
 *
 * @see UIScriptContextFactory
 * @see UIScriptBinderBase
 */
class ExportedByUIScriptBase UIScriptContext: public CATBaseUnknown
{
  CATDeclareClass;
public:

  /**
   * Constructor.
   * @param i_Universe the universe where the context is created 
   * @param i_WorldIdentifier the unique identifier to retrieve the context into given universe
   */
  UIScriptContext (ES::Universe* i_Universe, const CATUnicodeString& i_WorldIdentifier);

  /**
   * Destructor.
   */
  virtual ~UIScriptContext ();

  /**
   * DisconnectWorld. This method allows you to disconnect the internal context world. 
   * Use this method ONLY when you have created a UIScriptContext on an existing world. 
   */
  void DisconnectWorld(); 

  /**
   * Commits modifications done to the context. After commit, all the added functions will be available in scripting.
   * It is allowed to commit same context multiple times (on the contrary to types).
   */
  void Commit(); 

  /**
   * Evaluate a string as a piece of ECMAScript code. This method executes the interpreted code in the context. 
   * @param i_Source the string to evaluate in the current context. 
   * @return E_FAIL if the string evaluation fails, S_OK otherwise.
   */
  HRESULT Evaluate(const CATUnicodeString& i_Source);

  /**
   * Load a script and execute it inside the current context. 
   * @param iPath the path of the script
   * @param iCollectGarbage call the garbage collector or not 
   * @return E_FAIL if the script loading and/or execution fail, S_OK otherwise.
   */
  HRESULT LoadScript(const CATUnicodeString& i_Path, CATBoolean iCallCollectGarbage=TRUE);

  /**
   * @return the ESWorld instantiated behind the context object
   */
  ES::World* GetESWorld() { return _esWorld; }

  /**
   * Retrieve the source code of a script at a given path.
   * @param i_Path the script path 
   * @param o_Source the file source at the given script path
   * @return E_FAIL if the script path is invalid and/or the script file is invalid, S_OK otherwise.
   */
  static HRESULT GetFileSource(const CATUnicodeString& i_Path, CATUnicodeString& o_Source);

  /**
   * Get the ECMAScript object (used by a script) that represents a given c++ object
   * @param i_Obj the c++ object 
   * @return the ECMAScript object that represents the given c++ object, NULL if the c++ object has no ECMAScript object representation.
   */
  ES::Object GetNativeObject(CATBaseUnknown* iObj);

  /**
   * Create an ECMAScript object (used by a script) based on a c++ object. 
   * If an ECMAScript object already represent this c++ object, the same ECMAScript object is returned. 
   * @param i_Obj the c++ object. 
   * @return the created ECMAScript object, NULL if the object creation fails. 
   */
  ES::Object CreateInstanceObject(CATBaseUnknown* iObj);

  /**
   * Destroy an object explicitly from a script. 
   * @param i_Obj the ECMAScript object to destroy. This method destroys the ECMAScript object and the c++ object that it represents. 
   */
  void DestroyNativeObject(void* i_Obj); 

  /**
   * Register a binder on the current context. Registering an additional binder will give you additional bindings and so additional features that
   * could be used in your scripts.
   * @param i_Binder the binder to register.
   */
  void RegisterBinder(UIScriptBinderBase* i_Bbinder); 

  /**
   * Unregister a given binder from the current context. Unregistering a binder will make unavailable all the features provided by this binder.
   * @param i_Binder the binder to unregister. 
   */
  void UnregisterBinder(UIScriptBinderBase* i_Binder); 

  /**
   * @return the number of binders actually bind to the context.
   */
  int GetBinderCount() { return _binders->Size();}; 

  /**
   * @param i_Index the index of the binder to retrieve. 
   * @return the binder at the given index. 
   */
  UIScriptBinderBase* GetBinder(int i_Index);

  /**
   * Add an Event Listener on an object 
   * @param i_Obj the c++ object
   * @param i_EventType the event type as a string parameter ("Click" for instance)
   * @param i_Listener the ES::Function to execute when the event is triggered
   */
  void AddEventListener(CATBaseUnknown* i_Obj, const CATUnicodeString& i_EventType, const ES::Function& i_Listener);

  /**
   * Remove an Event Listener on an object 
   * @param i_Obj the c++ object
   * @param i_EventType the event type as a string parameter ("Click" for instance)
   * @param i_Listener the listener to remove on this object
   */
  void RemoveEventListener(CATBaseUnknown* i_Obj, const CATUnicodeString& i_EventType, const ES::Function& i_Listener);

  /**
   * Expose a native instance to the ECMAScript World. This object is added to the global object as a property named iObjectName.
   * @param iObj the c++ object
   * @param iObjectName the ECMAScript variable name to give for this native instance
   * @return E_FAIL if the exposition has failed, S_OK otherwise
   */
  HRESULT ExposeInstanceObject(CATBaseUnknown* iObj, const CATUnicodeString& iObjectName);

  /**
   * Expose a native instance as a property of a targeted ESObject.
   * @param iObj the c++ object to expose as child property
   * @param iTarget the targeted ESObject 
   * @param iTargetProperty the name of the child property to create
   * @return E_FAIL if the exposition has failed, S_OK otherwise
   */
  HRESULT ExposeInstanceObject(CATBaseUnknown* iObj, ES::Object& iTarget, const CATUnicodeString& iTargetProperty);

  /**
   * Expose a native instance as an element of a targeted ESArray.
   * @param iObj the c++ object to expose as child property
   * @param iTarget the targeted ESArray 
   * @param iTargetIndex the index in the targeted array
   * @return E_FAIL if the exposition has failed, S_OK otherwise
   */
  HRESULT ExposeInstanceObject(CATBaseUnknown* iObj, ES::Array& iTarget, unsigned int iTargetIndex);

protected:
  /**
   * Create an ECMAScript object (used by a script) based on a c++ object and a class name. 
   * If an ECMAScript object already represent this c++ object, the same ECMAScript object is returned. 
   * The class name is not necessary the real type of the c++ object. For instance, you could used the parent class type instead of the 
   * real type to create the ECMAScript object used in the script. 
   * @param i_Obj the c++ object. 
   * @param i_ClassName the class name used to create the ECMAScript object. 
   * @return the created ECMAScript object, NULL if the object creation fails. 
   */
  ES::Object CreateNativeObject(CATBaseUnknown* i_Obj, const char* i_ClassName); 

private:

  // Copy constructor and equal operator
  // -----------------------------------
  UIScriptContext (UIScriptContext &);
  UIScriptContext& operator=(UIScriptContext&);

  void _Initialize();
  void _Uninitialize(); 
  static HRESULT _GetStream(const CATUnicodeString& iPath, CATUnicodeString& oStream);
  // Debug purpose
  int _GetNativeObjectCount() { return _nativeToEsInstancesMap->GetSize(); } 
  void _ClearESInstancesMap();
  HRESULT _TemporaryExposedToFillProperties(ES::Object& iObj);

  ES::Universe* _esUniverse;
  ES::World* _esWorld;
  CATUnicodeString _esWorldIdentifier; 
  CATSYPHashMap<CATBaseUnknown_WR*, ES::NativeObject, CATSYPHashMapPointerHasher>* _nativeToEsInstancesMap;
  CATSYPDynArray<CATBaseUnknown*> _eventHandlerWrappers;
  CATListPV* _binders; 

  friend class UIScriptTst_UIScriptBinder;
  friend class UIScriptTst_UIScriptVIDBinder;
};

//-----------------------------------------------------------------------

#endif
