// COPYRIGHT Dassault Systemes 2009
//===================================================================
//
// PLMI3DFlexiblePositionServices.h
//
//===================================================================
//  Jul 2009  Creation: Code generated by the CAA wizard  VVG
//===================================================================
#ifndef PLMI3DFlexiblePositionServices_H
#define PLMI3DFlexiblePositionServices_H

/**
 * @level Private
 * @usage U3
 */

#include "CATPLMModelerPublicationItf.h"
#include "CATBaseUnknown.h"

#include "PLMI3DPositionServices.h"

class PLMIPublication;
class CATListPtrCATIPLMComponent;
class CATListValCATIPLMComponent_var;
class CATMathTransformation;

class CATListValCATBaseUnknown_var;
class CATIMovable_var;


#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATPLMModelerPublicationItf IID IID_PLMI3DFlexiblePositionServices;
#else
extern "C" const IID IID_PLMI3DFlexiblePositionServices ;
#endif

#define CATPrd3DFlexiblePositionServices_Component "CATPrd3DFlexiblePositionServices"

//------------------------------------------------------------------

/**
* Interface providing services related to 3D positioning, to be implemented by 3D _flexible_ PLM modelers
* Don't use this interface dedicated to Product Only
* LIMITED ACCESS, TO BE CALLED ONLY BY AUTHORIZED FRIENDLY ff 
* @example
*  PLMI3DFlexiblePositionServices *pPLM3DFlexiblePositionServices = NULL;
*  if (SUCCEEDED(::CATInstantiateComponent(CATPrd3DFlexiblePositionServices_Component,IID_PLMI3DFlexiblePositionServices,(void **)&pPLM3DFlexiblePositionServices))&&pPLM3DFlexiblePositionServices)
*  {
*    ...
*  }
*  CATSysReleasePtr(pPLM3DFlexiblePositionServices);
*/
class ExportedByCATPLMModelerPublicationItf PLMI3DFlexiblePositionServices: public CATBaseUnknown
{
  CATDeclareInterface;
public:
private:

  // authorized usages of this interface by these classes of 3D positioning software only:
  friend class PLM3DPositionServices;

  /**
  * Service to compute the absolute position of an object of a 3D modeler (instance or occurrence) identified
  * by the input description path <tt>iPathTo3DObject</tt>, also taking into account any position overloadings.
  * Don't use this interface dedicated to Product Only
  *
  *  @param  iPathTo3DObject
  *      A path of instances describing the 3D object which position will be computed. Size is 1 if the 3D object is a simple instance.<br>
  *      Input Parameter. <br>
  *      This path must not be provided by caller as empty!
  *      This path must be valid in terms of isaninstanceof/isownedby/isaninstanceof/isownedby/... relationships between its items.
  *  @param  oAbsoluteCumulatedPosition
  *      The absolute cumulated position of the 3D object returned. <br>
  *      Output parameter. <br>
  *      This parameter is correctly valuated if method succeeds. Otherwise its value (Identity) is nonsense.
  *  @return
  *      <code>S_OK</code> if the method succeeds. <br>
  *      <code>E_INVALIDARG</code> if <tt>iPathTo3DObject</tt> parameter provided is invalid. <br>
  *      <code>E_FAIL</code> otherwise. <br>
  */
  virtual HRESULT GetAbsPosition(CATListPtrCATIPLMComponent const & iPathTo3DObject, CATMathTransformation & oAbsoluteCumulatedPosition) const = 0;

#ifdef CATIAR424
  /** See PLMI3DPositionServices*/
  virtual HRESULT ComputeMovablePath_FixedContext(CATOmxList<CATBaseUnknown> const & iPOFI, size_t & oSizeOfMovingPath) const = 0;

  /** See PLMI3DPositionServices*/
  virtual HRESULT ComputeMovablePath_FixedTarget(CATOmxList<CATBaseUnknown> const & iPOFI, size_t & oSizeOfMovingPath) const = 0;

  /** See PLMI3DPositionServices*/
  virtual HRESULT ComputeMovablePath_FixedContext_LegacyPMR(CATOmxList<CATBaseUnknown> const & iPOFI, size_t & oSizeOfMovingPath) const = 0;
  /** See PLMI3DPositionServices*/
  virtual HRESULT ComputeMovablePath_FixedTarget_LegacyPMR(CATOmxList<CATBaseUnknown> const & iPOFI, size_t & oSizeOfMovingPath) const = 0;
  
  /** See PLMI3DPositionServices*/
  virtual HRESULT CanBeRepositioned(CATOmxList<CATBaseUnknown> const & iPOFI, bool & oCanBeRepositioned) const = 0;
#endif //CATIAR424

  /*
  * For a given occurrence path, smartly compute on which object (occurrence/instance) a 3D transformation 
  * can be applied, taking into account the repositionable subpathes and a user strategy (see below).
  * Don't use this interface dedicated to Product Only
  *
  * - If the input path position cannot be overloaded, a shorter overloadable occurrence is searched for. 
  *   The search is guided by a user strategy.
  * - If no occurrence can be overloaded, a first instance is returned.
  * 
  * 
  *
  * @param iPOFI
  *   Path of the occurrence to move.
  *   The consistency of the POFI is not checked.
  *
  * @param iStrategy
  *   Fixed Context, Fixed Target or NoSearch.
  *   The strategy is used to capture the user intention. When several objects (repositionable occurrences, instances)
  *   can be moved it defines which option must prevail.
  *
  *   - FixedContext : the move is performed in the context of the father of the 1st element's of the path.
  *     - the repositionable subpaths are searched exclusively in the immediate sub context
  *     - the longest repositionable subpath is used to build the moved subpath
  *     - if no repositionable is found, the 1st instance of the path is moved.
  *
  *   - FixedTarget : the occurrence moved must target the last element of the path.
  *     - the repositionable subpaths tested target the last element of the path 
  *     - the longest repositionable subpath is used to build the moved subpath 
  *       (starting from the second element of the path)
  *     - if no repositionable is found, the target instance is moved.
  *
  * @param ospMovingPath
  *   Occurrence which can actually move. This path is garanteed to be movable 
  * when used with the ApplyTransformation and SetPosition methods below.
  *
  * @return
  *      <code>S_OK</code> if the the moving path could be computed.<br>
  *      <code>E_FAIL</code> otherwise. <br>
  */
  virtual HRESULT ComputeMovingPath(CATListValCATIPLMComponent_var & iPOFI, 
                                    PLMI3DPositionServices::RepositionableSearchStrategy iStrategy,
                                    CATListValCATIPLMComponent_var & ospMovingPath) = 0;

  /*
  * Sets the relative position of an occurrence (overload) or an instance.
  * The position of the occurrence {i1,i2,i3} can be overloaded if and only if 
  *   the path {i2,i3} is repositionable.
  * Use ComputeMovingPath with the "NoSearch" strategy to ensurethe position can be set for this path.
  * Don't use this interface dedicated to Product Only
  *
  * @param iPOFI
  *   Path of the occurrence to move.
  *   The consistency of the POFI is not checked.
  *
  * @return
  *   <code>S_OK</code> if the position has been overloaded on the occurrence (or set on the instance). <br>
  *   <code>E_INVALIDARG</code> if <tt>iTransfo</tt> is invalid. <br>
  *   <code>E_FAIL</code> otherwise. <br>
  */
  virtual HRESULT SetPosition(CATMathTransformation & iPosition,
                              CATListValCATIPLMComponent_var & iPOFI) = 0;

  /**
  * Indicates if an occurrence (in the form of an instances path) can be repositioned, that is if a position
  * overload can be defined for this occurrence.
  * Equivalent to ComputeMovingPath called with NoSearch strategy and an occurrence path (size >= 2),
  * lighter error management (returns FALSE...)
  * Don't use this interface dedicated to Product Only
  *
  * @param iPOFI
  *   Path of the occurrence to check. At least 2 elements.
  *   The consistency of the POFI is not checked.
  *
  * @return
  *   <code>TRUE</code> if the occurrence can be repositionned.<br>
  *   <code>FALSE</code> otherwise.<br>
  */
  virtual CATBoolean CanBeRepositioned(CATListValCATIPLMComponent_var & iPOFI) = 0;

  /**
  * Indicates if an occurrence (in the form of an instances path) is repositioned. 
  * Don't use this interface dedicated to Product Only
  * 
  * @param iPOFI
  *   Path of the occurrence to check. At least 2 elements.
  *   The consistency of the POFI is not checked.
  *
  * @param ibCheckOnInputPathOnly
  *   Consider or not the overloads set in subcontexts:
  * 
  *   - If 'ibCheckOnInputPathOnly' is FALSE (default), 'Repositioned' means that the position of the occurrence 
  *     is different from the composition of the instances positions. 
  *     The overload does not need to be defined specifically for this path, but may have been set for a subpath : 
  *     {i1, i2, i3} will be said 'repositioned ' if an overloaded position has been set on {i2, i3}
  *     Hence, IsRepositioned may be TRUE, although CanBeRepositioned is FALSE for the same input path.
  * 
  *   - If 'ibCheckOnInputPathOnly' is TRUE, the method checks a position overload has been specificaly defined for the input path.
  *     In this case IsRepositioned => CanBeRepositioned.
  *
  * @return
  *   <code>TRUE</code> if the occurrence is repositionned.<br>
  *   <code>FALSE</code> otherwise.<br>
  */
  virtual CATBoolean IsRepositioned(CATListValCATIPLMComponent_var & iPOFI, CATBoolean ibCheckOnInputPathOnly = FALSE) = 0;

  /*
    DO NOT USE
  */
  virtual HRESULT GetPseudoMatrixForLegacyStamp(CATListPtrCATIPLMComponent const & iPathTo3DObject, PLMIPublication * ipPotentialPublication, CATMathTransformation & oPseudoMatrix, int const iLevelSensitivity) const = 0;

  // No constructors or destructors on this pure virtual base class
  // --------------------------------------------------------------
};

CATDeclareHandler(PLMI3DFlexiblePositionServices, CATBaseUnknown);
#endif
