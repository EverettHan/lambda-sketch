//===================================================================
// COPYRIGHT DS SolidWorks 2010/09/22
//===================================================================
// SWXUtVector.h
// Definition of SWXUtVector
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/09/22 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUTVECTOR_H
#define SWXUTVECTOR_H

#include <new>

#include "CATSysDataType.h"
#include "CATErrorMacros.h"
#include "SWXUtError.h"
#include "SWXUtTrackedIterator.h"
#include "SWXUtIteratorTracker.h"

template<class VALUETYPE> class SWXUtVector
{
public:
	typedef VALUETYPE ValueType_t;

	SWXUtVector() :
		mStart(NULL),
		mCurrent(NULL),
		mEnd(NULL)
	{
	}

	SWXUtVector(const SWXUtVector& iVector) :
		mStart(NULL),
		mCurrent(NULL),
		mEnd(NULL)
	{
		GrowByAtLeast(iVector.Size());

		for (ConstIterator it = iVector.Begin();it != iVector.End();it++)
		{
			PushBack(*it);
		}
	}

	SWXUtVector(size_t iSize) :
		mStart(NULL),
		mCurrent(NULL),
		mEnd(NULL)
	{
		Resize( iSize );
	}

	~SWXUtVector()
	{
		if (mStart != NULL)
		{
			DestructRange(mStart, mCurrent);

			::operator delete(mStart);

			mStart = NULL;
			mCurrent = NULL;
			mEnd = NULL;
		}
	}

	SWXUtVector& operator=(const SWXUtVector& iRight)
	{
		if (this != &iRight)
		{
			Clear();

			for(ConstIterator iter = iRight.Begin();iter != iRight.End();iter++)
			{
				PushBack(*iter);
			}
		}

		return *this;
	}

	class ConstIterator : public SWXUtTrackedIterator
	{
	public:
		ConstIterator() :
			SWXUtTrackedIterator(),
			mVector(NULL),
			mCurrent(NULL)
		{
		}

		ConstIterator(const SWXUtVector* iVector, ValueType_t* iCurrent) :
			SWXUtTrackedIterator(),
			mVector(iVector),
			mCurrent(iCurrent)
		{
			if (mVector != NULL)
			{
				((SWXUtVector*)mVector)->AddIterator(this);
			}
		}

		ConstIterator(const ConstIterator& iIterator) :
			SWXUtTrackedIterator(),
			mVector(iIterator.mVector),
			mCurrent(iIterator.mCurrent)
		{
			if (mVector != NULL)
			{
				((SWXUtVector*)mVector)->AddIterator(this);
			}
		}

		virtual ~ConstIterator()
		{
			if (mVector != NULL)
			{
				((SWXUtVector*)mVector)->RemoveIterator(this);

				mVector = NULL;
			}
		}

		virtual void InvalidateIter()
		{
			mVector = NULL;
		}

		ValueType_t& operator*() const
		{
			Validate();

			return *mCurrent;
		}

		ValueType_t* operator->() const
		{
			Validate();

			return &*mCurrent;
		}

		ConstIterator& operator=(const ConstIterator& iRight)
		{
			if (this != &iRight)
			{
				if (mVector != NULL)
				{
					((SWXUtVector*)mVector)->RemoveIterator(this);
				}

				mVector = iRight.mVector;
				mCurrent = iRight.mCurrent;

				if (mVector != NULL)
				{
					((SWXUtVector*)mVector)->AddIterator(this);
				}
			}

			return *this;
		}

		ConstIterator& operator++()
		{
			Validate();

			mCurrent++;

			return (*this);
		}

		ConstIterator& operator--()
		{
			Validate();

			mCurrent--;

			return (*this);
		}
		ConstIterator operator++(int)
		{
			ConstIterator _Tmp = *this;

			++*this;

			return (_Tmp);
		}
		ConstIterator operator--(int)
		{
			ConstIterator _Tmp = *this;

			--*this;

			return (_Tmp);
		}
		bool operator<(const ConstIterator& iRight) const
		{
			return mVector == iRight.mVector && mCurrent < iRight.mCurrent;
		}

		bool operator>(const ConstIterator& iRight) const
		{
			return mVector == iRight.mVector && mCurrent > iRight.mCurrent;
		}

		bool operator<=(const ConstIterator& iRight) const
		{
			return mVector == iRight.mVector && mCurrent <= iRight.mCurrent;
		}

		bool operator>=(const ConstIterator& iRight) const
		{
			return mVector == iRight.mVector && mCurrent >= iRight.mCurrent;
		}

		bool operator==(const ConstIterator& iRight) const
		{
			if (mVector == iRight.mVector)
			{
				return mCurrent == iRight.mCurrent;
			}

			return false;
		}

		bool operator!=(const ConstIterator& iRight) const
		{
			return (!(*this == iRight));
		}

		size_t operator-(const ConstIterator& iRight) const
		{
			return mCurrent-iRight.mCurrent;
		}

		ConstIterator operator+=(size_t iOff)
		{
			Validate();

			if (mCurrent+iOff > mVector->mCurrent || mCurrent+iOff < mVector->mStart)
			{
				CATThrow(new SWXUtError(SWXUtError::InvalidRange));
			}

			mCurrent += iOff;

			return *this;
		}

		ConstIterator operator+(size_t iOff) const
		{
			ConstIterator tmp = *this;

			return tmp += iOff;
		}

		ConstIterator operator-=(size_t iOff)
		{
			Validate();

			if (mCurrent-iOff >= mVector->mCurrent || mCurrent-iOff < mVector->mStart)
			{
				CATThrow(new SWXUtError(SWXUtError::InvalidRange));
			}

			mCurrent -= iOff;

			return *this;
		}

		ConstIterator operator-(size_t iOff) const
		{
			ConstIterator tmp = *this;

			return tmp -= iOff;
		}

	protected:
		typedef const SWXUtVector ConstSWXUtVector;

		ConstSWXUtVector *mVector;
		ValueType_t *mCurrent;

	private:
		bool InvalidateIfInRange(ValueType_t *iStart, ValueType_t *iEnd)
		{
			if (mCurrent >= iStart && mCurrent <= iEnd)
			{
				mCurrent = NULL;

				return true;
			}

			return false;
		}

		void Validate() const
		{
			if (mVector == NULL || mCurrent == NULL || mCurrent > mVector->mCurrent)
			{
				CATThrow(new SWXUtError(SWXUtError::InvalidIterator));
			}
		}

		friend class SWXUtVector;
	};

	class Iterator : public ConstIterator
	{
	public:
		Iterator() :
			ConstIterator()
		{
		}

		Iterator(const SWXUtVector* iVector, ValueType_t* iCurrent) :
			ConstIterator(iVector, iCurrent)
		{
		}

		Iterator(const Iterator& iIter) :
			ConstIterator(iIter)
		{
		}

		Iterator(const ConstIterator& iIter) :
			ConstIterator(iIter)
		{
		}

		Iterator& operator=(const Iterator& iRight)
		{
			if (this != &iRight)
			{
				ConstIterator::operator=(iRight);
			}

			return *this;
		}
	};


	void Append(const SWXUtVector& iVector)
	{
		GrowByAtLeast(iVector.Size());

		for (ConstIterator it = iVector.Begin();it != iVector.End();it++)
		{
			PushBack(*it);
		}
	}

	void PushBack(const ValueType_t& iVal)
	{
		if (Capacity() <= Size())
		{
			GrowByAtLeast(1);
		}

		::new ((void *)mCurrent) ValueType_t(iVal);

		mCurrent++;
	}

	void PopBack()
	{
		if (!Empty())
		{
			DestructRange(mCurrent-1, mCurrent);

			mCurrent--;
		}
	}

	ValueType_t& operator[](size_t iPos)
	{
		if (Size() <= iPos)
		{
			CATThrow(new SWXUtError(SWXUtError::InvalidRange));
		}

		return *(mStart+iPos);
	}

	const ValueType_t& operator[](size_t iPos) const
	{
		if (Size() <= iPos)
		{
			CATThrow(new SWXUtError(SWXUtError::InvalidRange));
		}

		return *(mStart+iPos);
	}

	size_t Size() const
	{
		return (mCurrent - mStart);
	}

	size_t Capacity() const
	{
		return (mEnd - mStart);
	}

	void Reserve(size_t iReserve)
	{
		if (iReserve > Capacity())
		{
			GrowTo(iReserve);
		}
	}

	bool Empty() const
	{
		return Size() == 0;
	}

	ConstIterator Begin() const
	{
		return ConstIterator(this, mStart);
	}

	ConstIterator End() const
	{
		return ConstIterator(this, mCurrent);
	}

	Iterator Begin()
	{
		return Iterator(this, mStart);
	}

	Iterator End()
	{
		return Iterator(this, mCurrent);
	}

	Iterator Erase(ConstIterator iWhere)
	{
		if (iWhere.mCurrent < mStart || iWhere.mCurrent > mCurrent)
		{
			CATThrow(new SWXUtError(SWXUtError::InvalidRange));
		}

		ValueType_t *ptr = iWhere.mCurrent;

		DestructRange(iWhere.mCurrent, iWhere.mCurrent+1);

		--mCurrent;

		for (;ptr < mCurrent;ptr++)
		{
			::new ((void*)ptr) ValueType_t(*(ptr+1));

			(ptr+1)->~ValueType_t();
		}

		return Iterator(this, iWhere.mCurrent);
	}

	void Clear()
	{
		DestructRange(mStart, mCurrent);

		mCurrent = mStart;
	}

	ValueType_t& Back()
	{
		return *(End()-1);
	}

	const ValueType_t& Back() const
	{
		return *(End()-1);
	}

	ValueType_t& Front()
	{
		return *Begin();
	}

	const ValueType_t& Front() const
	{
		return *Begin();
	}

	void Resize(size_t iNewSize)
	{
		Resize(iNewSize, ValueType_t());
	}

	void Resize(size_t iNewSize, ValueType_t iVal)
	{
		if (Size() < iNewSize)
		{
			GrowByAtLeast(iNewSize-Size());

			while(Size() < iNewSize)
			{
				PushBack(iVal);
			}
		}
		else if (iNewSize < Size())
		{
			DestructRange(mStart+iNewSize, mCurrent);

			mCurrent = mStart+iNewSize;
		}
	}

	void Sort()
	{
		if (Size() > 1)
		{
			InternalSort(Begin(), End()-1);
		}
	}

private:
	Iterator Partition(const Iterator &iLeft, const Iterator &iRight, const Iterator &iPivot)
	{
		ValueType_t pivotValue = *iPivot;

		*iPivot = *iRight;
		*iRight = pivotValue;

		Iterator index = iLeft;

		for (Iterator i = iLeft;i < iRight;i++)
		{
			if (*i < pivotValue)
			{
				ValueType_t tmp = *i;

				*i = *index;
				*index = tmp;

				index++;
			}
		}

		ValueType_t tmp = *iRight;

		*iRight = *index;
		*index = tmp;

		return index;
	}

	void InternalSort(const Iterator &iLeft, const Iterator &iRight)
	{
		if (iLeft < iRight)
		{
			Iterator pivot = iLeft + (iRight-iLeft)/2;

			pivot = Partition(iLeft, iRight, pivot);

			if (pivot > iLeft)
			{
				InternalSort(iLeft, pivot-1);
			}

			if (pivot < iRight)
			{
				InternalSort(pivot+1, iRight);
			}
		}
	}

	void DestructRange(VALUETYPE* iStart, VALUETYPE *iEnd)
	{
		InvalidateIterators(iStart, mEnd);

		for (ValueType_t* it = iStart; it < iEnd;it++)
		{
			it->~ValueType_t();
		}
	}

	void GrowByAtLeast(size_t iCount)
	{
		size_t capacity = Capacity();
		size_t size = Size();
		size_t newSize = size+iCount;

		if (capacity == 0)
		{
			capacity = 1;
		}
		else if (capacity < newSize)
		{
			capacity = capacity + capacity / 2;

			if (capacity < newSize)
			{
				capacity = newSize;
			}
		}

		GrowTo(capacity);
	}

	void GrowTo(size_t iCapacity)
	{
		ValueType_t *newStart = (ValueType_t*)::operator new(iCapacity*sizeof(ValueType_t));
		ValueType_t *newEnd = newStart+iCapacity;
		ValueType_t *newCurrent;
		ValueType_t *endPtr = newStart+Size();
		ValueType_t *ptr = mStart;

		for (newCurrent = newStart, ptr = mStart; newCurrent < endPtr;newCurrent++, ptr++)
		{
			::new ((void*)newCurrent) ValueType_t(*ptr);
		}

		InvalidateIterators(mStart, mEnd);

		DestructRange(mStart, mCurrent);

		::operator delete(mStart);

		mStart = newStart;
		mEnd = newEnd;
		mCurrent = newCurrent;
	}

	void AddIterator(ConstIterator* iIter)
	{
		mIteratorTracker.AddIterator(iIter);
	}

	void RemoveIterator(ConstIterator* iIter)
	{
		mIteratorTracker.RemoveIterator(iIter);
	}

	void InvalidateIterators(ValueType_t *iStart, ValueType_t *iEnd)
	{
		for (ConstIterator* iter = (ConstIterator*)mIteratorTracker.FirstIter();iter != NULL;)
		{
			ConstIterator* temp = (ConstIterator*)mIteratorTracker.NextIter(iter);

			if (iter->InvalidateIfInRange(iStart, iEnd))
			{
				RemoveIterator(iter);
			}

			iter = temp;
		}
	}

	ValueType_t* mStart;
	ValueType_t* mCurrent;
	ValueType_t* mEnd;

	SWXUtIteratorTracker mIteratorTracker;

	friend class ConstIterator;
};

#endif
