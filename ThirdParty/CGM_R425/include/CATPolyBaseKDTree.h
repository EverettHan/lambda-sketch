//===================================================================
// COPYRIGHT Dassault Systemes 2019/10/10
//===================================================================
// CATPolyBaseKDTree.cpp
// Header definition of class CATPolyBaseKDTree
//===================================================================
//
// Usage notes:
//
//
//===================================================================
//  2019/10/10 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATPolyBaseKDTree_H
#define CATPolyBaseKDTree_H

// PolyhedralMathematics
#include "Poly/Set.h"

// Mathematics
#include "CATMathPoint.h"
#include "CATMathFP.h"

// System
#include "CATErrorDef.h"

#include <limits>
#include <array>
#include <vector>
#include <queue>
#include <stack>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <type_traits>
#include <cstring>

/**
* This is the base class of CATPolyVertexKDTree and CATPolyTriangleKDTree.
* Unusable by itself, it is meant to factorize the tree structure, traversal methods, and multithreading infrastructure.
* As the methods used to build a kd-tree difer a lot depending on its real nature, these are not factorized.
* @tparam Element : refers to the type of geometrical primitive stored in the tree (vertex or triangle).
*/
template<typename Element>
class CATPolyBaseKDTree
{
public:

  /**
  * @brief Main constructor.
  */
  CATPolyBaseKDTree ();

  ~CATPolyBaseKDTree ();

protected:

  //////////////
  // Internal //
  //////////////

  struct Node;

  /**
  * The leaf is essentially an array of elements.
  * The array itself is always allocated right next to the leaf object itself in a single malloc call.
  */
  struct Leaf
  {
    unsigned int _Size; //!< Number of elements stored in this leaf.
    unsigned int _Capacity; //!< Maximum number of leaves storable in this leaf with respect to the current allocated capacity.

    static Leaf* CreateLeaf (const unsigned int iSize, const unsigned int iCapacity);

    const Element* GetElements () const;

    Element* GetElements ();
  };

  /**
  * Either a node or a leaf.
  */
  union Child
  {
    Node* _pNode;
    Leaf* _pLeaf;
  };

  /**
  * Main node class of the KD-Tree. 32 bytes (with padding) on a 64 bits system.
  */
  struct Node
  {
    Node ();
    ~Node ();

    unsigned char _CutDimension; //!< Along which axis is the node cut.
    bool _IsChildLeaf[2]; //!< Is son X a leaf ?
    bool _IsChildToUpdate[2]; //!< Has son X been edited since last update ?
    double _CutValue; //!< At which value along _CutDimension is the node cut.
    Child _Child[2]; //!< Children.
  };

protected:

  typedef std::array<double, 3> Position; // A 3D Point.
  typedef std::array<Position, 2> Box; // An axis-aligned bounding box made of its min and max points.

  class Bar
  {
  public:

    Bar ();

    Bar (const Position& iFstPoint, const Position& iSndPoint);

    Bar (const CATMathPoint iPositions[2]);

  public:

    unsigned char GetSides (const unsigned char iDim, const double iValue, const double iEpsilon) const;

    void Cut (const unsigned char iDim, const double iValue, const bool iSide, Bar& oBar);

    void Cut (const unsigned char iDim, const double iValue, const bool iSide);

  private:
    Position _Points[2];
  };

  /**
  * Class used to represent a convex polygon.
  * It is mainly used to traverse the tree with a triangle,
  * which will be cut by the splitting planes of the nodes as we traverse the tree.
  */
  class Polygon
  {
  public:

    Polygon ();

    /**
    * @brief Initializes the polygon with a triangle.
    */
    Polygon (const CATMathPoint iPositions[3]);

    /**
    * @brief Initializes the polygon with a triangle and a box splitting it.
    */
    Polygon (const CATMathPoint iPositions[3], const Box& iBox);

    Polygon (const Polygon& iOther);

    Polygon (Polygon&& iOther);

    ~Polygon ();

    Polygon& operator=(Polygon&& iOther);

    void Reset ();

  public:

    /**
    * The first two positions in the polygon are the extrema of its bounding box, if the polygon is not empty.
    */
    Position* GetBoundingBox () { return _pPoints; }

    /**
    * Are there positions in this polygon ?
    */
    bool IsEmpty () { return _NbPoints == 0; }

  private:

    /**
    * Add a new point at the end of the list, does not update the bounding box.
    */
    void Push (Position iPosition);
    void Push (const CATMathPoint& iPosition);

  public:

    /**
    * Cuts line (iBgn, iEnd) by plane point[iDim] == iValue.
    */
    static Position IntersectPlane (const unsigned char iDim, const double iValue, const Position& iBgn, const Position& iEnd);

  public:

    /**
    * Updates the bounding box with all positions inside.
    */
    void UpdateBox ();

    /**
    * Returns a two-bit code describing whether the polygon lies on the left (0), right (1) or on both sides (2)
    * of the plane point[iDim] == iValue with tolerance iEpsilon.
    */
    unsigned char GetSides (const unsigned char iDim, const double iValue, const double iEpsilon);

    /**
    * Cuts the polygon with plane point[iDim] == iValue into two polygons, with tolerance iEpsilon.
    */
    void Cut (const unsigned char iDim, const double iValue, const bool iSide, Polygon& oPolygon);

    /**
    * In-place variant of the previous method.
    */
    void Cut (const unsigned char iDim, const double iValue, const bool iSide);

    /**
    * Cuts this polygon, keeping also the part inside iBox.
    * These polygons are always convex by construction, so it's fine, there will only be one bit.
    */
    void Cut (const Box& iBox);

  private:

    static constexpr unsigned int _StaticPointCount = 7u;

  private:

    void Split (const unsigned char iDim, const double iValue, const bool iSide);

    unsigned int _NbPoints; //!< How many positions in the polygon ?
    unsigned int _PointCapacity; //!< The capacity of _pPoints. May be larger than _NbPoints.
    Position _StaticPoints[_StaticPointCount + 2u]; // Static array of points for performances.
    Position* _pPoints; //!< The positions of the polygon + 2 (the first two), who are reserved to represent its bounding box.
  };

protected:

  /** @name Leaf operators */
  //@{

  HRESULT GatherElements (const Node& iNode, const unsigned char iChildIdx, Poly::Set<Element>& oElements) const;

  HRESULT InsertInLeaf (Node& iNode, const unsigned char iChildIdx, const Element iElement);

  HRESULT RemoveFromLeaf (Node& iNode, const unsigned char iChildIdx, const Element iElement);

  HRESULT ReplaceInLeaf (Node& iNode, const unsigned char iChildIdx, const Element iOldElement, const Element iNewElement);

  //@}

protected:

  /** @name Traversal methods */
  //@{

  /**
  * @brief Generic traversal method where the user has full control over traversal decisions.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * @tparam Visitor : an object on which the method Call will be called on visited leaves of the KD-tree.
  * @tparam Call : the method called on the Visitor object provided. It should have signature :
  * HRESULT Call(const Node& iNode, const unsigned char iChildIdx, Args...)
  * @tparam Args : arguments of the method Call beside the father node to the leaf and the index of its leaf child.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT InternalTraverse (const Node* ipRoot, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

  /**
  * @brief Generic traversal method where the user has full control over traversal decisions.
  * This method is non const and can therefore modify the structure of the tree.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * @tparam Visitor : an object on which the method Call will be called on visited leaves of the KD-tree.
  * @tparam Call : the method called on the Visitor object provided. It should have signature :
  * HRESULT Call(Node& iNode, const unsigned char iChildIdx, Args...)
  * @tparam Args : arguments of the method Call beside the father node to the leaf and the index of its leaf child.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT InternalTraverse (Node* ipRoot, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  /**
  * @brief Generic traversal method where the user has full control over traversal decisions,
  * while additionnally providing the bounding box of the current node to assist in decision making.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const Box& iBox, const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * @tparam Visitor : an object on which the method Call will be called on visited leaves of the KD-tree.
  * @tparam Call : the method called on the Visitor object provided. It should have signature :
  * HRESULT Call(const Node& iNode, const unsigned char iChildIdx, const Box& iLeafBox, Args...)
  * @tparam Args : arguments of the method Call beside the father node to the leaf and the index of its leaf child.
  * @param iBox : the bounding box of the root of the tree.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT InternalTraverse (const Node* ipRoot, Box& iBox, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

  /**
  * @brief Generic traversal method where the user has full control over traversal decisions,
  * while additionnally providing the bounding box of the current node to assist in decision making.
  * This method is non const and can therefore modify the structure of the tree.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const Box& iBox, const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * @tparam Visitor : an object on which the method Call will be called on visited leaves of the KD-tree.
  * @tparam Call : the method called on the Visitor object provided. It should have signature :
  * HRESULT Call(Node& iNode, const unsigned char iChildIdx, const Box& iLeafBox, Args...)
  * @tparam Args : arguments of the method Call beside the father node to the leaf and the index of its leaf child.
  * @param iBox : the bounding box of the root of the tree.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT InternalTraverse (Node* ipRoot, Box& iBox, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  /**
  * TODO UPDATE
  * @brief Traversal method based on a convex polygon (most likely a triangle at the start) intersecting nodes.
  * @details This required a separate traversal method because we need to duplicate and modify polygons as we descend
  * in the tree, and maintaining this information could not be done in the previous methods.
  * @tparam Visitor : an object on which the method Call will be called on visited leaves of the KD-tree.
  * @tparam Call : the method called on the Visitor object provided. It should have signature :
  * HRESULT Call(const Node& iNode, const unsigned char iChildIdx, Args...)
  * @tparam Args : arguments of the method Call beside the father node to the leaf and the index of its leaf child.
  * @param iEpsilon : the tolerance used to determine that a polygon is intersecting the bounding box of a node.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT InternalTraverse (const Node* ipRoot, Traverser& iTraverser, const double iEpsilon, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

  /**
  * TODO UPDATE
  * @brief Traversal method based on a convex polygon (most likely a triangle at the start) intersecting nodes.
  * This method is non const and can therefore modify the structure of the tree.
  * @details This required a separate traversal method because we need to duplicate and modify polygons as we descend
  * in the tree, and maintaining this information could not be done in the previous methods.
  * @tparam Visitor : an object on which the method Call will be called on visited leaves of the KD-tree.
  * @tparam Call : the method called on the Visitor object provided. It should have signature :
  * HRESULT Call(Node& iNode, const unsigned char iChildIdx, Args...)
  * @tparam Args : arguments of the method Call beside the father node to the leaf and the index of its leaf child.
  * @param iEpsilon : the tolerance used to determine that a polygon is intersecting the bounding box of a node.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT InternalTraverse (Node* ipRoot, Traverser& iTraverser, const double iEpsilon, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  //@}

protected:

  /**
  * Default traverser object which can be provided to traversal methods.
  * It will always decide to visit both children of each node.
  */
  class DefaultTraverser
  {
  public:
    unsigned char GetSides (const unsigned char iDim, const double iValue) { return 2; }
    unsigned char GetSides (const Box& iBox, const unsigned char iDim, const double iValue) { return 2; }
  };

  /**
  * This method is used to call visitors publically exposed outside the class,
  * which do not have access to the father node of the leaf.
  * @tparam Visitor : the object on which the method iCall is called for each visited leaf of the tree.
  * @tparam Call : the method type of the method called on ipVisitor. It must have signature :
  * HRESULT Call(const Element* ipElements, const unsigned int iNbElements, Args... iArgs)
  * @tparam Args : remaining arguments of the method iCall beside the elements in the visited leaf and the number of them.
  */
  template<typename Visitor, typename Call, typename... Args>
  HRESULT VisitLeaf (const Node& iNode, const unsigned char iChildIdx, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

private:

  /** @name Generic Traversal methods
  * The following methods are used to factorize code between const and non const traversal methods.
  */
  //@{

  template<typename NodeType, typename Traverser, typename Visitor, typename Call, typename... Args>
  static HRESULT StaticTraverse (NodeType* ipRoot, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  template<typename NodeType, typename Traverser, typename Visitor, typename Call, typename... Args>
  static HRESULT StaticTraverse (NodeType* ipRoot, Box& iBox, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  template<typename NodeType, typename Traverser, typename Visitor, typename Call, typename... Args>
  static HRESULT StaticTraverse (NodeType* ipRoot, Traverser& iTraverser, const double iEpsilon, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  //@}

private:

  /** @name Traversal Helper methods */
  //@{

  template<typename NodeType, typename Traverser>
  static inline void Pop (std::stack<std::tuple<NodeType*, Traverser>>& iStack, NodeType*& opNode, Traverser& oTraverser);

  template<typename NodeType>
  static inline void Pop (std::stack<NodeType*>& iStack, NodeType*& opNode);

  template<typename NodeType>
  static inline void Pop (std::stack<std::tuple<NodeType*, Box>>& iStack, NodeType*& opNode, Box& oBox);

  template<typename NodeType>
  static inline void Push (std::stack<std::tuple<NodeType*, Box>>& iStack, NodeType& iNode, const unsigned char iChildIdx, Box& iBox);

  template<typename NodeType, typename Visitor, typename Call, typename... Args>
  static inline HRESULT Visit (Box& iBox, NodeType& iNode, const unsigned char iChildIdx, Visitor* ipVisitor, Call iCall, Args ... iArgs);

  //@}

protected:

  /** @name Multithreading methods */
  //@{

  /**
  * Creates the threads which will be used to execute tasks.
  */
  HRESULT BuildWorkers ();

  /**
  * Joins all worker threads.
  */
  void KillWorkers ();

  /**
  * The method called on each worker thread.
  * It continuously looks for tasks to execute.
  */
  void ProcessTasks ();

  /**
  * Method called on the main operator to wait for the task list to be empty.
  * Will return E_FAIL if one of the tasks failed when executed.
  */
  HRESULT WaitForCompletion ();

  //@}

protected:

  Node* _pRoot; //!< The root of the KD-Tree.

protected:

  std::queue<std::function<HRESULT ()>> _Tasks; //!< All tasks to be executed by workers.
  std::thread** _ppWorkers; //!< Array of workers.
  unsigned int _NbWorkers; //!< Number of workers.

  std::condition_variable _SchedulerNotifier; //!< Used to send notifications to the operator itself.
  std::condition_variable _WorkerNotifier; //!< Used to send notifications to the workers.
  std::mutex _Mutex; //!< Main mutex to synchronize operator and workers.
  size_t _NbTasksLeft; //!< Numbers of nodes of the KD-Tree still in process by workers.
  bool _StopSignal; //!< Signal sent to workers to stop them.
  bool _FailureSignal; //!< Signal sent by workers to the operator to notify that one task failed.

};


//////////////////////
//  IMPLEMENTATION  //
//////////////////////


template<typename Element>
CATPolyBaseKDTree<Element>::CATPolyBaseKDTree () :
  _pRoot (nullptr),
  _Tasks (),
  _ppWorkers (nullptr),
  _NbWorkers (1),
  _SchedulerNotifier (),
  _WorkerNotifier (),
  _Mutex (),
  _NbTasksLeft (0),
  _StopSignal (false),
  _FailureSignal (false)
{
}

template<typename Element>
CATPolyBaseKDTree<Element>::~CATPolyBaseKDTree ()
{
  KillWorkers ();

  if (_pRoot)
  {
    delete _pRoot;
    _pRoot = nullptr;
  }
}

template<typename Element>
typename CATPolyBaseKDTree<Element>::Leaf* CATPolyBaseKDTree<Element>::Leaf::CreateLeaf (const unsigned int iSize, const unsigned int iCapacity)
{
  Leaf* pLeaf = static_cast<Leaf*>(malloc (sizeof (Leaf) + iCapacity * sizeof (Element)));
  if (pLeaf)
  {
    pLeaf->_Size = iSize;
    pLeaf->_Capacity = iCapacity;
  }
  return pLeaf;
}

template<typename Element>
const Element* CATPolyBaseKDTree<Element>::Leaf::GetElements () const
{
  return reinterpret_cast<const Element*>(this + 1);
}

template<typename Element>
Element* CATPolyBaseKDTree<Element>::Leaf::GetElements ()
{
  return reinterpret_cast<Element*>(this + 1);
}

template<typename Element>
CATPolyBaseKDTree<Element>::Node::Node () :
  _CutDimension (0),
  _IsChildLeaf (),
  _IsChildToUpdate (),
  _CutValue (0.),
  _Child ()
{
  _IsChildLeaf[0] = _IsChildLeaf[1] = true;
  _IsChildToUpdate[0] = _IsChildToUpdate[1] = false;
}

template<typename Element>
CATPolyBaseKDTree<Element>::Node::~Node ()
{
  for (unsigned int childIdx = 0; childIdx < 2; ++childIdx)
  {
    if (_IsChildLeaf[childIdx])
    {
      free (_Child[childIdx]._pLeaf);
      _Child[childIdx]._pLeaf = nullptr;
    }
    else
    {
      delete _Child[childIdx]._pNode;
      _Child[childIdx]._pNode = nullptr;
    }
  }
}

template<typename Element>
HRESULT CATPolyBaseKDTree<Element>::InsertInLeaf (Node& iNode, const unsigned char iChildIdx, const Element iElement)
{
  iNode._IsChildToUpdate[iChildIdx] = true;
  Leaf*& pLeaf = iNode._Child[iChildIdx]._pLeaf;
  if (pLeaf)
  {
    if (pLeaf->_Capacity == pLeaf->_Size)
    {
      pLeaf->_Capacity = static_cast<unsigned int>(CATCeil (1.5 * pLeaf->_Capacity));
      if (pLeaf = static_cast<Leaf*>(realloc (pLeaf, sizeof (Leaf) + pLeaf->_Capacity * sizeof (Element))))
      {
        pLeaf->GetElements ()[pLeaf->_Size++] = iElement;
        return S_OK;
      }
    }
    else
    {
      pLeaf->GetElements ()[pLeaf->_Size++] = iElement;
      return S_OK;
    }
  }
  return E_FAIL;
}

template<typename Element>
HRESULT CATPolyBaseKDTree<Element>::ReplaceInLeaf (Node& iNode, const unsigned char iChildIdx, const Element iOldElement, const Element iNewElement)
{
  HRESULT ret = S_OK;
  Leaf*& pLeaf = iNode._Child[iChildIdx]._pLeaf;
  if (pLeaf)
  {
    Element* pElements = pLeaf->GetElements ();
    unsigned int triIdx = 0;
    while (triIdx < pLeaf->_Size && pElements[triIdx] != iOldElement)
      ++triIdx;

    if (triIdx == pLeaf->_Size)
      ret = E_FAIL;
    else
      pElements[triIdx] = iNewElement;
  }
  else
    ret = E_FAIL;
  return ret;
}

template<typename Element>
HRESULT CATPolyBaseKDTree<Element>::RemoveFromLeaf (Node& iNode, const unsigned char iChildIdx, const Element iElement)
{
  HRESULT ret = S_OK;
  Leaf*& pLeaf = iNode._Child[iChildIdx]._pLeaf;
  if (pLeaf)
  {
    Element* pElements = pLeaf->GetElements ();
    unsigned int triIdx = 0;
    while (triIdx < pLeaf->_Size && pElements[triIdx] != iElement)
      ++triIdx;

    if (triIdx == pLeaf->_Size)
      ret = E_FAIL;
    else
      std::swap (pElements[triIdx], pElements[--pLeaf->_Size]);
  }
  else
    ret = E_FAIL;
  return ret;
}

template<typename Element>
HRESULT CATPolyBaseKDTree<Element>::GatherElements (const Node& iNode, const unsigned char iChildIdx, Poly::Set<Element>& oElements) const
{
  HRESULT ret = S_OK;
  const Leaf* pLeaf = iNode._Child[iChildIdx]._pLeaf;
  if (!pLeaf)
    ret = E_FAIL;
  else
  {
    const Element* pElements = pLeaf->GetElements ();
    for (unsigned int triIdx = 0; triIdx < pLeaf->_Size && SUCCEEDED (ret); ++triIdx)
      ret = oElements.Insert (pElements[triIdx]);
  }
  return ret;
}

template<typename Element>
template<typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::VisitLeaf (const Node& iNode, const unsigned char iChildIdx, Visitor* ipVisitor, Call iCall, Args... iArgs) const
{
  return iNode._Child[iChildIdx]._pLeaf ? (ipVisitor->*iCall) (iNode._Child[iChildIdx]._pLeaf->GetElements (), iNode._Child[iChildIdx]._pLeaf->_Size, iArgs...) : E_FAIL;
}

template<typename Element>
CATPolyBaseKDTree<Element>::Bar::Bar () :
  _Points ()
{
  _Points[0][0] = _Points[0][1] = _Points[0][2] = std::numeric_limits<double>::signaling_NaN ();
  _Points[1][0] = _Points[1][1] = _Points[1][2] = std::numeric_limits<double>::signaling_NaN ();
}

template<typename Element>
CATPolyBaseKDTree<Element>::Bar::Bar (const Position& iFstPoint, const Position& iSndPoint) :
  _Points { iFstPoint, iSndPoint }
{
}

template<typename Element>
CATPolyBaseKDTree<Element>::Bar::Bar (const CATMathPoint iPositions[2]) :
  _Points { { iPositions[0].GetX (), iPositions[0].GetY (), iPositions[0].GetZ () }, { iPositions[1].GetX (), iPositions[1].GetY (), iPositions[1].GetZ () } }
{
}

template<typename Element>
unsigned char CATPolyBaseKDTree<Element>::Bar::GetSides (const unsigned char iDim, const double iValue, const double iEpsilon) const
{
  if (_Points[0][iDim] < _Points[1][iDim])
    return static_cast<unsigned char>(_Points[0][iDim] <= iValue + iEpsilon) + 2 * static_cast<unsigned char>(_Points[1][iDim] >= iValue - iEpsilon) - 1;
  else
    return static_cast<unsigned char>(_Points[1][iDim] <= iValue + iEpsilon) + 2 * static_cast<unsigned char>(_Points[0][iDim] >= iValue - iEpsilon) - 1;
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Bar::Cut (const unsigned char iDim, const double iValue, const bool iSide, Bar& oBar)
{
  if (iSide ? _Points[0][iDim] >= iValue : _Points[0][iDim] <= iValue)
  {
    if (iSide ? _Points[1][iDim] >= iValue : _Points[1][iDim] <= iValue)
    {
      oBar._Points[0] = _Points[0];
      oBar._Points[1] = _Points[1];
    }
    else
    {
      oBar._Points[0] = _Points[0];
      oBar._Points[1] = Polygon::IntersectPlane (iDim, iValue, _Points[0], _Points[1]);
    }
  }
  else if (iSide ? _Points[1][iDim] >= iValue : _Points[1][iDim] <= iValue)
  {
    oBar._Points[0] = Polygon::IntersectPlane (iDim, iValue, _Points[0], _Points[1]);
    oBar._Points[1] = _Points[1];
  }
  else
  {
    oBar._Points[0][0] = oBar._Points[0][1] = oBar._Points[0][2] = std::numeric_limits<double>::signaling_NaN ();
    oBar._Points[1][0] = oBar._Points[1][1] = oBar._Points[1][2] = std::numeric_limits<double>::signaling_NaN ();
  }
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Bar::Cut (const unsigned char iDim, const double iValue, const bool iSide)
{
  if (iSide ? _Points[0][iDim] < iValue : _Points[0][iDim] > iValue)
  {
    if (iSide ? _Points[1][iDim] < iValue : _Points[1][iDim] > iValue)
    {
      _Points[0][0] = _Points[0][1] = _Points[0][2] = std::numeric_limits<double>::signaling_NaN ();
      _Points[1][0] = _Points[1][1] = _Points[1][2] = std::numeric_limits<double>::signaling_NaN ();
    }
    else
      _Points[0] = Polygon::IntersectPlane (iDim, iValue, _Points[0], _Points[1]);
  }
  else if (iSide ? _Points[1][iDim] < iValue : _Points[1][iDim] > iValue)
    _Points[1] = Polygon::IntersectPlane (iDim, iValue, _Points[0], _Points[1]);
}

template<typename Element>
CATPolyBaseKDTree<Element>::Polygon::Polygon () :
  _NbPoints (0u),
  _PointCapacity (_StaticPointCount),
  _StaticPoints (),
  _pPoints (_StaticPoints)
{
}

template<typename Element>
CATPolyBaseKDTree<Element>::Polygon::Polygon (const CATMathPoint iPositions[3], const Box& iBox) :
  _NbPoints (3u),
  _PointCapacity (_StaticPointCount),
  _StaticPoints (),
  _pPoints (_StaticPoints)
{
  iPositions[0].GetCoord (_pPoints[2][0], _pPoints[2][1], _pPoints[2][2]);
  iPositions[1].GetCoord (_pPoints[3][0], _pPoints[3][1], _pPoints[3][2]);
  iPositions[2].GetCoord (_pPoints[4][0], _pPoints[4][1], _pPoints[4][2]);
  Cut (iBox);
}

template<typename Element>
CATPolyBaseKDTree<Element>::Polygon::Polygon (const CATMathPoint iPositions[3]) :
  _NbPoints (3u),
  _PointCapacity (_StaticPointCount),
  _StaticPoints (),
  _pPoints (_StaticPoints)
{
  iPositions[0].GetCoord (_pPoints[2][0], _pPoints[2][1], _pPoints[2][2]);
  iPositions[1].GetCoord (_pPoints[3][0], _pPoints[3][1], _pPoints[3][2]);
  iPositions[2].GetCoord (_pPoints[4][0], _pPoints[4][1], _pPoints[4][2]);
  UpdateBox ();
}

template<typename Element>
CATPolyBaseKDTree<Element>::Polygon::Polygon (const Polygon& iOther) :
  _NbPoints (iOther._NbPoints),
  _PointCapacity (_StaticPointCount),
  _StaticPoints (),
  _pPoints (_StaticPoints)
{
  if (_NbPoints > _StaticPointCount)
  {
    _PointCapacity = iOther._NbPoints;
    _pPoints = static_cast<Position*>(malloc ((_PointCapacity + 2) * sizeof (Position)));
  }

  for (unsigned int pntIdx = 0, nbPoints = _NbPoints + 2; pntIdx < nbPoints; ++pntIdx)
    _pPoints[pntIdx] = iOther._pPoints[pntIdx];
}

template<typename Element>
CATPolyBaseKDTree<Element>::Polygon::Polygon (Polygon&& iOther) :
  _NbPoints (iOther._NbPoints),
  _PointCapacity (iOther._PointCapacity),
  _StaticPoints (),
  _pPoints (_StaticPoints)
{
  if (_NbPoints > _StaticPointCount)
  {
    _pPoints = iOther._pPoints;
    iOther._PointCapacity = _StaticPointCount;
    iOther._pPoints = iOther._StaticPoints;
  }
  else
    for (unsigned int pntIdx = 0, nbPoints = _NbPoints + 2; pntIdx < nbPoints; ++pntIdx)
      _pPoints[pntIdx] = iOther._pPoints[pntIdx];

  iOther._NbPoints = 0;
}

template<typename Element>
CATPolyBaseKDTree<Element>::Polygon::~Polygon ()
{
  if (_pPoints && _pPoints != _StaticPoints)
    free (_pPoints);
  _pPoints = nullptr;
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Reset ()
{
  _NbPoints = 0u;
}

template<typename Element>
typename CATPolyBaseKDTree<Element>::Polygon& CATPolyBaseKDTree<Element>::Polygon::operator=(Polygon&& iOther)
{
  if (_pPoints && _pPoints != _StaticPoints)
    free (_pPoints);
  _pPoints = _StaticPoints;

  _NbPoints = iOther._NbPoints;
  _PointCapacity = iOther._PointCapacity;

  if (_NbPoints > _StaticPointCount)
  {
    _pPoints = iOther._pPoints;
    iOther._PointCapacity = _StaticPointCount;
    iOther._pPoints = iOther._StaticPoints;
  }
  else
    for (unsigned int pntIdx = 0, nbPoints = _NbPoints + 2; pntIdx < nbPoints; ++pntIdx)
      _pPoints[pntIdx] = iOther._pPoints[pntIdx];

  iOther._NbPoints = 0u;

  return *this;
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Push (Position iPosition)
{
  if (_NbPoints == _PointCapacity)
  {
    if (_PointCapacity > _StaticPointCount)
    {
      _PointCapacity += 2;
      _pPoints = static_cast<Position*>(realloc (_pPoints, (_PointCapacity + 2) * sizeof (Position)));
    }
    else
    {
      _PointCapacity = _StaticPointCount + 2;
      _pPoints = static_cast<Position*>(malloc ((_PointCapacity + 2) * sizeof (Position)));
      std::memcpy (_pPoints, _StaticPoints, _PointCapacity * sizeof (Position));
    }
  }
  if (_pPoints)
    _pPoints[2 + _NbPoints++] = iPosition;
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Push (const CATMathPoint& iPosition)
{
  Position position;
  position[0] = iPosition.GetX ();
  position[1] = iPosition.GetY ();
  position[2] = iPosition.GetZ ();
  Push (position);
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::UpdateBox ()
{
  if (_NbPoints)
  {
    Position* pPoints = _pPoints + 2;
    _pPoints[0] = pPoints[0];
    _pPoints[1] = pPoints[0];
    for (unsigned int pntIdx = 1; pntIdx < _NbPoints; ++pntIdx)
    {
      for (unsigned char dim = 0; dim < 3; ++dim)
      {
        if (pPoints[pntIdx][dim] < _pPoints[0][dim])
          _pPoints[0][dim] = pPoints[pntIdx][dim];
        else if (pPoints[pntIdx][dim] > _pPoints[1][dim])
          _pPoints[1][dim] = pPoints[pntIdx][dim];
      }
    }
  }
}

template<typename Element>
unsigned char CATPolyBaseKDTree<Element>::Polygon::GetSides (const unsigned char iDim, const double iValue, const double iEpsilon)
{
  return static_cast<unsigned char>(_pPoints[0][iDim] <= iValue + iEpsilon) + 2 * static_cast<unsigned char>(_pPoints[1][iDim] >= iValue - iEpsilon) - 1;
}

template<typename Element>
typename CATPolyBaseKDTree<Element>::Position CATPolyBaseKDTree<Element>::Polygon::IntersectPlane (const unsigned char iDim, const double iValue, const Position& iBgn, const Position& iEnd)
{
  Position intersection;
  intersection[iDim] = iValue;
  double alpha = (iValue - iBgn[iDim]) / (iEnd[iDim] - iBgn[iDim]);
  unsigned char dim0 = (iDim + 1) % 3;
  unsigned char dim1 = (iDim + 2) % 3;
  intersection[dim0] = iBgn[dim0] + alpha * (iEnd[dim0] - iBgn[dim0]);
  intersection[dim1] = iBgn[dim1] + alpha * (iEnd[dim1] - iBgn[dim1]);
  return intersection;
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Cut (const unsigned char iDim, const double iValue, const bool iSide, Polygon& oPolygon)
{
  oPolygon.Reset ();
  if (_pPoints && _NbPoints)
  {
    Position* pPoints = _pPoints + 2;
    unsigned int lstPntIdx = _NbPoints - 1;
    bool lstSide = iSide ? pPoints[lstPntIdx][iDim] >= iValue : pPoints[lstPntIdx][iDim] <= iValue;

    for (unsigned int crtPntIdx = 0; crtPntIdx < _NbPoints; lstPntIdx = crtPntIdx++)
    {
      if (iSide ? pPoints[crtPntIdx][iDim] >= iValue : pPoints[crtPntIdx][iDim] <= iValue)
      {
        if (!lstSide) // change side
        {
          if (pPoints[crtPntIdx][iDim] != iValue)
            oPolygon.Push (IntersectPlane (iDim, iValue, pPoints[lstPntIdx], pPoints[crtPntIdx]));
          oPolygon.Push (pPoints[crtPntIdx]);
        }
        else // no side change
          oPolygon.Push (pPoints[crtPntIdx]);
        lstSide = true;
      }
      else
      {
        if (lstSide) // change side
        {
          if (pPoints[lstPntIdx][iDim] != iValue)
            oPolygon.Push (IntersectPlane (iDim, iValue, pPoints[lstPntIdx], pPoints[crtPntIdx]));
        }
        // else => no insersion since on the other side
        lstSide = false;
      }
    }
    oPolygon.UpdateBox ();
  }
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Cut (const unsigned char iDim, const double iValue, const bool iSide)
{
  Split (iDim, iValue, iSide);
  UpdateBox ();
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Split (const unsigned char iDim, const double iValue, const bool iSide)
{
  if (_NbPoints)
  {
    Position* pPoints = _pPoints + 2;
    Position bgnPnt;
    Position endPnt;
    unsigned int bgnPntIdx = _NbPoints; // First point of the polygon on the wrong side of the current plane.
    unsigned int endPntIdx = _NbPoints; // Last point of the polygon on the wrong side of the current plane.

    unsigned int lstPntIdx = _NbPoints - 1;
    bool lstSide = iSide ? pPoints[lstPntIdx][iDim] >= iValue : pPoints[lstPntIdx][iDim] <= iValue;

    unsigned int crtPntIdx = 0;
    bool crtSide;

    for (; crtPntIdx < _NbPoints; lstSide = crtSide, lstPntIdx = crtPntIdx++)
    {
      crtSide = iSide ? pPoints[crtPntIdx][iDim] >= iValue : pPoints[crtPntIdx][iDim] <= iValue;
      if (!lstSide && crtSide)
      {
        endPntIdx = lstPntIdx;
        endPnt = IntersectPlane (iDim, iValue, pPoints[lstPntIdx], pPoints[crtPntIdx]);
      }
      else if (!crtSide && lstSide)
      {
        bgnPntIdx = crtPntIdx;
        bgnPnt = IntersectPlane (iDim, iValue, pPoints[lstPntIdx], pPoints[crtPntIdx]);
      }
    }

    if (bgnPntIdx < _NbPoints) // We only enter here if the plane cuts the polygon.
    {
      if (bgnPntIdx < endPntIdx)
      {
        pPoints[bgnPntIdx] = bgnPnt;
        pPoints[bgnPntIdx + 1] = endPnt;
        if (endPntIdx - bgnPntIdx > 1)
        {
          for (lstPntIdx = endPntIdx + 1, crtPntIdx = bgnPntIdx + 2; lstPntIdx < _NbPoints; ++lstPntIdx, ++crtPntIdx)
            pPoints[crtPntIdx] = pPoints[lstPntIdx];
          _NbPoints -= endPntIdx - bgnPntIdx - 1;
        }
      }
      else if (bgnPntIdx > endPntIdx)
      {
        for (lstPntIdx = endPntIdx + 1, crtPntIdx = 1; lstPntIdx < bgnPntIdx; ++lstPntIdx, ++crtPntIdx)
          pPoints[crtPntIdx] = pPoints[lstPntIdx];
        _NbPoints = bgnPntIdx - endPntIdx + 1;
        pPoints[0] = endPnt;
        pPoints[_NbPoints - 1] = bgnPnt;
      }
      else
      {
        Push (pPoints[_NbPoints - 1]);
        pPoints = _pPoints + 2;
        for (lstPntIdx = _NbPoints - 3; lstPntIdx > endPntIdx; --lstPntIdx)
          pPoints[lstPntIdx + 1] = pPoints[lstPntIdx];
        pPoints[bgnPntIdx] = bgnPnt;
        pPoints[bgnPntIdx + 1] = endPnt;
      }
    }
    else if (!crtSide)
      _NbPoints = 0u;
  }
}

template<typename Element>
void CATPolyBaseKDTree<Element>::Polygon::Cut (const Box& iBox)
{
  for (unsigned char dim = 0; dim < 3; ++dim) // For each axis.
  {
    Split (dim, iBox[0][dim], true);
    Split (dim, iBox[1][dim], false);
  }
  UpdateBox ();
}

template<typename Element>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::InternalTraverse (const Node* ipRoot, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const
{
  return StaticTraverse<const Node> (ipRoot, iTraverser, ipVisitor, iCall, iArgs...);
}

template<typename Element>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::InternalTraverse (Node* ipRoot, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  return StaticTraverse<Node> (ipRoot, iTraverser, ipVisitor, iCall, iArgs...);
}

template<typename Element>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::InternalTraverse (const Node* ipRoot, Box& iBox, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const
{
  return StaticTraverse<const Node> (ipRoot, iBox, iTraverser, ipVisitor, iCall, iArgs...);
}

template<typename Element>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::InternalTraverse (Node* ipRoot, Box& iBox, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  return StaticTraverse<Node> (ipRoot, iBox, iTraverser, ipVisitor, iCall, iArgs...);
}

template<typename Element>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::InternalTraverse (const Node* ipRoot, Traverser& iTraverser, const double iEpsilon, Visitor* ipVisitor, Call iCall, Args ... iArgs) const
{
  return StaticTraverse<const Node> (ipRoot, iTraverser, iEpsilon, ipVisitor, iCall, iArgs...);
}

template<typename Element>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::InternalTraverse (Node* ipRoot, Traverser& iTraverser, const double iEpsilon, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  return StaticTraverse<Node> (ipRoot, iTraverser, iEpsilon, ipVisitor, iCall, iArgs...);
}

template<typename Element>
template<typename NodeType>
inline void CATPolyBaseKDTree<Element>::Pop (std::stack<NodeType*>& iStack, NodeType*& opNode)
{
  if (!iStack.empty ())
  {
    opNode = iStack.top ();
    iStack.pop ();
  }
  else
    opNode = nullptr;
}

template<typename Element>
template<typename NodeType>
inline void CATPolyBaseKDTree<Element>::Pop (std::stack<std::tuple<NodeType*, Box>>& iStack, NodeType*& opNode, Box& oBox)
{
  if (!iStack.empty ())
  {
    opNode = std::get<0> (iStack.top ());
    oBox = std::get<1> (iStack.top ());
    iStack.pop ();
  }
  else
    opNode = nullptr;
}

template<typename Element>
template<typename NodeType, typename Traverser>
inline void CATPolyBaseKDTree<Element>::Pop (std::stack<std::tuple<NodeType*, Traverser>>& iStack, NodeType*& opNode, Traverser& oTraverser)
{
  if (!iStack.empty ())
  {
    opNode = std::get<0> (iStack.top ());
    oTraverser = std::move (std::get<1> (iStack.top ()));
    iStack.pop ();
  }
  else
    opNode = nullptr;
}

template<typename Element>
template<typename NodeType>
inline void CATPolyBaseKDTree<Element>::Push (std::stack<std::tuple<NodeType*, Box>>& iStack, NodeType& iNode, const unsigned char iChildIdx, Box& iBox)
{
  double temp = iBox[1 - iChildIdx][iNode._CutDimension];
  iBox[1 - iChildIdx][iNode._CutDimension] = iNode._CutValue;
  iStack.emplace (iNode._Child[iChildIdx]._pNode, iBox);
  iBox[1 - iChildIdx][iNode._CutDimension] = temp;
}

template<typename Element>
template<typename NodeType, typename Visitor, typename Call, typename... Args>
inline HRESULT CATPolyBaseKDTree<Element>::Visit (Box& iBox, NodeType& iNode, const unsigned char iChildIdx, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  double temp = iBox[1 - iChildIdx][iNode._CutDimension];
  iBox[1 - iChildIdx][iNode._CutDimension] = iNode._CutValue;
  HRESULT ret = (ipVisitor->*iCall) (iNode, iChildIdx, iBox, iArgs...);
  iBox[1 - iChildIdx][iNode._CutDimension] = temp;
  return ret;
}

template<typename Element>
template<typename NodeType, typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::StaticTraverse (NodeType* ipRoot, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  HRESULT ret = S_FALSE;

  thread_local std::stack<NodeType*> nodes;

  NodeType* pNode = ipRoot;
  unsigned char side;

  while (pNode && SUCCEEDED (ret))
  {
    if ((side = iTraverser.GetSides (pNode->_CutDimension, pNode->_CutValue)) == 2) // We need to go down both ways
    {
      if (pNode->_IsChildLeaf[0])
      {
        ret = (ipVisitor->*iCall) (*pNode, 0, iArgs...);
        if (pNode->_IsChildLeaf[1])
        {
          ret = SUCCEEDED (ret) ? (ipVisitor->*iCall) (*pNode, 1, iArgs...) : ret;
          Pop (nodes, pNode);
        }
        else
          pNode = pNode->_Child[1]._pNode;
      }
      else
      {
        if (pNode->_IsChildLeaf[1])
          ret = (ipVisitor->*iCall) (*pNode, 1, iArgs...);
        else
          nodes.push (pNode->_Child[1]._pNode);
        pNode = pNode->_Child[0]._pNode;
      }
    }
    else if (pNode->_IsChildLeaf[side])
    {
      ret = (ipVisitor->*iCall) (*pNode, side, iArgs...);
      Pop (nodes, pNode);
    }
    else
      pNode = pNode->_Child[side]._pNode;
  }

  while (!nodes.empty ())
    nodes.pop ();
  return ret;
}

template<typename Element>
template<typename NodeType, typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::StaticTraverse (NodeType* ipRoot, Box& iBox, Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  HRESULT ret = S_FALSE;

  thread_local std::stack<std::tuple<NodeType*, Box>> nodes;

  NodeType* pNode = ipRoot;
  unsigned char side;

  while (pNode && SUCCEEDED (ret))
  {
    if ((side = iTraverser.GetSides (iBox, pNode->_CutDimension, pNode->_CutValue)) == 2) // We need to go down both ways
    {
      if (pNode->_IsChildLeaf[0])
      {
        ret = Visit (iBox, *pNode, 0, ipVisitor, iCall, iArgs...);
        if (pNode->_IsChildLeaf[1])
        {
          ret = SUCCEEDED (ret) ? Visit (iBox, *pNode, 1, ipVisitor, iCall, iArgs...) : ret;
          Pop (nodes, pNode, iBox);
        }
        else
        {
          iBox[0][pNode->_CutDimension] = pNode->_CutValue;
          pNode = pNode->_Child[1]._pNode;
        }
      }
      else
      {
        if (pNode->_IsChildLeaf[1])
          ret = Visit (iBox, *pNode, 1, ipVisitor, iCall, iArgs...);
        else
          Push (nodes, *pNode, 1, iBox);
        iBox[1][pNode->_CutDimension] = pNode->_CutValue;
        pNode = pNode->_Child[0]._pNode;
      }
    }
    else if (pNode->_IsChildLeaf[side])
    {
      ret = Visit (iBox, *pNode, side, ipVisitor, iCall, iArgs...);
      Pop (nodes, pNode, iBox);
    }
    else
    {
      iBox[1 - side][pNode->_CutDimension] = pNode->_CutValue;
      pNode = pNode->_Child[side]._pNode;
    }
  }

  while (!nodes.empty ())
    nodes.pop ();
  return ret;
}

template<typename Element>
template<typename NodeType, typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyBaseKDTree<Element>::StaticTraverse (NodeType* ipRoot, Traverser& iTraverser, const double iEpsilon, Visitor* ipVisitor, Call iCall, Args ... iArgs)
{
  HRESULT ret = S_FALSE;

  thread_local std::stack<std::tuple<NodeType*, Traverser>> nodes;

  NodeType* pNode = ipRoot;
  Traverser tempTraverser;
  unsigned char side;

  while (pNode && SUCCEEDED (ret))
  {
    if ((side = iTraverser.GetSides (pNode->_CutDimension, pNode->_CutValue, iEpsilon)) == 2) // We need to go down both ways
    {
      if (pNode->_IsChildLeaf[0])
      {
        ret = (ipVisitor->*iCall) (*pNode, 0, iArgs...);
        if (pNode->_IsChildLeaf[1])
        {
          ret = SUCCEEDED (ret) ? (ipVisitor->*iCall) (*pNode, 1, iArgs...) : E_FAIL;
          Pop (nodes, pNode, iTraverser);
        }
        else
        {
          iTraverser.Cut (pNode->_CutDimension, pNode->_CutValue - iEpsilon, true);
          pNode = pNode->_Child[1]._pNode;
        }
      }
      else
      {
        if (pNode->_IsChildLeaf[1])
          ret = (ipVisitor->*iCall) (*pNode, 1, iArgs...);
        else
        {
          iTraverser.Cut (pNode->_CutDimension, pNode->_CutValue - iEpsilon, true, tempTraverser);
          nodes.emplace (pNode->_Child[1]._pNode, tempTraverser);
        }
        iTraverser.Cut (pNode->_CutDimension, pNode->_CutValue + iEpsilon, false);
        pNode = pNode->_Child[0]._pNode;
      }
    }
    else if (pNode->_IsChildLeaf[side])
    {
      ret = (ipVisitor->*iCall) (*pNode, side, iArgs...);
      Pop (nodes, pNode, iTraverser);
    }
    else
      pNode = pNode->_Child[side]._pNode;
  }

  while (!nodes.empty ())
    nodes.pop ();
  return ret;
}

template<typename Element>
HRESULT CATPolyBaseKDTree<Element>::BuildWorkers ()
{
  HRESULT ret = S_FALSE;
  if (_NbWorkers > 1)
    if (SUCCEEDED (ret = (_ppWorkers = new std::thread * [_NbWorkers] ()) ? S_OK : E_FAIL))
      for (unsigned int workerIdx = 0; workerIdx < _NbWorkers && SUCCEEDED (ret); ++workerIdx)
        ret = (_ppWorkers[workerIdx] = new std::thread (&CATPolyBaseKDTree::ProcessTasks, this)) ? S_OK : E_FAIL;
  return ret;
}

template<typename Element>
void CATPolyBaseKDTree<Element>::KillWorkers ()
{
  if (_NbWorkers > 1)
  {
    _Mutex.lock ();
    _StopSignal = true;
    _Mutex.unlock ();
    _WorkerNotifier.notify_all ();
    if (_ppWorkers)
    {
      for (unsigned int workerIdx = 0; workerIdx < _NbWorkers; ++workerIdx)
      {
        std::thread*& pWorker = _ppWorkers[workerIdx];
        if (pWorker)
        {
          pWorker->join ();
          delete pWorker;
          pWorker = nullptr;
        }
      }
      delete [] _ppWorkers;
      _ppWorkers = nullptr;
    }
  }
}

template<typename Element>
void CATPolyBaseKDTree<Element>::ProcessTasks ()
{
  std::unique_lock<std::mutex> lock (_Mutex);

  while (!_StopSignal)
  {
    _WorkerNotifier.wait (lock, [this]() { return !_Tasks.empty () || _StopSignal; });
    if (!_Tasks.empty ())
    {
      std::function<HRESULT ()> task = std::move (_Tasks.front ());
      _Tasks.pop ();

      lock.unlock ();
      HRESULT ret = task ();
      lock.lock ();

      if (FAILED (ret))
        _FailureSignal = true;

      if (!--_NbTasksLeft)
      {
        lock.unlock ();
        _SchedulerNotifier.notify_all ();
        lock.lock ();
      }
    }
  }
}

template<typename Element>
HRESULT CATPolyBaseKDTree<Element>::WaitForCompletion ()
{
  std::unique_lock<std::mutex> lock (_Mutex);
  if(_NbTasksLeft)
    _SchedulerNotifier.wait(lock, [this]() { return !_NbTasksLeft; });
  HRESULT ret = _FailureSignal ? E_FAIL : S_OK;
  _FailureSignal = false;
  return ret;
}

#endif
