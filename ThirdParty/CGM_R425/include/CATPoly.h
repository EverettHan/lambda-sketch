// COPYRIGHT DASSAULT SYSTEMES 2004, ALL RIGHTS RESERVED.
//===================================================================
//
// CATPoly.h
//
//===================================================================
// July 2004  Creation: Code generated by the CAA wizard  ndo
//===================================================================
#ifndef CATPoly_H
#define CATPoly_H

#include "PolyMathContainers.h"

#include "CATCompareElements.h"
#include "Poly/Set.h"

#ifndef _AIX_SOURCE
#include <cstdint>
#endif

#if !defined (PLATEFORME_DS64)
#define POLY_32BIT 1
#endif

namespace Poly
{

/** @name Polyhedral Elements
    @{ */

/**
   * A cell element encoded as a pair of 32-bit integers:
   *   * An unsigned integer giving the index or id of a cell.
   *   * An integer giving the index of the element on the cell.
   *
   * A cell element has the size of a 64-bit pointer.
   */
  class CellElement
  {
  public:

    inline CellElement ()
    {
      _Handle._H._CellID = 0;
      _Handle._H._Index = 0;
    }

    inline CellElement (const CellElement & iToCopy)
    {
#ifndef POLY_32BIT
      _Handle._P = iToCopy._Handle._P;
#else
      _Handle._H._CellID = iToCopy._Handle._H._CellID;
      _Handle._H._Index = iToCopy._Handle._H._Index;
#endif
    }

    inline CellElement (unsigned int iCellID, int iElementID)
    {
      _Handle._H._CellID = iCellID;
      _Handle._H._Index = iElementID;
    }

#ifndef POLY_32BIT
    inline explicit CellElement (const void* h)
    {
      _Handle._P = (void*)h;
    }
#endif

    inline unsigned int CellID () const { return _Handle._H._CellID; }

    inline int Index () const { return _Handle._H._Index; }

#ifndef POLY_32BIT
    inline operator void* () const { return _Handle._P; }
#endif

    inline bool operator < (const CellElement & CE) const
    {
      return (CellID() < CE.CellID()) || (CellID() == CE.CellID() && Index() < CE.Index());
    }

    inline bool operator == (const CellElement & CE) const
    {
      return CellID () == CE.CellID () && Index () == CE.Index ();
    }

    inline bool operator != (const CellElement & CE) const
    {
      return CellID () != CE.CellID () || Index () != CE.Index ();
    }

    inline CellElement & operator=(const CellElement & iToAssign)
    {
#ifndef POLY_32BIT
      _Handle._P = iToAssign._Handle._P;
#else
      _Handle._H._CellID = iToAssign._Handle._H._CellID;
      _Handle._H._Index = iToAssign._Handle._H._Index;
#endif
      return *this;
    }

#ifndef POLY_32BIT
    inline bool IsDefined () const {return _Handle._P != 0; }
#else
    inline bool IsDefined () const {return CellID () || Index (); }
#endif

  private:

    struct Handle
    {
#ifndef _AIX_SOURCE
      uint32_t _CellID;  // ID of the cell.
      int32_t _Index;    // Index of the element on the cell.
#else
      unsigned int _CellID;  // ID of the cell.
      int _Index;            // Index of the element on the cell.
#endif
    };

    union
    {
      Handle _H;
      void* _P;
    } _Handle;
  };


  /**
   * A triangle encoded as a pair of 32-bit integers:
   *   * An unsigned integer giving the index or id of a face.
   *   * An integer giving the index of a triangle.
   *
   * A triangle has the size of a 64-bit pointer.
   */
  class Triangle : public CellElement
  {
  public:

    inline Triangle () : CellElement () {};

    inline Triangle (unsigned int faceID, int t) : CellElement (faceID, t) {};

#ifndef POLY_32BIT
    inline explicit Triangle (const void* h) : CellElement (h) {};
#endif

    inline unsigned int FaceID () const { return CellID (); }
  };


  /**
   * A Bar encoded as a pair of 32-bit integers:
   *   * An unsigned integer giving the index or id of a cell.
   *   * An integer giving the index of a bar.
   *
   * A bar has the size of a 64-bit pointer.
   */
  class Bar : public CellElement
  {
  public:
    inline Bar () : Poly::CellElement () {};
    inline Bar (unsigned int iIdCell, int iIdBar) : CellElement (iIdCell, iIdBar) {};

#ifndef POLY_32BIT
    inline explicit Bar (const void* h) : CellElement (h) {};
#endif
  };


  /**
   * A Tip encoded as a pair of 32-bit integers:
   *   * An unsigned integer giving the index or id of a cell.
   *   * An integer giving the index of a tip.
   *
   * A tip has the size of a 64-bit pointer.
   */
  class Tip : public CellElement
  {
  public:
    inline Tip () : Poly::CellElement () {};
    inline Tip (unsigned int iIdCell, int iIdTip) : CellElement (iIdCell, iIdTip) {};

#ifndef POLY_32BIT
    inline explicit Tip(const void* h) : CellElement(h) {};
#endif
  };


  /**
   * Enumerator defining the type of a polyhedral element: vertex, bar or triangle.
   */
  enum ElementType
  {
    /** Undefined type. */   eUndefined = 0,
    /** Vertex type. */      eVertex    = 1,
    /** Bar type. */         eBar       = 2,
    /** Triangle type. */    eTriangle  = 3
  };  

/** @} */

};

/**
* Full Template specialization of CATComparator for CellElement.
* Its is generally reused for specialization of subclasses of CellElement.
*/
template<>
class CATComparator<Poly::CellElement>
{
public:

  int Compare (const Poly::CellElement & iE0, const Poly::CellElement & iE1) const
  {
    return (iE1 < iE0) ? +1 : (iE0 < iE1) ? -1 : 0;
  };

  bool Equal (const Poly::CellElement & iE0, const Poly::CellElement & iE1) const
  {
    return iE1 == iE0;
  };

  // Hash function based on index AND cellID
  // Only index can lead to bad performances if a lot of cell with few index
  // Same goes for cellID only
  // Binary view: Index - CellID
  unsigned int Hash (const Poly::CellElement & iE) const
  {
    unsigned int h =   (iE.CellID()<<25) + iE.Index(); // Need to be on 32 bits...
    return h;
  };

  bool operator () (const Poly::CellElement & iE0, const Poly::CellElement & iE1) const
  {
    return iE0 < iE1;
  }
};

#ifndef _AIX_SOURCE
// for std
namespace std {
  template <> 
  struct hash<Poly::CellElement>
  {
    size_t operator()(const Poly::CellElement & iE) const
    {
      unsigned int h = (iE.CellID() << 25) + iE.Index(); // Need to be on 32 bits...
      return h;
    }
  };
}
#endif

/** @name CATComparator specialization of subclasses of CellElement.
    @{ */

template<>
class CATComparator<Poly::Triangle> : public CATComparator<Poly::CellElement> {};

template<>
class CATComparator<Poly::Bar> : public CATComparator<Poly::CellElement> {};

template<>
class CATComparator<Poly::Tip> : public CATComparator<Poly::CellElement> {};

/** @} */

/** @name Extern template declarations, to speed up compilation. Explicit instantiations are in Poly_Set.cpp.
    @{ */

extern template class ExportedTemplateByPolyMathContainers Poly::Set<Poly::Triangle>;

extern template class ExportedTemplateByPolyMathContainers Poly::Set<Poly::Bar>;

extern template class ExportedTemplateByPolyMathContainers Poly::Set<Poly::Tip>;

/** @} */

/**
*/
class CATPoly
{
  
public:

  /**
   * See Poly::ElementType.
   */
  enum EntityType
  {
    /** Undefined type. */   eUndefined = Poly::eUndefined,
    /** Vertex type. */      eVertex    = Poly::eVertex,
    /** Bar type. */         eBar       = Poly::eBar,
    /** Triangle type. */    eTriangle  = Poly::eTriangle
  };  

};

#endif
