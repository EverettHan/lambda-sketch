// COPYRIGHT Dassault Systemes 2005
//  May 2005  Creation: Code generated by the CAA wizard  bhg
//===================================================================

/**
 * @level Protected
 * @usage U1
 */
#ifndef CATOmyCuteIOTransactionsManager_H
#define CATOmyCuteIOTransactionsManager_H

#include "CATOMYCuteIO.h"
#include "CATIOmyCuteIOMonitor.h"
#include "CATWTypes.h"
#include "CATBinary.h"
#include "CATIOmyAsyncResult.h"
#include "CATIAsyncTaskCompletionCallBackBase.h"
#include "CATOmxSR.h"
#include "CATOmxList.h"

#include "CATVVSUrl.h"
#include "CATUuid.h"

class CATOmyVVSAsyncCallBackNotifier;
class CATOmyCioUrlUsageCtx;
class CATIOmyCioNotifier;
class CATOmyCuteIOTransaction;
class CATVVSTransaction;

/**
* States of a transaction.
* @param TRANS_CREATED
*     The transaction is just created.
* @param TRANS_PREPARED
*     The transaction is just prepared.
* @param TRANS_EXECUTED
*     The transaction is just executed.
* @param TRANS_COMMITED
*     The transaction is just commited.
* @param TRANS_ABORTED
*     The transaction is just aborted.
*/
enum eTransactionState {TRANS_CREATED = 0, TRANS_PREPARED = 1, TRANS_EXECUTED = 2, TRANS_COMMITED = 3, TRANS_ABORTED = 4, TRANS_CLOSED = 5};

CATOmxCollecManager& canceledContextCollecManager();

/**
* This object manage all CuteIo transactions.
* <br><b>Role</b>: This object is a factory of all CATOmyCuteIOTransaction.
*/
class ExportedByCATOMYCuteIO CATOmyCuteIOTransactionsManager
{
  friend class CATOmyCuteIOTransaction;
  friend class CATOmbStreamDescriptorObjectImpl;
  friend class CATPLMExternalsStreamDescriptor;
  friend class CATPCCExternalsStreamDescriptor;
  friend class OdtClass;
  friend class CATAsyncMTVVSTasksFactory;
  friend class CATStreamDownloader;

  public:
    enum eContextType {LoadingContext, AsyncLoadingContext, SavingContext, UnloadingContext, LocalSavingContext, AsyncSavingContext};

  /** 
  * Get the transaction manager.
  * <br><b>Role</b>: There is only one instance of this manager in session.
  * @param oManager [out]
  *   The transaction manager. No need to delete this object.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL;
  */
  static HRESULT GetCuteIoTransactionManager(CATOmyCuteIOTransactionsManager*& oManager);
  
  /** 
  * Creates a context of stream management.
  * @param iType [in]
  *   The type of the context
  * @param iUuid [out]
  *   The Identifier of the context.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL;
  */
  HRESULT NewStreamMgtContext(enum eContextType iType, CATUuid& oContextUuid, CATVVSTransaction * const iVaultSessionAttributes = NULL);

  /** 
  * Registers an element to be treated by cuteIO in a given context.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @param iContext [in]
  *   The context of the element to treat. (URL, needs, etc...)
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */
  HRESULT DeclareStream(const CATUuid& iTransUuid, const CATOmyCioUrlUsageCtx* iContext);

  /** 
  * Prepare all registered stream in cuteIO caches.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */
  HRESULT PrepareInCache(const CATUuid& iContextUuid);

  /** 
  * Copies or writes data from/in the vault.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @param iCallBackAfterAsynchronousTransfert [in]
  *   Function to be called back after asynchronous transfert (if NULL, no asynchronous transfert)
  *   void* iCallBackAfterAsynchronousTransfert(void*);
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */  
  HRESULT CommunicateWithVault(const CATUuid& iContextUuid);
  HRESULT CommunicateWithVault(const CATUuid& iContextUuid, CATOmyVVSAsyncCallBackNotifier* iSaveAsyncCallback, CATIOmyAsyncResult ** oAsyncResult);
  HRESULT CommunicateWithVault(const CATUuid& iTransUuid, CATIAsyncTaskCompletionCallBackBase* ipAsyncCallback, CATAsyncTaskID& oTaskID);

  /** 
  * Ensures the peristence of the registered streams.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */  
  HRESULT FlushToPersistentCache(const CATUuid& iContextUuid);
  
 /** 
  * Abort the context of stream management.
  * <br><b>Role</b>: This action roll back all actions made by cuteIO for this context.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */ 
  HRESULT AbortStreamMgtContext(const CATUuid& iContextUuid);


  /** 
  * Cancels the transaction (For Async Saving Transaction)
  * <br><b>Role</b>: This action Sends an order to the Async VVS Process to stop the upload or kill it itself
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */ 
  HRESULT CancelAsynchronousTransaction(const CATUuid& iTransUuid);

  /** 
  * Ends the context.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */ 
  HRESULT EndStreamMgtContext(const CATUuid& iContextUuid);
 
  /** 
  * Attaches a notifier to a transaction..
  * <br><b>Role</b>: This notifier could be usefull to follow action made by CuteIO during the transaction.<BR>
  * If it is set, CuteIO wil raise method of the given interface to inform the implementation of its action.
  * @param iUuid [in]
  *   The Identifier of the transaction.
  * @param iNotifier [in]
  *   The notifier of the transaction
  *
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL;
  *
  */
  HRESULT AttachTransactionNotifier(const CATUuid& iContextUuid, const CATIOmyCioNotifier* iNotifier);

  /** 
  * Get the Notifier associated with a transaction.
  * @param iTransUuid [in]
  *   The identifier of the transaction
  * @param opNotifier [out]
  *   The returned notifier. Must be released.
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL;
  */
  void GetAttachedNotifier(const CATUuid& iTransUuid, CATIOmyCioNotifier*& opNotifier);

  /** 
  * Gets the current state of a transaction.
  * @param iUuid [in]
  *   The identifier of the transaction.
  * @param oState [out]
  *   The current state of transaction.
  *   The parameter role...
  * @param oStatus [out]
  *   The 
  *
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL;
  */
  HRESULT GetTransactionState(const CATUuid& iContextUuid, enum eTransactionState& oState, HRESULT& oStatus);

  /** 
  * Register a Monitor
  * @param iCioMonitor [in]
  *   The given monitor
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */
	HRESULT SetMonitor(CATIOmyCuteIOMonitor * iCioMonitor);

  /** 
  * Return a Monitor (don't forget to release it after use)
	* @param oCioMonitor [out, IUnknown#Release]
	*   The retrieved monitor
  * @return
  *   <code>S_OK</code> if everything ran ok, otherwise E_FAIL.
  */
  HRESULT GetMonitor(CATIOmyCuteIOMonitor *& oCioMonitor);
  
  /** 
  * Destroy the Monitor
  */
  void DestroyMonitor();

  /** 
  * Gets the size of data to transfer from/to a distant PLM vault to/from internal CuteIO caches.
  * @param iTransUuid [in]
  *   The identifier of the internal CuteIO transaction.
  * @param oSizeinKo [out]
  *   The returned size in Kilo Bytes.
  * @return
  * <UL>
  *   <LI><code>S_OK</code> if everything ran ok.</LI>
  *   <LI><code>E_NOTIMPL</code> if this service is not implemented by the internal transation.</LI>
  *   <LI><code>E_FAIL</code> if an error occurs.</LI>
  * </UL>
  */
  HRESULT GetSizeOfStreamsToTransfer(const CATUuid& iTransUuid, unsigned int& oSizeinKo) const;

  /**
  *Gets canceled streams (not available from source vault). These entries have been deleted from cache and a fallback download can be launched.
  * @param iTransUuid [in]
  *   The identifier of the internal CuteIO transaction.
  * @param oCanceledContexts [out]
  *   The canceled streams represented by CATOmyCioUrlUsageCtx class
  * @param iAutoRelease
  *   If set to true, the ReleaseCanceledStreams behavior will be automatically called after getting canceled streams. This means this method couldn't be called anymore with this transUuid
  * @return
  * <UL>
  *   <LI><code>S_OK</code> if everything ran ok.</LI>
  *   <LI><code>S_FALSE</code> transaction is not completed yet and such status is unvailable.</LI>
  *   <LI><code>E_NOTIMPL</code> if this service is not implemented by the internal transation.</LI>
  *   <LI><code>E_FAIL</code> if an error occurs.</LI>
  * </UL>
  */
  HRESULT GetCanceledStreams(const CATUuid& iTransUuid, CATOmxList<CATOmyCioUrlUsageCtx>& oCanceledContexts, bool iAutoRelease=true);

  /* same as previous, but it will parse all input contexts for differents transactions (it can occurs espcially for multi store download)
  */
  HRESULT GetCanceledStreams(const CATOmxList<CATOmyCioUrlUsageCtx>& iContexts, CATOmxList<CATOmyCioUrlUsageCtx>& oCanceledContexts, bool iAutoRelease = true);

  /**
  * Allow the canceled context to be removed from manager or transaction (depending on its lifecycle)
  * @param iTransUuid [in]
  *   The identifier of the internal CuteIO transaction.
  */
  void ReleaseCanceledStreams(const CATUuid& iTransUuid);

  ~CATOmyCuteIOTransactionsManager();

private:
  
  CATOmyCuteIOTransactionsManager();
  void operator delete(void *iOld);

  CATOmyCuteIOTransactionsManager(const CATOmyCuteIOTransactionsManager &) = delete;
  CATOmyCuteIOTransactionsManager& operator=(const CATOmyCuteIOTransactionsManager&) = delete;
  
  CATOmyCuteIOTransaction* _GetTransaction(const CATUuid& iUuid) const;

  HRESULT UpdatePreparedUrl(const CATUuid& iUuid, const CATVVSUrl& iOldIndexUrl, int iOldWaterMarkstamp, const CATVVSUrl& iNewIndexUrl, int iNewWaterMarkstamp)
    {return UpdatePreparedLnkUrl(iUuid, iOldIndexUrl, iOldWaterMarkstamp, iNewIndexUrl, iNewWaterMarkstamp);}
  HRESULT UpdatePreparedLnkUrl(const CATUuid& iUuid, const CATVVSUrl& iOldIndexUrl, int iOldWaterMarkstamp, const CATVVSUrl& iNewIndexUrl, int iNewWaterMarkstamp);

  static CATOmyCuteIOTransactionsManager _Instance;
  CATOmxList<CATOmyCuteIOTransaction>    _TransactionList;
  CATOmxOHMap<CATUuid, CATOmxList<CATOmyCioUrlUsageCtx>, CATOmxDefaultCollecManager<CATUuid>::manager, canceledContextCollecManager > _CanceledContextsOnEndedTransactions;
	CATOmxSR<CATIOmyCuteIOMonitor>         _spCioMonitor;
};

//-----------------------------------------------------------------------

#endif
