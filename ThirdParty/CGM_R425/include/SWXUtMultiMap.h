//===================================================================
// COPYRIGHT DS SolidWorks 2010/09/17
//===================================================================
// SWXUtMultiMap.h
// Definition of SWXUtMultiMap
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/09/17 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUTMULTIMAP_H
#define SWXUTMULTIMAP_H

#include "SWXUtMap.h"
#include "SWXUtVector.h"
#include "SWXUtPair.h"

template<class KEYTYPE, class VALUETYPE, class KEY_COMPARE =  SWXUtLess<KEYTYPE> > class SWXUtMultiMap 
{
public:
    typedef KEYTYPE KeyType_t;
    typedef VALUETYPE MappedType_t;
    typedef KEY_COMPARE KeyCompare_t;
    typedef SWXUtPair<const KeyType_t, MappedType_t> ValueType_t;

private:
    typedef SWXUtMap<int, ValueType_t> Container_t;
    typedef SWXUtMap<KeyType_t, Container_t *, KeyCompare_t> Map_t;

public:
	SWXUtMultiMap() :
      mMap(), mCounter(0)
	{
	}

    SWXUtMultiMap(const SWXUtMultiMap& iMap) :
        mMap(iMap.mMap), mCounter(iMap.mCounter)
	{
        for (typename Map_t::Iterator iter = mMap.Begin();iter != mMap.End();iter++)
        {
            Container_t *container = iter->second;

            iter->second = new Container_t();

            *iter->second = *container;
        }
	}

    SWXUtMultiMap& operator=(const SWXUtMultiMap& iRight)
    {
        if (this != &iRight)
        {
            Clear();

            mMap = iRight.mMap;
			mCounter = iRight.mCounter;

            for (typename Map_t::Iterator iter = mMap.Begin();iter != mMap.End();iter++)
            {
                Container_t *container = iter->second;

                iter->second = new Container_t();

                *iter->second = *container;
            }
        }

        return *this;
    }

    ~SWXUtMultiMap()
	{
        Clear();
    }

    void Clear()
	{
        for (typename Map_t::ConstIterator iter = mMap.Begin();iter != mMap.End();iter++)
        {
            delete iter->second;
        }

        mMap.Clear();
    }

    bool Empty() const
    {
        return mMap.Empty();
    }

    class ConstIterator
    {
    public:
		ConstIterator() :
			mMapIter(),
			mContainerIter(),
			mMap()
		{
		}

        ConstIterator(const ConstIterator& iIter) :
			mMapIter(iIter.mMapIter),
			mContainerIter(iIter.mContainerIter),
			mMap(iIter.mMap)
		{
		}
    
        virtual ~ConstIterator()
        {
        }

        ConstIterator& operator=(const ConstIterator& iRight)
        {
            if (this != &iRight)
            {
                mMap =  iRight.mMap;
                mMapIter = iRight.mMapIter;
                mContainerIter = iRight.mContainerIter;
            }

            return *this;
        }

		const ValueType_t operator*() const
		{
            return  mContainerIter->second;
		}

        const ValueType_t* operator->() const
		{
			return &mContainerIter->second;
		}

        ConstIterator& operator++() 
		{
			if (mMapIter != mMap->End())
            {
                mContainerIter++;

                if (mContainerIter == mMapIter->second->End())
                {
                    mMapIter++;

                    if (mMapIter == mMap->End())
                    {
                        mContainerIter =  typename Container_t::Iterator();
                    }
                    else
                    {
                        mContainerIter = mMapIter->second->Begin();
                    }
                }
            }

			return (*this);
		}
        
        ConstIterator operator++(int) 
		{	
			ConstIterator _Tmp = *this;

			++*this;

			return (_Tmp);
		}


		bool operator==(const ConstIterator& iRight) const
		{
			return mMapIter == iRight.mMapIter && mContainerIter == iRight.mContainerIter;
		}

		bool operator!=(const ConstIterator& iRight) const
		{	
			return (!(*this == iRight));
		}

    protected:
        ConstIterator(const Map_t* iMap, typename Map_t::ConstIterator iMapIter, typename Container_t::ConstIterator iContainerIter) :
			mMapIter(iMapIter),
			mContainerIter(iContainerIter),
			mMap(iMap)
        {
        }

        typename Map_t::ConstIterator         mMapIter;
        typename Container_t::ConstIterator   mContainerIter;

    private:
        const Map_t*                          mMap;

        friend class SWXUtMultiMap;
    };

    class Iterator : public ConstIterator
    {
    public:
        Iterator(const Iterator& iIter) :
             ConstIterator(iIter)
		{
		}
    
        virtual ~Iterator()
        {
        }

        Iterator& operator=(const Iterator& iRight)
        {
             if (this != &iRight)
             {
                 ConstIterator::operator=(iRight);
             }

             return *this;
        }

        ValueType_t operator*()
		{
			return this->mContainerIter->second;
		}

        ValueType_t* operator->()
		{
			return (ValueType_t*)&(this->mContainerIter->second);
		}

		Iterator& operator++()
		{
            ++(*(ConstIterator*)this);

			return (*this);
		}

		Iterator operator++(int)
		{	
            Iterator temp = *this;

			++*this;

			return temp;
		}

    protected:
        Iterator(const Map_t* iMap, typename Map_t::ConstIterator iMapIter, typename Container_t::ConstIterator iContainerIter) :
          ConstIterator(iMap, iMapIter, iContainerIter)
        {
        }

        friend class SWXUtMultiMap;
    };

    ConstIterator Begin() const
    {
        typename Map_t::Iterator iter =  mMap.Begin();

        if (iter == mMap.End())
        {
			return ConstIterator(&mMap, mMap.Begin(), typename Container_t::Iterator());
        }
        else
        {
            return ConstIterator(&mMap, iter, iter->second->Begin());
        }
    }

    ConstIterator End() const
    {
        return Iterator(&mMap, mMap.End(), typename Container_t::Iterator());
    }

    Iterator Begin()
    {
        typename Map_t::Iterator iter =  mMap.Begin();

        if (iter == mMap.End())
        {
            return Iterator(&mMap, mMap.Begin(), typename Container_t::Iterator());
        }
        else
        {
            return Iterator(&mMap, iter, iter->second->Begin());
        }
    }

    Iterator End()
    {
        return Iterator(&mMap, mMap.End(), typename Container_t::Iterator());
    }

    SWXUtPair<Iterator, bool> Insert(const ValueType_t& iPair)
	{
        typename Map_t::Iterator iter = mMap.Find(iPair.first);
        
        if (iter == mMap.End())
        {
            iter = mMap.Insert(SWXUtMakePair(iPair.first, new Container_t())).first;
        }

        return SWXUtPair<Iterator, bool>(Iterator(&mMap, iter, iter->second->Insert(SWXUtMakePair(mCounter++, SWXUtMakePair(iPair.first, iPair.second))).first), true);
    }

    void Erase(Iterator iPos)
    {
        mMap[iPos.mMapIter->first]->Erase(iPos.mContainerIter->first);
		
		if (mMap[iPos.mMapIter->first]->Empty())
		{
            delete iPos.mMapIter->second;

			mMap.Erase(iPos.mMapIter->first);
		}
    }

    ConstIterator Find(const KeyType_t& iKeyVal)  const
	{
        typename Map_t::Iterator iter = mMap.Find(iKeyVal);

        if (iter == mMap.End())
        {
            return End();
        }
        else
        {
            return ConstIterator(&mMap, iter, iter->second->Begin());
        }
	}

	Iterator Find(const KeyType_t& iKeyVal) 
	{
        typename Map_t::Iterator iter = mMap.Find(iKeyVal);

        if (iter == mMap.End())
        {
            return End();
        }
        else
        {
            return Iterator(&mMap, iter, iter->second->Begin());
        }
	}

    void Erase(const KeyType_t& iKeyVal)
    {
        typename Map_t::Iterator findIter = mMap.Find(iKeyVal);

        if (findIter != mMap.End())
        {
            delete findIter->second;

            mMap.Erase(findIter->first);
        }
    }

    size_t Size()
    {
        size_t n = 0;

        for (typename Map_t::ConstIterator iter = mMap.Begin();iter != mMap.End();iter++)
        {
            n += iter->second->Size();
        }

        return n;
    }

    Iterator LowerBound(const KeyType_t& iKeyVal) 
	{
        typename Map_t::Iterator iter = mMap.LowerBound(iKeyVal);

        if (iter == mMap.End())
        {
            return End();
        }
        else
        {
            return Iterator(&mMap, iter, iter->second->Begin());
        }
    }

	ConstIterator LowerBound(const KeyType_t& iKeyVal) const
	{	
		typename Map_t::ConstIterator iter = mMap.LowerBound(iKeyVal);

        if (iter == mMap.End())
        {
            return End();
        }
        else
        {
            return ConstIterator(&mMap, iter, iter->second->Begin());
        }
	}

    Iterator UpperBound(const KeyType_t& iKeyVal) 
	{
		typename Map_t::Iterator iter = mMap.UpperBound(iKeyVal);

        if (iter == mMap.End())
        {
            return End();
        }
        else
        {
            return Iterator(&mMap, iter, iter->second->Begin());
        }
	}

	ConstIterator UpperBound(const KeyType_t& iKeyVal) const
	{	
		typename Map_t::ConstIterator iter = mMap.UpperBound(iKeyVal);

        if (iter == mMap.End())
        {
            return End();
        }
        else
        {
            return ConstIterator(&mMap, iter, iter->second->Begin());
        }
	}

    size_t Count(const  KeyType_t& iKeyVal) const
	{
        typename Map_t::ConstIterator findIter = mMap.Find(iKeyVal);

        if (findIter == mMap.End())
        {
            return 0;
        }
        else
        {
            return findIter->second->Size();
        }
	}

private:
    Map_t   mMap;
	int		mCounter;

    static int CompareKeys(const void* iLeft, const void* iRight)
	{
		const ValueType_t* leftPair = (const ValueType_t *)iLeft;
		const ValueType_t* rightPair = (const ValueType_t *)iRight;

		if (KeyCompare_t()(leftPair->first, rightPair->first))
		{
			return -1;
		}
		else
		{
			if (KeyCompare_t()(rightPair->first, leftPair->first))
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}

    friend class Iterator;
    friend class ConstIterator;
};

#endif
