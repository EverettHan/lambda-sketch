//===================================================================
// COPYRIGHT Dassault Systems 2018-10-02
//===================================================================
// VisMaterialPropertiesHelper.cpp
// Header definition of class VisMaterialPropertiesHelper
//===================================================================
//
// Usage notes:
//===================================================================
//  2018-10-02 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef VisMaterialPropertiesHelper_H
#define VisMaterialPropertiesHelper_H

#include "SGInfra.h"

#include "IVisTexturePtr.h"
#include "IVisTexturePtr.h"
#include "VisMaterialModel.h"
#include "VisMaterialModelVersion.h"
#include "VisMaterialTextureSampler.h"

#include "CAT3x3Matrix.h"

class CATGraphicMaterial;
class l_VisMaterialPropertiesHelper;

/** Class to help modify material properties without need to know type of material.
* Supported material types:
*   CATBasicMaterial (without shader)
*   REPhysicalMaterial
*   REVisMaterial
* Note:
* - Object of this class can be created on stack (no need to new/delete). 
* - You can call SetMaterial multiple times. Other helper APIs will work on last material set. 
* - This calss doesn’t own the material set (doesn't do addref). It keeps a weak reference of material. 
*/

class ExportedBySGInfra VisMaterialPropertiesHelper
{
public:
  // Standard constructors and destructors
  // -------------------------------------
  VisMaterialPropertiesHelper();
  virtual ~VisMaterialPropertiesHelper();

  /**
  * Set the interested material 
  * @return
  *   S_OK: success
  *   E_NOTIMPL: material is not supported 
  *   E_FAIL: failure (unknown reason)
  */
  HRESULT SetMaterial(CATGraphicMaterial* ipMat);

  /**
  * Query if material is transparent 
  * @args
  *   oFlag: store the result of the query
  * @return
  *   E_FAIL: some error occurred. oFlag is unusable.
  *   S_FALSE: oFlag is true in this case, but material may or may not appear transparent.
  *            This means transparency is not coming from coefficient but from texture.
  *            Actual rendering will depend on contents of texture (which are not interrogated at this time due to performance reasons)
  *   S_OK: Query successful in knowing definitely if material is transparent or not.
  *         Material is definitely transparent if either, transparency coefficient > 0.0 OR alpha coefficient is < 1.0
  */
  HRESULT IsTransparent(bool &oFlag) const;

  /**
  * Query if material is emissive
  * @args
  *   oFlag: store the result of the query
  * @return
  *   E_FAIL: some error occurred. oFlag is unusable.
  *   S_OK: if oFlag is false the material is definitely not emissive,
  *         if oFlag is true it means that the material has paramaters set, that potentially create emission.
  *         If the relevant parameter is textured, actual rendering will depend on contents of texture (which are not interrogated at this time due to performance reasons).
  */
  HRESULT IsEmissive(bool& oFlag) const;

  /**
  * Get material appearance color
  * @out RGB color. Range [0.0, 1.0]
  * @return
  *   S_OK: success
  *   S_FALSE: value is not used as texture is used to infer color 
  *   E_NOTIMPL: material doesn't support this property
  *   E_FAIL: failure to get color (unknown reason)
  */
  HRESULT GetColor(float &oR, float &oG, float &oB) const;

  /**
  * Set material appearance color
  * @in RGB color. Range [0.0, 1.0]
  * @return
  *   S_OK: success
  *   S_FALSE: value is changed but will not be used as texture is used to infer color  
  *   E_NOTIMPL: material doesn't support this property
  *   E_FAIL: failure to set color (unknown reason)
  */
  HRESULT SetColor(float iR, float iG, float iB);

  /**
  * Get material appearance transparency coefficient.
  * This is physically accurate transparancy and not all material models might support this. (Ex. Metal)
  * @args
  *   oT: range [0.0, 1.0]. 0: not transparent. 1: fully transparent
  * @return
  *   S_OK: success
  *   S_FALSE: value is not used as texture is used to infer transparency  
  *   E_NOTIMPL: material doesn't support this property
  *   E_FAIL: failure to get transparency (unknown reason)
  */
  HRESULT GetTransparency(float &oT) const;

  /**
  * Set material appearance transparency coefficient
  * This is physically accurate transparancy and not all material models might support this. (Ex. Metal)
  * @args
  *   iT: range [0.0, 1.0]. 0: not transparent. 1: fully transparent
  * @return
  *   S_OK: success
  *   S_FALSE: value is changed but will not be used as texture is used to infer transparency 
  *   E_NOTIMPL: material doesn't support this property
  *   E_FAIL: failure to set transparency (unknown reason)
  */
  HRESULT SetTransparency(float iT);

  /**
  * Get material appearance texture
  * @out RGB color. Range [0.0, 1.0]
  * @return
  *   S_OK: success
  *   S_FALSE: texture is not used to infer color
  *   E_NOTIMPL: material doesn't support this property
  *   E_FAIL: failure to get color (unknown reason)
  */
  HRESULT GetColorTexture(IVisTexturePtr &oTex) const;

  /**
  * Get alpha coefficient. Material transparency is multiplied by this coefficent. 1.0 by default.
  * @in range [0.0, 1.0]
  * @return
  *   S_OK: success
  *   E_NOTIMPL: not supported by material. Use GetTransparency.
  *   E_FAIL: failure to get transparency (unknown reason)
  */
  HRESULT GetAlphaCoefficient(float &oA) const;

  /**
  * Set alpha coefficient. Material transparency is multiplied by this coefficent. 1.0 by default.
  * @in range [0.0, 1.0]
  * @return
  *   S_OK: success
  *   E_NOTIMPL: not supported by material. Use SetTransparency.
  *   E_FAIL: failure to get transparency (unknown reason)
  */
  HRESULT SetAlphaCoefficient(float iA);

  /**
  * Query if material is converted from REPhysicalMaterial
  * @args
  *   oFlag: store the result of the query
  * @return
  *   E_FAIL: some error occurred. oFlag is unusable.
  *   S_FALSE: oFlag is true in this case, but material may or may not appear transparent.
  *            This means transparency is not coming from coefficient but from texture.
  *            Actual rendering will depend on contents of texture (which are not interrogated at this time due to performance reasons)
  *   S_OK: Query successful in knowing definitely if material is transparent or not.
  *         Material is definitely transparent if either, transparency coefficient > 0.0 OR alpha coefficient is < 1.0
  */
  HRESULT IsConvertedFromREPhysicalMaterial(bool& oFlag) const;

  /**
  * Get material model given a type description
  * @args
  *   iTypeDesc: input type description of material model version
  * @return
  *   pointer to the VisMaterialModel instance  
  */
  const VisMaterialModel* GetMaterialModel(const VisMaterialModelVersion::TypeDesc& iTypeDesc) const;

  /**
  * Create an instance of VisMaterialTextureSamplerWithTransform
  * @args
  *   iTrf: input 3x3 transformation matrix
  * @return
  *   a VisMaterialTextureSamplerWithTransform instance
  *   (VisMaterialTextureSamplerWithTransform is inherited from VisMaterialTextureSampler)
  */
  VisMaterialTextureSampler GetSamplerWithTransform(const CAT3x3Matrix& iTrf) const;

private:
  // Copy constructor and equal operator
  // -----------------------------------
  VisMaterialPropertiesHelper(VisMaterialPropertiesHelper &);
  VisMaterialPropertiesHelper& operator=(VisMaterialPropertiesHelper&);

  l_VisMaterialPropertiesHelper *m_pImpl;
};

//-----------------------------------------------------------------------

#endif
