//===================================================================
// COPYRIGHT Dassault Systemes 2019/10/07
//===================================================================
// CATPolyVertexKDTree.cpp
// Header definition of class CATPolyVertexKDTree
//===================================================================
//
// Usage notes:
//
// I (DGE2) developed this in 2019 for the prototype of a Boolean Operator.
// It was coded with performances in mind (time and memory-wise), to be built, updated and queried as fast as possible,
// while not being too naive when it comes to node subdivision.
// There aren't many functionalities, but feel free to expand them.
//
//===================================================================
//  2019/10/07 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATPolyVertexKDTree_H
#define CATPolyVertexKDTree_H

// PolyhedralOperators
#include "CATPolyGriddingTools.h"
#include "CATPolyBaseKDTree.h"

// Mathematics
#include "CATMathPoint.h"
#include "CATMathFP.h"

// System
#include "CATErrorDef.h"

#include <vector>
#include <algorithm>

/**
* A KD-Tree of vertices.
* This has been made a template to cope with various representations of vertices.
* This KD-tree is directly manipulated : vertices are added, removed and the tree is updated by the user.
* There are wrappers which take care of keeping the tree up to date.
* @see CATPolyMeshVertexKDTree
* @see CATPolyOverlayTipKDTree
*/
template <typename Vertex>
class CATPolyVertexKDTree : public CATPolyBaseKDTree<Vertex>
{
public:

  /**
  * @brief Main constructor. Do not forget to call Initialize.
  */
  CATPolyVertexKDTree ();

  /**
  * @brief Sets the maximum number of vertices allowed in one leaf.
  * Leaves may occasionally contain more vertices than that, if there are too many coincident vertices.
  * Default value is set to 30.
  */
  void SetMaxNumberOfVerticesInLeaf (const unsigned int iMaxNbVerticesPerLeaf) { _MaxNbVerticesPerLeaf = iMaxNbVerticesPerLeaf; }

  /**
  * @brief Sets the number of threads used during initialization and update of the KD-tree.
  * Default value is 1 (monothreaded behavior).
  * To be called before Initialize.
  */
  void SetNumberOfWorkers (const unsigned int iNbWorkers) { this->_NbWorkers = iNbWorkers; }

  ~CATPolyVertexKDTree ();

  /**
  * @brief Initializes the tree with all points of the mesh and setups the observer.
  * @param iGetPosition : this is an object with a public method of signature : HRESULT Get (Vertex iVertex, CATMathPoint &oPosition) const, used to recover the position of vertices.
  * @param iNbVertices : the number of vertices to be inserted. Optional, it is used to preallocate memory.
  * @param iVtxItr : an iterator over vertices to be inserted, in the same fashion as all iterators used in the Polyhedral frameworks.
  */
  template <class GetVertexPosition, class VertexIterator>
  HRESULT Initialize (const GetVertexPosition& iGetPosition, const size_t iNbVertices, VertexIterator& iVtxItr);

  /**
  * @brief Traverses the tree and subdivide all edited leaves which contain too many vertices.
  * @param iGetPosition : this is an object with a public method of signature : HRESULT Get (Vertex iVertex, CATMathPoint &oPosition) const, used to recover the position of vertices.
  */
  template <class GetVertexPosition>
  HRESULT Update (const GetVertexPosition& iGetPosition);

public:

  /**
  * @brief Adds a new vertex to the KD-tree and subdivides leaves on the spot if necessary.
  * @param iVertex : the vertex to add.
  * @param iGetPosition : this is an object with a public method of signature : HRESULT Get (Vertex iVertex, CATMathPoint &oPosition) const, used to recover the position of vertices.
  */
  template <class GetVertexPosition>
  HRESULT AddVertexAndUpdate (const Vertex iVertex, const GetVertexPosition& iGetPosition);

  /**
  * @brief Adds a new vertex to the KD-tree while keeping the tree structure unchanged.
  * Affected leaves are marked as edited to be subdivided during update, if necessary.
  * @param iVertex : the vertex to add.
  * @param iPosition : position of iVertex.
  */
  HRESULT AddVertex (const Vertex iVertex, const CATMathPoint& iPosition);

  /**
  * @brief Replaces a vertex in the KD-tree by another one at the same position.
  * @param iOldVertex : the old vertex to remove from the tree.
  * @param iNewVertex : the new vertex to replace the old one at the same position.
  * @param iPosition : position of iOldVertex and iNewVertex.
  */
  HRESULT ReplaceVertex (const Vertex iOldVertex, const Vertex iNewVertex, const CATMathPoint& iPosition);

  /**
  * @brief Removes vertex iVertex from the tree.
  * @param iVertex : the vertex to remove from the tree.
  * @param iPosition : the position of iVertex, which should be the same as when the vertex was added to the tree.
  */
  HRESULT RemoveVertex (const Vertex iVertex, const CATMathPoint& iPosition);

  /**
  * This method is used to navigate the tree and call user-defined methods on its chosen leaves.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a visited node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * The arguments to GetSides provide the dimension (0, 1 or 2) of the splitting plane and the splitting value for the current node.
  * @tparam Visitor : the object on which the method iCall is called for each visited leaf of the tree.
  * @tparam Call : the method type of the method called on iVisitor on leaves of the tree. It must have signature :
  * HRESULT Call(const Vertex* ipVertices, const unsigned int iNbVertices, Args... iArgs)
  * @tparam Args : remaining arguments of the method iCall beside the vertices in the visited leaf and the number of them.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT Traverse (Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

  /**
  * @brief Gather all vertices closer than iRadius from iCenter in oVertices.
  * @param iGetPosition : this is an object with a public method of signature : HRESULT Get (Vertex iVertex, CATMathPoint &oPosition) const, used to recover the position of vertices.
  * @param oVertices : array of all vertices in the sphere, with the square distance to its center for all of them.
  */
  template <class GetVertexPosition>
  HRESULT GetVerticesInSphere (const GetVertexPosition& iGetPosition, const CATMathPoint& iCenter, const double iRadius, std::vector<std::pair<Vertex, double>>& oVertices) const;

  /**
  * @brief Gets the closest vertex closer than iRadius from iCenter in oVertex, or zero otherwise.
  * @param iGetPosition : this is an object with a public method of signature : HRESULT Get (Vertex iVertex, CATMathPoint &oPosition) const, used to recover the position of vertices.
  */
  template <class GetVertexPosition>
  HRESULT GetClosestVertexInSphere (const GetVertexPosition& iGetPosition, const CATMathPoint& iCenter, const double iRadius, Vertex& oVertex) const;

private:

  using typename CATPolyBaseKDTree<Vertex>::Position;
  using typename CATPolyBaseKDTree<Vertex>::Node;
  using typename CATPolyBaseKDTree<Vertex>::Leaf;
  using typename CATPolyBaseKDTree<Vertex>::Child;
  using typename CATPolyBaseKDTree<Vertex>::DefaultTraverser;

  /**
  * A 3D position and a vertex index.
  */
  struct PointTraverser
  {
    PointTraverser (const Vertex iVertex, const CATMathPoint& iPoint);

    unsigned char GetSides (const unsigned char iDim, const double iValue);

    Vertex _Vertex;
    Position _Position;
  };

  struct CompareVertexPosition
  {
    CompareVertexPosition (const unsigned char iDimension) : _Dimension (iDimension) {}

    bool operator()(const PointTraverser& iFst, const PointTraverser& iSnd) const;

    unsigned char _Dimension;
  };

private:

  ///////////////////////////
  // Node building methods //
  ///////////////////////////

  using PointIterator = typename std::vector<PointTraverser>::iterator;

  HRESULT BuildChild (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints, Child& oNode, bool& oLeafFlag);

  HRESULT BuildNode (PointIterator iBgn, PointIterator iEnd, PointIterator iCut, const unsigned char iCutDimension, const size_t iNbLeftPoints, const size_t iNbRightPoints, Node*& opNode);

  HRESULT BuildLeaf (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints, Leaf*& opLeaf);

  unsigned char GetCutAxis (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints);

  PointIterator BuildCut (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints, const unsigned char iCutDimension, size_t& oNbLeftPoints, size_t& oNbRightPoints);

private:

  ////////////////////
  // Leaf operators //
  ////////////////////

  struct SphereTraverser
  {
    SphereTraverser (const CATMathPoint& iCenter, const double iRadius);

    unsigned char GetSides (const unsigned char iDim, const double iValue);

    double GetSquareDistance (const CATMathPoint& iPoint) const;

    Position _Center;
    double _Radius;
  };

  template <class GetVertexPosition>
  HRESULT FindClosestVertexInLeaf (const Node& iNode, const unsigned char iChildIdx, SphereTraverser& iSphere, const GetVertexPosition& iGetPosition, Vertex& oVertex) const;

  template <class GetVertexPosition>
  HRESULT GetVerticesInLeaf (const Node& iNode, const unsigned char iChildIdx, const SphereTraverser& iSphere, const GetVertexPosition& iGetPosition, std::vector<std::pair<Vertex, double>>& oVertices) const;

  template <class GetVertexPosition>
  HRESULT InsertVertexInLeafAndUpdate (Node& iNode, const unsigned char iChildIdx, const PointTraverser& iVertex, const GetVertexPosition& iGetPosition);

  template<class GetTrianglePosition>
  inline HRESULT CheckLeaf (Node& iNode, const unsigned char iChildIdx, const GetTrianglePosition& iGetPosition);

  template<class GetTrianglePosition>
  HRESULT UpdateLeaf (Node& iNode, const unsigned char iChildIdx, const GetTrianglePosition& iGetPosition);

  template<class GetTrianglePosition>
  HRESULT RebuildLeaf (Node& iNode, const unsigned char iChildIdx, std::vector<PointTraverser>& iVertexCache, const GetTrianglePosition& iGetPosition);

private:

  unsigned int _MaxNbVerticesPerLeaf; // Maximum number of vertices allowed in a leaf.
  std::vector<PointTraverser> _SplitCache;
};

template <typename Vertex>
CATPolyVertexKDTree<Vertex>::CATPolyVertexKDTree () :
  _MaxNbVerticesPerLeaf (30),
  _SplitCache ()
{
}

template <typename Vertex>
CATPolyVertexKDTree<Vertex>::~CATPolyVertexKDTree ()
{
}

template <typename Vertex>
CATPolyVertexKDTree<Vertex>::PointTraverser::PointTraverser (const Vertex iVertex, const CATMathPoint& iPoint) :
  _Vertex (iVertex),
  _Position ()
{
  _Position[0] = iPoint.GetX ();
  _Position[1] = iPoint.GetY ();
  _Position[2] = iPoint.GetZ ();
}

template <typename Vertex>
bool CATPolyVertexKDTree<Vertex>::CompareVertexPosition::operator()(const PointTraverser& iFst, const PointTraverser& iSnd) const
{
  return iFst._Position[_Dimension] < iSnd._Position[_Dimension];
}

template <typename Vertex>
template <class GetVertexPosition, class VertexIterator>
HRESULT CATPolyVertexKDTree<Vertex>::Initialize (const GetVertexPosition& iGetVertexPosition, const size_t iNbVertices, VertexIterator& iVtxItr)
{
  if(iNbVertices==0)
    return S_FALSE;

  HRESULT ret = S_FALSE;

  if (SUCCEEDED (ret = this->BuildWorkers ()))
  {
    std::vector<PointTraverser> vertices;
    vertices.reserve (iNbVertices);

    CATMathPoint position;
    for (; !iVtxItr.End () && SUCCEEDED (ret); ++iVtxItr)
      if (SUCCEEDED (ret = iGetVertexPosition.Get (*iVtxItr, position)))
        vertices.emplace_back (*iVtxItr, position);

    if (SUCCEEDED (ret))
    {
      auto bgn = vertices.begin ();
      auto end = vertices.end ();
      size_t nbPoints = vertices.size ();
      unsigned char cutDimension = GetCutAxis (bgn, end, nbPoints);
      size_t nbLeftPoints, nbRightPoints;
      PointIterator cut = BuildCut (bgn, end, nbPoints, cutDimension, nbLeftPoints, nbRightPoints);

      if (isnan(cut->_Position[cutDimension]))
        ret = E_FAIL; // protection
      else
      {
        ret = BuildNode(bgn, end, cut, cutDimension, nbLeftPoints, nbRightPoints, this->_pRoot);
        if (this->_NbWorkers > 1 && FAILED(this->WaitForCompletion()) && SUCCEEDED(ret))
          ret = E_FAIL;
      }
    }
  }
  return ret;
}

template <typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::Update (const GetVertexPosition& iGetPosition)
{
  DefaultTraverser traverser;
  HRESULT ret = Traverse (traverser, 0., this, &CATPolyVertexKDTree<Vertex>::CheckLeaf<GetVertexPosition>, std::cref (iGetPosition));
  if (this->_NbWorkers > 1 && FAILED (this->WaitForCompletion ()) && SUCCEEDED (ret))
    ret = E_FAIL;
  return ret;
}

template <typename Vertex>
HRESULT CATPolyVertexKDTree<Vertex>::BuildChild (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints, Child& oNode, bool& oLeafFlag)
{
  if (iNbPoints > _MaxNbVerticesPerLeaf)
  {
    unsigned char cutDimension = GetCutAxis (iBgn, iEnd, iNbPoints);
    size_t nbLeftPoints, nbRightPoints;
    PointIterator cut = BuildCut (iBgn, iEnd, iNbPoints, cutDimension, nbLeftPoints, nbRightPoints);
    if (cut != iBgn)
    {
      oLeafFlag = false;
      return BuildNode (iBgn, iEnd, cut, cutDimension, nbLeftPoints, nbRightPoints, oNode._pNode);
    }
  }
  oLeafFlag = true;
  return BuildLeaf (iBgn, iEnd, iNbPoints, oNode._pLeaf);
}

template <typename Vertex>
HRESULT CATPolyVertexKDTree<Vertex>::BuildNode (PointIterator iBgn, PointIterator iEnd, PointIterator iCut, const unsigned char iCutDimension, const size_t iNbLeftPoints, const size_t iNbRightPoints, Node*& opNode)
{
  HRESULT ret = E_OUTOFMEMORY;
  if (opNode = new Node ())
  {
    opNode->_CutDimension = iCutDimension;
    opNode->_CutValue = iCut->_Position[iCutDimension];

    if (this->_NbWorkers > 1)
    {
      this->_Mutex.lock ();
      this->_Tasks.push (std::bind (&CATPolyVertexKDTree::BuildChild, this, iBgn, iCut, iNbLeftPoints, std::ref (opNode->_Child[0]), std::ref (opNode->_IsChildLeaf[0])));
      this->_Tasks.push (std::bind (&CATPolyVertexKDTree::BuildChild, this, iCut, iEnd, iNbRightPoints, std::ref (opNode->_Child[1]), std::ref (opNode->_IsChildLeaf[1])));
      this->_NbTasksLeft += 2;
      this->_Mutex.unlock ();
      this->_WorkerNotifier.notify_one ();
      this->_WorkerNotifier.notify_one ();
      ret = S_OK;
    }
    else if (SUCCEEDED (ret = BuildChild (iBgn, iCut, iNbLeftPoints, opNode->_Child[0], opNode->_IsChildLeaf[0])))
      ret = BuildChild (iCut, iEnd, iNbRightPoints, opNode->_Child[1], opNode->_IsChildLeaf[1]);
  }
  return ret;
}

template <typename Vertex>
HRESULT CATPolyVertexKDTree<Vertex>::BuildLeaf (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints, Leaf*& opLeaf)
{
  if (opLeaf = Leaf::CreateLeaf (static_cast<unsigned int>(iNbPoints), static_cast<unsigned int>(iNbPoints)))
  {
    size_t nbPts = std::distance (iBgn, iEnd);
    if (nbPts != iNbPoints)
    {
      nbPts = 0;
    }

    Vertex* pVertices = opLeaf->GetElements ();
    unsigned int idx = 0;
    for (auto itr = iBgn; itr != iEnd; ++itr, ++idx)
      pVertices[idx] = itr->_Vertex;
    return S_OK;
  }
  return E_OUTOFMEMORY;
}

template <typename Vertex>
unsigned char CATPolyVertexKDTree<Vertex>::GetCutAxis (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints)
{
  double average[3] = { 0., 0., 0. };
  double variance[3] = { 0., 0., 0. };

  for (auto itr = iBgn; itr != iEnd; ++itr)
  {
    for (unsigned int dim = 0; dim < 3; ++dim)
    {
      average[dim] += itr->_Position[dim];
      variance[dim] += itr->_Position[dim] * itr->_Position[dim];
    }
  }

  for (unsigned int dim = 0; dim < 3; ++dim)
  {
    average[dim] /= iNbPoints;
    variance[dim] = variance[dim] / iNbPoints - average[dim] * average[dim];
  }

  return variance[0] > variance[1] ? variance[0] > variance[2] ? 0 : 2 : variance[1] > variance[2] ? 1 : 2; // Cut along max variance axis.
}

template <typename Vertex>
typename CATPolyVertexKDTree<Vertex>::PointIterator CATPolyVertexKDTree<Vertex>::BuildCut (PointIterator iBgn, PointIterator iEnd, const size_t iNbPoints, const unsigned char iCutDimension, size_t& oNbLeftPoints, size_t& oNbRightPoints)
{
  CompareVertexPosition cmp (iCutDimension);
  std::sort (iBgn, iEnd, cmp);

  size_t halfSize = iNbPoints / 2;
  auto last = iBgn;
  auto crnt = iBgn;
  size_t lastCount = 0;
  size_t crntCount = 0;
  while (crnt != iEnd && crntCount <= halfSize)
  {
    last = crnt;
    lastCount = crntCount;
    for (++crnt, ++crntCount; crnt != iEnd && crnt->_Position[iCutDimension] == last->_Position[iCutDimension]; ++crnt, ++crntCount);
  }

  if (crnt == iEnd)
  {
    crnt = last;
    crntCount = lastCount;
  }

  oNbLeftPoints = crntCount;
  oNbRightPoints = iNbPoints - crntCount;

  return crnt;
}

template<typename Vertex>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyVertexKDTree<Vertex>::Traverse (Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const
{
  return this->InternalTraverse (this->_pRoot, iTraverser, this, &CATPolyVertexKDTree::template Visit<Visitor, Call, Args...>, ipVisitor, iCall, iArgs...);
}

template<typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::AddVertexAndUpdate (const Vertex iVertex, const GetVertexPosition& iGetPosition)
{
  HRESULT ret = S_FALSE;
  CATMathPoint position;
  if (SUCCEEDED (ret = iGetPosition.Get (iVertex, position)))
  {
    PointTraverser traverser (iVertex, position);
    ret = this->InternalTraverse (this->_pRoot, traverser, this, &CATPolyVertexKDTree::InsertVertexInLeafAndUpdate<GetVertexPosition>, std::cref (traverser), std::cref (iGetPosition));
  }
  return ret;
}

template<typename Vertex>
HRESULT CATPolyVertexKDTree<Vertex>::AddVertex (const Vertex iVertex, const CATMathPoint& iPosition)
{
  PointTraverser traverser (iVertex, iPosition);
  return this->InternalTraverse (this->_pRoot, traverser, this, &CATPolyVertexKDTree::InsertInLeaf, iVertex);
}

template<typename Vertex>
HRESULT CATPolyVertexKDTree<Vertex>::ReplaceVertex (const Vertex iOldVertex, const Vertex iNewVertex, const CATMathPoint& iPosition)
{
  PointTraverser traverser (iOldVertex, iPosition);
  return this->InternalTraverse (this->_pRoot, traverser, this, &CATPolyVertexKDTree::ReplaceInLeaf, iOldVertex, iNewVertex);
}

template<typename Vertex>
HRESULT CATPolyVertexKDTree<Vertex>::RemoveVertex (const Vertex iVertex, const CATMathPoint& iPosition)
{
  PointTraverser traverser (iVertex, iPosition);
  return this->InternalTraverse (this->_pRoot, traverser, this, &CATPolyVertexKDTree::RemoveFromLeaf, iVertex);
}

template <typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::GetClosestVertexInSphere (const GetVertexPosition& iGetPosition, const CATMathPoint& iCenter, const double iRadius, Vertex& oVertex) const
{
  SphereTraverser traverser (iCenter, iRadius);
  return this->InternalTraverse (this->_pRoot, traverser, this, &CATPolyVertexKDTree::FindClosestVertexInLeaf<GetVertexPosition>, std::ref (traverser), std::cref (iGetPosition), std::ref (oVertex));
}

template <typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::GetVerticesInSphere (const GetVertexPosition& iGetPosition, const CATMathPoint& iCenter, const double iRadius, std::vector<std::pair<Vertex, double>>& oVertices) const
{
  SphereTraverser traverser (iCenter, iRadius);
  return this->InternalTraverse (this->_pRoot, traverser, this, &CATPolyVertexKDTree::GetVerticesInLeaf<GetVertexPosition>, std::cref (traverser), std::cref (iGetPosition), std::ref (oVertices));
}

template <typename Vertex>
CATPolyVertexKDTree<Vertex>::SphereTraverser::SphereTraverser (const CATMathPoint& iCenter, const double iRadius) :
  _Center (),
  _Radius (iRadius)
{
  _Center[0] = iCenter.GetX ();
  _Center[1] = iCenter.GetY ();
  _Center[2] = iCenter.GetZ ();
}

template <typename Vertex>
unsigned char CATPolyVertexKDTree<Vertex>::PointTraverser::GetSides (const unsigned char iDim, const double iValue)
{
  return static_cast<unsigned char>(_Position[iDim] >= iValue);
}

template <typename Vertex>
unsigned char CATPolyVertexKDTree<Vertex>::SphereTraverser::GetSides (const unsigned char iDim, const double iValue)
{
  return static_cast<unsigned char>(_Center[iDim] - _Radius < iValue) + 2 * static_cast<unsigned char>(_Center[iDim] + _Radius >= iValue) - 1;
}

template <typename Vertex>
double CATPolyVertexKDTree<Vertex>::SphereTraverser::GetSquareDistance (const CATMathPoint& iPoint) const
{
  return (iPoint.GetX () - _Center[0]) * (iPoint.GetX () - _Center[0]) + (iPoint.GetY () - _Center[1]) * (iPoint.GetY () - _Center[1]) + (iPoint.GetZ () - _Center[2]) * (iPoint.GetZ () - _Center[2]);
}

template <typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::FindClosestVertexInLeaf (const Node& iNode, const unsigned char iChildIdx, SphereTraverser& iSphere, const GetVertexPosition& iGetPosition, Vertex& oVertex) const
{
  if (iNode._Child[iChildIdx]._pLeaf)
  {
    Vertex* pVertices = iNode._Child[iChildIdx]._pLeaf->GetElements ();
    unsigned int nbVertices = iNode._Child[iChildIdx]._pLeaf->_Size;
    double sqrDist;
    double sqrRadius = iSphere._Radius * iSphere._Radius;
    CATMathPoint position;
    for (unsigned int vtxIdx = 0; vtxIdx < nbVertices; ++vtxIdx)
    {
      if (SUCCEEDED (iGetPosition.Get (pVertices[vtxIdx], position)) && (sqrDist = iSphere.GetSquareDistance (position)) <= sqrRadius)
      {
        sqrRadius = sqrDist;
        iSphere._Radius = CATSqrt (sqrRadius);
        oVertex = pVertices[vtxIdx];
      }
    }
  }
  return S_OK;
}

template <typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::GetVerticesInLeaf (const Node& iNode, const unsigned char iChildIdx, const SphereTraverser& iSphere, const GetVertexPosition& iGetPosition, std::vector<std::pair<Vertex, double>>& oVertices) const
{
  if (iNode._Child[iChildIdx]._pLeaf)
  {
    Vertex* pVertices = iNode._Child[iChildIdx]._pLeaf->GetElements ();
    unsigned int nbVertices = iNode._Child[iChildIdx]._pLeaf->_Size;
    double sqrRadius = iSphere._Radius * iSphere._Radius;
    double sqrDist;
    CATMathPoint position;
    for (unsigned int vtxIdx = 0; vtxIdx < nbVertices; ++vtxIdx)
      if (SUCCEEDED (iGetPosition.Get (pVertices[vtxIdx], position)) && (sqrDist = iSphere.GetSquareDistance (position)) <= sqrRadius)
        oVertices.emplace_back (pVertices[vtxIdx], sqrDist);
  }
  return S_OK;
}

template <typename Vertex>
template<class GetTrianglePosition>
HRESULT CATPolyVertexKDTree<Vertex>::RebuildLeaf (Node& iNode, const unsigned char iChildIdx, std::vector<PointTraverser>& iVertexCache, const GetTrianglePosition& iGetPosition)
{
  HRESULT ret = S_OK;
  Leaf* pLeaf = iNode._Child[iChildIdx]._pLeaf;
  if (pLeaf)
  {
    CATMathPoint position;
    Vertex* pVertices = pLeaf->GetElements ();
    for (unsigned int vtxIdx = 0; vtxIdx < pLeaf->_Size && SUCCEEDED (ret); ++vtxIdx)
      if (SUCCEEDED (ret = iGetPosition.Get (pVertices[vtxIdx], position)))
        iVertexCache.emplace_back (pVertices[vtxIdx], position);
    if (SUCCEEDED (ret))
    {
      free (pLeaf);
      pLeaf = nullptr;
      ret = BuildChild (iVertexCache.begin (), iVertexCache.end (), iVertexCache.size (), iNode._Child[iChildIdx], iNode._IsChildLeaf[iChildIdx]);
    }
  }
  else
    ret = E_FAIL;
  return ret;
}

template <typename Vertex>
template <class GetVertexPosition>
HRESULT CATPolyVertexKDTree<Vertex>::InsertVertexInLeafAndUpdate (Node& iNode, const unsigned char iChildIdx, const PointTraverser& iVertex, const GetVertexPosition& iGetPosition)
{
  HRESULT ret = S_OK;
  Leaf* pLeaf = iNode._Child[iChildIdx]._pLeaf;
  if (pLeaf)
  {
    if (pLeaf->_Size < _MaxNbVerticesPerLeaf)
      ret = this->InsertInLeaf (iNode, iChildIdx, iVertex._Vertex);
    else
    {
      _SplitCache.reserve (static_cast<size_t>(pLeaf->_Size) + 1);
      _SplitCache.push_back (iVertex);
      ret = RebuildLeaf (iNode, iChildIdx, _SplitCache, iGetPosition);
      if (this->_NbWorkers > 1 && FAILED (this->WaitForCompletion ()) && SUCCEEDED (ret))
        ret = E_FAIL;
      _SplitCache.clear ();
    }
  }
  else
    ret = E_FAIL;
  return ret;
}

template <typename Vertex>
template<class GetTrianglePosition>
inline HRESULT CATPolyVertexKDTree<Vertex>::CheckLeaf (Node& iNode, const unsigned char iChildIdx, const GetTrianglePosition& iGetPosition)
{
  HRESULT ret = S_FALSE;

  if (iNode._IsChildToUpdate[iChildIdx])
  {
    if (this->_NbWorkers > 1)
    {
      this->_Mutex.lock ();
      this->_Tasks.push (std::bind (&CATPolyVertexKDTree::UpdateLeaf, this, std::ref (iNode), iChildIdx, std::cref (iGetPosition)));
      ++this->_NbTasksLeft;
      this->_Mutex.unlock ();
      this->_WorkerNotifier.notify_one ();
      ret = S_OK;
    }
    else
      ret = UpdateLeaf (iNode, iChildIdx, iGetPosition);
  }
  return ret;
}

template <typename Vertex>
template<class GetTrianglePosition>
HRESULT CATPolyVertexKDTree<Vertex>::UpdateLeaf (Node& iNode, const unsigned char iChildIdx, const GetTrianglePosition& iGetPosition)
{
  std::vector<PointTraverser> vertices;
  vertices.reserve (static_cast<size_t>(iNode._Child[iChildIdx]._pLeaf ? iNode._Child[iChildIdx]._pLeaf->_Size : 0));
  return RebuildLeaf (iNode, iChildIdx, vertices, iGetPosition);
}

extern template class ExportedTemplateByCATPolyGriddingTools CATPolyVertexKDTree<int>;

#endif
