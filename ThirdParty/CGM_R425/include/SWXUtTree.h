//===================================================================
// COPYRIGHT DS SolidWorks 2010/09/17
//===================================================================
// SWXUtTree.h
// Definition of SWXUtTree
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/09/17 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUTTREE_H
#define SWXUTTREE_H

#include "CATSysDataType.h"
#include "SWXUtAvlTree.h"
#include "SWXUtAvlTreeCursor.h"
#include "SWXUtError.h"
#include "SWXUtLess.h"
#include "SWXUtPair.h"
#include "SWXUtTrackedIterator.h"
#include "SWXUtIteratorTracker.h"

template <class KEYTYPE, class KEY_COMPARE =  SWXUtLess<KEYTYPE> > class SWXUtTree
{
public:
	typedef KEYTYPE ValueType_t;

    virtual ~SWXUtTree()
	{
		Clear();

        delete mEndCursorConstIterator;
        mEndCursorConstIterator = NULL;

		delete mEndCursorIterator;
        mEndCursorIterator = NULL;
	}

	void Clear()
	{
        InvalidateAllIterators();

        mTree.DeleteItems(DeleteItem, this);
	}

    bool Empty() const
    {
        return mTree.GetItemNumber() == 0;
    }

    class ConstIterator : public SWXUtTrackedIterator
	{
	public:
		ConstIterator() :
              SWXUtTrackedIterator(),
			  mCursor(NULL),
              mTree(NULL)
		{
		}

        ConstIterator(const ConstIterator& iIter) :
              SWXUtTrackedIterator(),
			  mCursor(iIter.mCursor),
              mTree(iIter.mTree)
		{
            if (mTree != NULL)
            {
                mTree->AddIterator(this);
            }
		}
    
        virtual ~ConstIterator()
        {
            if (mTree != NULL)
            {
                mTree->RemoveIterator(this);
            }
        }

		virtual void InvalidateIter()
		{
			mTree = NULL;
		}

        ConstIterator& operator=(const ConstIterator& iRight)
        {
            if (this != &iRight)
            {
                if (mTree != NULL)
                {
                    mTree->RemoveIterator(this);
                }

                mCursor = iRight.mCursor;
                mTree = iRight.mTree;

                if (mTree != NULL)
                {
                    mTree->AddIterator(this);
                }
            }

            return *this;
        }

		const ValueType_t* Item()
		{
            Validate();

			return (const ValueType_t*) mCursor.GetItem();
		}

		const ValueType_t& operator*() const
		{
			Validate();

            return * (const ValueType_t*) mCursor.GetItem();
		}

		ConstIterator& operator++() 
		{
			Validate();

            mCursor.Increment();

			return (*this);
		}

		ConstIterator operator++(int) 
		{	
			ConstIterator _Tmp = *this;

			++*this;

			return (_Tmp);
		}

		const ValueType_t* operator->() const
		{	
			Validate();

            return (ValueType_t*)( mCursor.GetItem());
		}

		bool operator==(const ConstIterator& iRight) const
		{
			if (mCursor.Tree() == iRight.mCursor.Tree())
			{
				return mCursor.GetItem() == iRight.mCursor.GetItem();
			}

			return false;
		}

		bool operator!=(const ConstIterator& iRight) const
		{	
			return (!(*this == iRight));
		}

	protected:
		ConstIterator(const SWXUtAvlTreeCursor& iCursor, const SWXUtTree *iTree) :
              SWXUtTrackedIterator(),
			  mCursor(iCursor),
              mTree((SWXUtTree*)iTree)
		{
            if (mTree != NULL)
            {
                mTree->AddIterator(this);
            }
		}

        SWXUtAvlTreeCursor  mCursor;
        SWXUtTree           *mTree;

		void Validate() const
        {
            if (mCursor.Tree() == NULL)
            {
                CATThrow(new SWXUtError(SWXUtError::InvalidIterator));
            }
        }

        bool InvalidateForNode(SWXUtAvlTreeNode *iNode)
        {
            if (mCursor.Tree() != NULL)
            {
                if (mCursor.Node() == iNode)
                {
                    mCursor = SWXUtAvlTreeCursor(NULL);

                    return true;
                }
            }

            return false;
        }

        bool Invalidate()
        {
            if (mCursor.Tree() != NULL)
            {
                if (mCursor.Node() != NULL)
                {
                    mCursor = SWXUtAvlTreeCursor(NULL);

                    return true;
                }
            }

            return false;
        }

        template<class K, class KC> friend class SWXUtTree;
        template<class K, class KC>  friend class SWXUtSet;
        template<class K, class V, class KC> friend class SWXUtMap;
	};

	class Iterator : public ConstIterator
	{
	public:
		Iterator() :
			  ConstIterator()
		{
		}

        Iterator(const Iterator& iIter) :
			  ConstIterator(iIter)
		{
		}

        Iterator& operator=(const Iterator& iRight)
        {
             if (this != &iRight)
             {
                 ConstIterator::operator=(iRight);
             }

             return *this;
        }

		ValueType_t operator*() const
		{
            this->Validate();

            return *(ValueType_t*)this->mCursor.GetItem();
		}

		Iterator& operator++()
		{
            this->Validate();

            ++(*(ConstIterator*)this);

			return (*this);
		}

		Iterator operator++(int)
		{	
            this->Validate();

            Iterator temp = *this;

			++*this;

			return temp;
		}

        ValueType_t* operator->() const
		{	
            this->Validate();

            return (ValueType_t*)this->mCursor.GetItem();
		}

    protected:
       	Iterator(const SWXUtAvlTreeCursor& iCursor, const SWXUtTree *iTree) :
			  ConstIterator(iCursor, iTree)
		{
		}

        template<class K, class KC> friend class SWXUtTree;
        template<class K, class KC>  friend class SWXUtSet;
        template<class K, class V, class KC> friend class SWXUtMap;
	};

    SWXUtPair<Iterator, bool> Insert(const ValueType_t& iValue)
	{
		ValueType_t* t = new ValueType_t(iValue);

		SWXUtAvlTreeCursor cursor = mTree.InsertItem(t);

        if (cursor.IsAfterLastItem())
        {
            // Duplicate value, not inserted so delete

            delete t;
        }

        return SWXUtMakePair(Iterator(cursor, this), !cursor.IsAfterLastItem());
	}

	Iterator Begin()
	{
		Iterator begin(SWXUtAvlTreeCursor(mTree), this);

        begin.mCursor.ResetOnFirstItem();

        return begin;
	}

	ConstIterator Begin() const
	{
        ConstIterator begin(SWXUtAvlTreeCursor(mTree), this);

        begin.mCursor.ResetOnFirstItem();

		return begin;
	}

	ConstIterator End() const
	{
		return *mEndCursorConstIterator;
	}

	Iterator End() 
	{
		return *mEndCursorIterator;
	}

	size_t Size() const
	{
		return mTree.GetItemNumber();
	}

protected:
    SWXUtTree(SWXUtCompareFunction iCompareFunction) :
	    mTree(iCompareFunction),
		mEndCursor(&mTree)
	{
        mEndCursorConstIterator = new ConstIterator(mEndCursor, this);
        mEndCursorIterator = new Iterator(mEndCursor, this);
	}

    SWXUtTree& operator=(const SWXUtTree& iRight)
    {
        if (this != &iRight)
        {
            Clear();

            mTree.SetCompareFunction(iRight.mTree.GetCompareFunction());

            for(ConstIterator iter = iRight.Begin();iter != iRight.End();iter++)
            {
                Insert(*iter);
            }
        }

        return *this;
    }

	void RemoveItem(void *v)
	{
		mTree.RemoveItem(v, DeleteItem, this);
	}

    static void DeleteItem(SWXUtAvlTreeNode* iNode, void* iValue, void* iClosure)
    {
        SWXUtTree* tree = (SWXUtTree*)iClosure;

        if (tree != NULL)
        {
            tree->InvalidateIteratorsForNode(iNode);
        }

        ValueType_t* val = (ValueType_t*)iValue;

        delete val;
    }

    void InvalidateIteratorsForNode(SWXUtAvlTreeNode* iNode)
    {
        for (ConstIterator* iter = (ConstIterator*)mIteratorTracker.FirstIter();iter != NULL;)
        {
            ConstIterator* temp  = (ConstIterator*)mIteratorTracker.NextIter(iter);

            if (iter->InvalidateForNode(iNode))
            {
                RemoveIterator(iter);
            }

            iter = temp;
        }
    }

    void InvalidateAllIterators()
    {
        for (ConstIterator* iter = (ConstIterator*)mIteratorTracker.FirstIter();iter != NULL;)
        {
            ConstIterator* temp  = (ConstIterator*)mIteratorTracker.NextIter(iter);

            if (iter->Invalidate())
            {
                RemoveIterator(iter);
            }

            iter = temp;
        }
    }

    void AddIterator(ConstIterator* iIter)
    {
        mIteratorTracker.AddIterator(iIter);
    }

    void RemoveIterator(ConstIterator* iIter)
    {
        mIteratorTracker.RemoveIterator(iIter);
    }

    SWXUtAvlTree			mTree;
	SWXUtAvlTreeCursor		mEndCursor;
	ConstIterator			*mEndCursorConstIterator;
	Iterator				*mEndCursorIterator;

    SWXUtIteratorTracker    mIteratorTracker;
};

#endif
