//===================================================================
// COPYRIGHT Dassault Systemes 2014/06/19
//===================================================================
// CATOmyAsyncRequestNotifier.cpp
// Header definition of class CATOmyAsyncRequestNotifier
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2014/06/19 Creation: Code generated by the 3DS wizard
//===================================================================
#ifndef CATOmyAsyncRequestNotifier_H
#define CATOmyAsyncRequestNotifier_H

/**
 * @level Protected
 * @usage U1
 */
#undef ExportedByCATOmyAsyncInterfaces
//-----------------------------------------------------
//  Check that only authorized modules can link on the exported symbols
//----------------------------------------------------
// List of forbidden re-define
#if defined(private) || defined(friend) || defined(protected)
  #error Forbidden re-define of 'private', 'friend' or 'protected'
  // Fatal error on solaris
  @error 
#endif

#define AuthorizedModuleForCATOmyAsyncRequestNotifier 888

// Check no one makes a declaration to by-pass our control. 
#if _MK_MODNAME_ == AuthorizedModuleForCATOmyAsyncRequestNotifier  
  #error Module declared as authorized by another header  
  // Fatal error on solaris
  @error 
#endif  

// List of authorized infrastructure modules 
// Framework ObjectModelerSystem
#define CATOMYAsyncInterfaces	   AuthorizedModuleForCATOmyAsyncRequestNotifier 
#define CATOMYBaseSession	       AuthorizedModuleForCATOmyAsyncRequestNotifier 
#define CATPLMChronos            AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATAsyncServices         AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATAsyncTasksPlatform_NG AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATAsyncStreamRequests   AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATOMYHTTP               AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATOMYCommunication      AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATPLMxProviderImpl      AuthorizedModuleForCATOmyAsyncRequestNotifier
#define CATOMYCuteIOAccess       AuthorizedModuleForCATOmyAsyncRequestNotifier

#if _MK_MODNAME_ == AuthorizedModuleForCATOmyAsyncRequestNotifier
#else
  #error Forbidden Access To CATOmyAsyncRequestNotifier from a non-authorized module
  // Fatal error on solaris
  @error 
#endif

#undef CATOMYAsyncInterfaces
#undef CATPLMChronos
#undef CATAsyncServices
#undef CATAsyncTasksPlatform_NG
#undef CATAsyncStreamRequests
#undef CATOMYHTTP
#undef CATOMYCommunication
#undef CATPLMxProviderImpl
#undef CATOMYBaseSession
#undef CATOMYCuteIOAccess

#if _MK_MODNAME_ == AuthorizedModuleForCATOmyAsyncRequestNotifier
  #error Declared Module has not been undeclared correctly
  // Fatal error on solaris
  @error 
#endif  

#undef AuthorizedModuleForCATOmyAsyncRequestNotifier
//-----------------------------------------------------------------------------

#include "CATOmxEvent.h"
#include "CATOmxOHMap.h"
#include "CATOmyAsyncInterfaces.h"


/**
 * Available events.
 */
#define CATOmyAsyncRequest_START  1
#define CATOmyAsyncRequest_UPDATE 2
#define CATOmyAsyncRequest_END    3


//-----------------------------------------------------------------------
/**
 * Static class to notify async request status.
 * Use the macros below to send the notification.
 * Use the 'source' member to register your listener (cf. CATOmxEvent doc).
 */
class ExportedByCATOmyAsyncInterfaces CATOmyAsyncRequestNotifier
{
public:
  /**
   * Available request types.
   * @param requestType_MCS The requests to MCS.
   * @param requestType_FCS The requests to FCS.
   */
  enum RequestType
  {
    requestType_MCS,
    requestType_FCS
  };

  /**
   * ID type for the requests.
   */
  typedef CATLONG64 RequestID;

  /**
   * Type for the date and time.
   */
  typedef CATLONG64 DateTime;

  /**
   * @return The singleton instance (create it if needed).
   */
  static CATOmyAsyncRequestNotifier & get();

  /**
   * Builds the context for the START notification.
   * @param iRequestType The type of request that was started.
   * @param iRequestId The ID of the request.
   * @param iStartDate The start date of the request.
   * @return The context.
   */
  static CATOmxAny BuildStartContext(RequestType iRequestType, RequestID iRequestId, DateTime iStartDate);

  /**
   * Builds the context for the UPDATE notification.
   * @param iRequestType The type of request the data update applies to.
   * @param iWrittenBytes The written data size.
   * @param iReadBytes The read data size.
   * @return The context.
   */
  static CATOmxAny BuildUpdateContext(RequestType iRequestType, int iWrittenBytes, int iReadBytes);
  
  /**
   * Builds the context for the END notification.
   * This notification is standalone and DOES NOT require a START notification 
   * to be sent beforehand.
   * @param iRequestType The type of the request the data applies to.
   * @param iStartDate The date the request started.
   * @param iEndDate The date the request ended.
   * @param iWrittenBytes The written data size.
   * @param iReadBytes The read data size.
   * @return The context.
   */
  static CATOmxAny BuildEndContext(RequestType iRequestType, DateTime iStartDate, DateTime iEndDate, int iWrittenBytes = 0, int iReadBytes = 0);

  /**
   * Builds the context for the END notification.
   * The request type and start date are retrieved based on the request ID.
   * This notification requires that the request is registered by a START 
   * notification beforehand.
   * @param iRequestId The ID of the request.
   * @param iEndDate The date the request ended.
   * @param iWrittenBytes The written data size.
   * @param iReadBytes The read data size.
   * @return The context.
   */
  static CATOmxAny BuildEndContext(RequestID iRequestId, DateTime iEndDate, int iWrittenBytes = 0, int iReadBytes = 0);

  /**
   * Builds a timestamp in the right format for the notifications.
   * You may use BUILD_CATOmyAsyncRequest_TIMESTAMP instead if you need the 
   * current time for other operations as well.
   * @return The number of milliseconds from 1970/01/01.
   */
  static DateTime GetCurrentDateTimeUTC();

  ///**
  // * Stores the start time for a request.
  // * @param iRequestId The request ID.
  // * @param iStartTime The start time.
  // * @return S_OK if success, or E_* if a start time is already stored for this 
  // *  request.
  // */
  //HRESULT StoreRequestStartTime(unsigned iRequestId, CATLONG64 iStartTime);

  ///**
  // * Retrieves the start time for a request.
  // * @param iRequestId The request ID.
  // * @param oStartTime The start time.
  // * @return S_OK if success, or E_* if the request ID is unknown or it failed.
  // */
  //HRESULT PopRequestStartTime(unsigned iRequestId, CATLONG64 & oStartTime);

  /**
   * Adds a listener.
   * @param iListen The listener to add.
   */
  void AddListener(CATOmxEventListener & iListen);

  /**
   * Removes a listener.
   * @param iListen The listener to remove.
   */
  void RemoveListener(CATOmxEventListener & iListen);

  /**
   * Source used for the events.
   */
  //CATOmxEventSource & source1;
  CATOmxEventSource* source();

private:
  CATOmyAsyncRequestNotifier();
  ~CATOmyAsyncRequestNotifier();
  CATOmyAsyncRequestNotifier(CATOmyAsyncRequestNotifier &);
  CATOmyAsyncRequestNotifier & operator=(CATOmyAsyncRequestNotifier &);

  /**
   * Returns the source. It is created if it does not exist yet.
   * @return The source.
   */
  CATOmxEventSource* GetOrCreateSource() const;

};

//-----------------------------------------------------------------------

/**
 * Builds a timestamp from what is returned by CATGetCurrentTime.
 * Use it only if you need the current time for other operations as well.
 * Otherwise use CATOmyAsyncRequestNotifier::GetCurrentDateTimeUTC() instead.
 * @param iSecondsSinceEpoch Number of seconds since 1970/01/01.
 * @param iAdditionalMicroseconds Number of microseconds to add.
 */
#define BUILD_CATOmyAsyncRequest_TIMESTAMP(iSecondsSinceEpoch, iAdditionalMicroseconds) \
  (((CATLONG64)(iSecondsSinceEpoch))*1000 + (iAdditionalMicroseconds)/1000)

/**
 * Convenience macro to notify the start of a request.
 * @param iRequestType The request type.
 */
#define EMIT_CATOmyAsyncRequest_START(iRequestType, iRequestId, iStartDate)   \
  CATOmxEventSource* source = CATOmyAsyncRequestNotifier::get().source();     \
  if(source){                                                                  \
    OMX_EMIT(*source,                          \
           CATOmyAsyncRequest_START,                                          \
           .add(CATOmyAsyncRequestNotifier::BuildStartContext(iRequestType, iRequestId, iStartDate)))}

/**
 * Convenience macro to notify the update of a request.
 * @param iRequestType The request type.
 * @param iWrittenBytes The written data size.
 * @param iReadBytes The read data size.
 */
#define EMIT_CATOmyAsyncRequest_UPDATE(iRequestType, iWrittenBytes, iReadBytes)\
  CATOmxEventSource* source = CATOmyAsyncRequestNotifier::get().source();     \
  if(source){                                                                  \
    OMX_EMIT(*source,                           \
           CATOmyAsyncRequest_UPDATE,                                          \
           .add(CATOmyAsyncRequestNotifier::BuildUpdateContext(iRequestType, iWrittenBytes, iReadBytes)))}

/**
 * Convenience macro to notify the end of a request.
 * 
 * 1) In the case of a standalone notification:
 *  @param iRequestType The request type.
 *  @param iStartDate The date the request started.
 *  @param iEndDate The date the request ended.
 *  @param iWrittenBytes The written data size.
 *  @param iReadBytes The read data size.
 *  
 * 2) In the case of an end notification closing a start notification:
 *  @param iRequestId The ID of the request.
 *  @param iEndDate The date the request ended.
 *  @param iWrittenBytes The written data size.
 *  @param iReadBytes The read data size.
 * 
 */
#define EMIT_CATOmyAsyncRequest_END(...)                                      \
  CATOmxEventSource* source = CATOmyAsyncRequestNotifier::get().source();     \
  if(source){                                                                  \
    OMX_EMIT(*source,                          \
           CATOmyAsyncRequest_END,                                            \
           .add(CATOmyAsyncRequestNotifier::BuildEndContext(__VA_ARGS__)))}

#endif
