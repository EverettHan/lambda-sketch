//===================================================================
// COPYRIGHT Dassault Systemes 2017/09/26
//===================================================================
// CATA5CsvRow.cpp
// Header definition of class CATA5CsvRow
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2017/09/26 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATA5CsvRow_H
#define CATA5CsvRow_H

#include "CATA5ParserExport.h"

#include "CATOmxTextStream.h"
#include "CATOmxKeyString.h"
#include "CATOmxArray.h"
#include "CATOmxAny.h"
#include "CATOmxKeyValueBlock.h"
#include "CATOmxSharable.h"
#include "CATOmxSQList.h"
#include "CATOmxSR.h"
#include "CATOmxOMap.h"
#include "CATOmxMapIter.h"

#include "CATA5CsvRowDefinition.h"
#include "CATA5TclNode.h"
#include "CATA5AbstractProcessor.h"
#include "CATA5AttrNoDfltAbstractProcessor.h"
#include "CATOMYCollections.h"

class CATA5RecordBuilderHelper;

namespace CATA5
{
  class CsvContext;

  /*
  * A chunk of CsvRow stored in a CATOmxSQList thread-safe collection
  */
  const int CsvRowChunkSize = 256;
  #pragma warning(disable : 4275) // disable warning C4275: non dll-interface class 'CATOmxSQList<Data,Size>::Node' used as base for dll-interface class 'CATA5::CsvRowChunk'
  class ExportedByCATA5Parser CsvRowChunk : public CATOmxSQList<CATOmxSR<CsvRow>, CsvRowChunkSize>::Node
  {
  public:
    CsvRowChunk();
    virtual ~CsvRowChunk();
  };
  #pragma warning(default : 4275)

  /*
  * This thread-safe (concurrent) queue stores CsvRow in buckets of size CsvRowChunkSize.
  */
  typedef CATOmxSQList< CATOmxSR<CsvRow>, CsvRowChunkSize> CsvRowQueue;

  /**
  * A processed TCL row.
  */
  class ExportedByCATA5Parser CsvRow : public CATOmxSharable
  {
  public:
    CsvRow(CsvRowDefinition* ipDefinition);
    ~CsvRow();

    void DumpRow(CATOmxTextStream& iStream, CATBoolean iWithDefinition = TRUE, const char* iSeparator = "| ") const;

    /*
    * Call this when you finished to build the CsvRow.
    */
    HRESULT Finish();

    /*
    * Create next field.
    * Used by TclParser.
    */
    HRESULT NextField(TclNode &toMap, CsvContext &iContext);

    /*
    * Create next field.
    * Used by JsonParser.
    */
    HRESULT NextField(CATOmxAny& iValue, CsvContext& iCsvContext, CsvRowDefinition& iCsvRowDefinition, const FieldDescription& iFieldDescription);

    /**
    * Returns the row physical id.
    *
    * @param oPhysicalId
    *   The returned physical id. May be empty.
    *
    * @return
    *   S_OK: the physical id is valuated (ie. returned by the server)
    *   E_FAIL: the physical id is empty (ie. not selected during the query)
    */
    HRESULT GetPhysicalId(CATOmxAny& oPhysicalId) const;

    /*
    * Sets the row's physical id.
    */
    void SetPhysicalId(CATOmxAny& iPhysicalId);

    /*
    * Adds a processed data on the row, with his corresponding processor.
    */
    HRESULT AddProcessedData(CATA5AbstractProcessor* ipProcessor, const CATOmxAny& iProcessedData);

    /*
    * Adds a processed data on the row, with his corresponding processor.
    */
    HRESULT AddProcessedData(CATA5AttrNoDfltAbstractProcessor* ipProcessor, const CATOMYPairAnyToBool& iProcessedData);

    /*
    * Returns the processed data iterator.
    */
    CATOmxMapIter<CATA5AbstractProcessor*, CATOmxAny> GetProcessedDataIterator() const;

    /*
    * Returns the processed data for the given processor id.
    * If the row has multiple processors with the same id (example: multiple PLMID processors or different recordReadTargetId),
    * the first data encountered is returned.
    * Check the returned HR for more information on the returned data.
    *
    * @return
    *   S_OK: the processed data returned
    *   S_FALSE: more than one processor for the given id. Data may be wrong.
    *   E_FAIL: no processed data for the given processor id.
    */
    HRESULT GetProcessedData(int iProcessorId, CATOmxAny& oData) const;

    /*
    * Returns the processed data for the given processor id, processor subid and recordReadTargetId.
    *
    * @return
    *   S_OK: the processed data returned
    *   E_FAIL: no processed data for the given processor id, processor subid and recordReadTargetId.
    */
    HRESULT GetProcessedData(int iProcessorId, int iProcessorSubId, int iClassification, CATOmxAny& oData) const;

    /*
    * Returns the processed data for the given processor.
    *
    * @return
    *   S_OK: the processed data returned.
    *   E_FAIL: no processed data for the given processor.
    */
    HRESULT GetProcessedData(CATA5AbstractProcessor* ipProcessor, CATOmxAny& oData) const;

    HRESULT GetProcessedData(CATA5AttrNoDfltAbstractProcessor* ipProcessor, CATOMYPairAnyToBool& oData) const;

    /*
    * Adds an error for the given processor.
    */
    void AddProcessingError(CATA5AbstractProcessor* ipProcessor, CATOmxAny& iError);

    /*
    * Returns true if there is an error generated by the given processor.
    *   The error is returned in oError.
    * Returns false otherwise.
    */
    bool HasProcessingError(CATA5AbstractProcessor* ipProcessor, CATOmxAny& oError) const;

    void AddProcessingError(CATA5AttrNoDfltAbstractProcessor* ipProcessor, CATOmxAny& iError);

    bool HasProcessingError(CATA5AttrNoDfltAbstractProcessor* ipProcessor, CATOmxAny& oError) const;

    /*
    * Returns the expected kvb's size according to the row's definition.
    */
    int GetExpectedKeyValueBlockSize() const;

    /*
    * Returns the expected data's size according to the row's definition.
    */
    int GetExpectedDataSize() const;

    /*
    * Returns the row's csv tag.
    * See CsvRowDefinition::_csv_tag
    */
    CATOmxKeyString GetCsvTag() const;

    /*
    * Returns the row's csv tag's type.
    * See CsvRowDefinition::_csv_tagType
    */
    CATOmxKeyString GetCsvTagType() const;

    // Public attributes
    HRESULT status; // the row status.
    unsigned int flags;
    CATOmxKeyValueBlock kvb; // map of projected items (according to prototype)
    CATOmxArray<CATOmxAny> data; // the row data
    CATOmxAny error; // array of error description [ { "error": , "input": , "column" } ]

  private:
    HRESULT _PostFailure(const char* iError, HRESULT iRC, const CATOmxKeyString& iAttributeName, int iColumn, TclNode& iNode);
    HRESULT _PostFailure(const char* iError, HRESULT iRC, const CATOmxKeyString& iAttributeName, int iColumn, CATOmxAny& iValue);

    /*
    * Returns true if the iTarget's type is valid:
    *   iTarget is equal to expected type (in given field description).
    *   iValue is empty (may lead to omx_void type. See: CATA5::CsvContext::_BuildEmptyTarget).
    *   iFieldDescription's type is omx_void or omx_attribute
    */
    bool _CheckFieldType(CATOmxAny& iValue, CATOmxAny& iTarget, const FieldDescription& iFieldDescription);

    /*
    * Processed data by processors.
    * The map stores Processor -> Processed Data.
    * Filled during Finish()
    */
    CATOMYA5AbstractProcessorToAny _ProcessedData;

    /*
    * Errors generated during data processing.
    * Empty entry for a processor means there is no error.
    */
    CATOMYA5AbstractProcessorToAny _ProcessorsErrors;

    CATOMYA5AttrNoDfltAbstractProcessorToPairAnyToBool _AttrProcessedData;

    CATOMYA5AttrNoDfltAbstractProcessorToAny _AttrProcessorsErrors;

    /*
    * The object physicalid, may be empty. Use Kind() == omx_uuid to check if not empty.
    * The physicalid is set by TCL processors (see: CATA5AbstractTCLProcessor_TS).
    * It is only valuated if one of the following processor has been added:
    *     - AttributeProcessor(_PHYID / _PhysicalIdIndex)
    *     - PLMIDProcessor(_PLMID)
    *     - SR/PT processor (physical id is retrieved with SR/PT owner)
    */
    CATOmxAny _PhysicalId;

    CATOmxSR<CsvRowDefinition> _spDefinition; // the row definition (according to prototype)

    // Friends
    friend class ::CATA5RecordBuilderHelper; // This is due to an architecture issue between ObjectModelerSystem and CATPLMImplAdapterQL (CME4 idea: create an abstract class for CATA5AbstractRecordBuilder, with template (for type of data built, here Record))
  };
}

#endif
