//===================================================================
// COPYRIGHT DS SolidWorks 2010/09/17
//===================================================================
// SWXUtMap.h
// Definition of SWXUtMap
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/09/17 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUTMAP_H
#define SWXUTMAP_H

#include "SWXUtTree.h"

template<class KEYTYPE, class VALUETYPE, class KEY_COMPARE =  SWXUtLess<KEYTYPE> > class SWXUtMap : public SWXUtTree<SWXUtPair<const KEYTYPE, VALUETYPE>, KEY_COMPARE>
{
public:
    typedef KEYTYPE KeyType_t;
    typedef VALUETYPE MappedType_t;
    typedef KEY_COMPARE KeyCompare_t;
    typedef SWXUtPair<const KeyType_t, MappedType_t> ValueType_t;

	typedef typename SWXUtTree<ValueType_t, KeyCompare_t>::ConstIterator ConstIterator;

private:
    typedef SWXUtTree<ValueType_t, KeyCompare_t> Tree_t;
	typedef typename Tree_t::ValueType_t TreeValueType_t;

public:
	SWXUtMap() :
      Tree_t(&CompareKeys)
	{
	}

    SWXUtMap(const SWXUtMap& iMap) :
        Tree_t(&iMap.CompareKeys)
	{
        for (ConstIterator iter = iMap.Begin();iter != iMap.End();iter++)
        {
            this->Insert(*iter);
        }
	}

    SWXUtMap& operator=(const SWXUtMap& iRight)
    {
        if (this != &iRight)
        {
            Tree_t::operator=(iRight);
        }

        return *this;
    }

	MappedType_t& operator[](const KeyType_t& iKeyVal)
	{
        TreeValueType_t tempVal = TreeValueType_t(iKeyVal, MappedType_t());
		TreeValueType_t* v = (TreeValueType_t*)this->mTree.LookForItem(&tempVal);

		if (v != NULL)
		{
			return v->second;
		}
		else
		{
	        TreeValueType_t *temp = new TreeValueType_t(iKeyVal, MappedType_t());

			this->mTree.InsertItem(temp);

			return temp->second;
		}
	}

	typename Tree_t::Iterator Find(const KeyType_t& iKeyVal) 
	{
		SWXUtAvlTreeCursor findCursor(this->mTree);

		Find(iKeyVal, findCursor);

		return typename Tree_t::Iterator(findCursor, this);
	}

	typename Tree_t::ConstIterator Find(const KeyType_t& iKeyVal) const
	{	
		SWXUtAvlTreeCursor findCursor(this->mTree);

		Find(iKeyVal, findCursor);

		return typename Tree_t::ConstIterator(findCursor, this);
	}

    typename Tree_t::Iterator LowerBound(const KeyType_t& iKeyVal) 
	{
		SWXUtAvlTreeCursor findCursor(this->mTree);

		LowerBound(iKeyVal, findCursor);

		return typename Tree_t::Iterator(findCursor, this);
	}

	typename Tree_t::ConstIterator LowerBound(const KeyType_t& iKeyVal) const
	{	
		SWXUtAvlTreeCursor findCursor(this->mTree);

		LowerBound(iKeyVal, findCursor);

		return typename Tree_t::ConstIterator(findCursor, this);
	}

    typename Tree_t::Iterator UpperBound(const KeyType_t& iKeyVal) 
	{
		SWXUtAvlTreeCursor findCursor(this->mTree);

		UpperBound(iKeyVal, findCursor);

		return typename Tree_t::Iterator(findCursor, this);
	}

	typename Tree_t::ConstIterator UpperBound(const KeyType_t& iKeyVal) const
	{	
		SWXUtAvlTreeCursor findCursor(this->mTree);

		UpperBound(iKeyVal, findCursor);

		return typename Tree_t::ConstIterator(findCursor, this);
	}

    size_t Count(const  KeyType_t& iKeyVal) const
	{
        typename Tree_t::ConstIterator findIter = Find(iKeyVal);

        if (findIter == this->End())
        {
            return 0;
        }
        else
        {
            return 1;
        }
	}

    size_t Erase(const KeyType_t& iKeyVal)
	{
        typename Tree_t::ConstIterator findIter = Find(iKeyVal);

		if (findIter != this->End())
		{
			this->RemoveItem((void*)findIter.Item());

			return 1;
		}

		return 0 ;
	}

	void Erase(typename Tree_t::Iterator iIter)
	{
        if (iIter != this->End())
        {
		    this->RemoveItem((void*)iIter.Item());
        }
	}

	void Erase(typename Tree_t::Iterator iFirst, typename Tree_t::Iterator iLast)
	{
		while (iFirst != iLast)
		{
			void* v = (void*)iFirst.Item();

			iFirst++;

		    this->RemoveItem(v);
		}
	}


	const MappedType_t& GetValue(const KeyType_t& iKeyVal,  const MappedType_t& iDefaultVal) 
	{       		
		typename Tree_t::ConstIterator findIter = Find(iKeyVal);

		if (findIter != this->End())
			return findIter->second;
		
		return iDefaultVal;	
		
	} 


	bool KeyExists(const KeyType_t& iKeyVal)
	{        
		return !(Count(iKeyVal) == 0);
	}


protected:
    virtual void Find(const KeyType_t& iKeyVal, SWXUtAvlTreeCursor& iFindCursor) const
	{
		typename Tree_t::ValueType_t temp(iKeyVal, MappedType_t());

		iFindCursor.ResetOnItem(&temp);
	}

    virtual void LowerBound(const KeyType_t& iKeyVal, SWXUtAvlTreeCursor& iFindCursor) const
	{
        typename Tree_t::ValueType_t temp(iKeyVal, MappedType_t());

        iFindCursor.ResetOnNode(this->mTree.LowerBound(&temp));
	}

    virtual void UpperBound(const KeyType_t& iKeyVal, SWXUtAvlTreeCursor& iFindCursor) const
	{
        typename Tree_t::ValueType_t temp(iKeyVal, MappedType_t());

        iFindCursor.ResetOnNode(this->mTree.UpperBound(&temp));
	}

	static int CompareKeys(const void* iLeft, const void* iRight)
	{
		const TreeValueType_t* leftPair = (const TreeValueType_t *)iLeft;
		const TreeValueType_t* rightPair = (const TreeValueType_t *)iRight;

		if (KeyCompare_t()(leftPair->first, rightPair->first))
		{
			return -1;
		}
		else
		{
			if (KeyCompare_t()(rightPair->first, leftPair->first))
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}
};

#endif
