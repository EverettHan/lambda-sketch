// COPYRIGHT DASSAULT SYSTEMES 2006, ALL RIGHTS RESERVED.
//===================================================================
//
// CATPolyGeodesicIntersector.h
//
//===================================================================
// December 2006  Creation: Code generated by the CAA wizard  ndo
//===================================================================
#ifndef CATPolyGeodesicIntersector_H
#define CATPolyGeodesicIntersector_H

#include "PolyMathIntersectors.h"
#include "CATBoolean.h"
#include "CATErrorDef.h"
#include "CATPolyIntersection.h"
#include "CATPolyTriangleIntersector.h"

class CATMathPoint;
class CATPolyExactArithmetic;
class CATPolyIntersectionPoint;


/**
 * This class tests two geodesics defined on the surface of a sphere of given center for intersection.
 * A geodesic is the shortest arc on the sphere between the two points.  T
 * There are an infinite number of geodesics between two points that are diametrically opposite
 * (two opposite points result in an ill-defined geodesic).
 * Except for the center of the sphere, any point in space can be associated to a unique point on the surface
 * of the sphere by a radial projection.  For any two points distinct from the center of the sphere,
 * the geodesic is defined between their radial projections on the sphere unless the two points are 
 * radially aligned and opposite sides of the center. 
 *
 * Two points and the origin define a triangle and a triangular sector starting from the origin.
 * Unless a triangle is degenerate, the radial projections of its corner points cannot be radially aligned.
 *
 * @see CATPoly
 * @see CATPolyIntersection
 */
class ExportedByPolyMathIntersectors CATPolyGeodesicIntersector
{

public:

  /**
   * Constructor.
   * @param iExactArithmetic
   *   An instance of exact arithmetic.
   * @param iOrigin
   *   The center of sphere on which the geodesics are defined.
   */
  CATPolyGeodesicIntersector (const CATPolyExactArithmetic& iExactArithmetic,
                                     const CATMathPoint& iOrigin);
  ~CATPolyGeodesicIntersector ();

public:

  /**
   * Tests whether two geodesic segments, each defined by a pair of points, 
   * intersect or not on the surface of a sphere.  The points don't need to be explicitely on the surface 
   * of the sphere but they need to be distinct from its center.
   * A geodesic segment is the smallest arc of a great circle on the sphere between the two points.
   * (More precisely between the intersections of the radial lines going through the points and the sphere.)
   * The method returns an enum that describes the type of the intersection.
   * If there is an intersection between the two segments, a symbolic description of the intersection
   * can be obtained using the GetEntityType () method.
   * @param A
   *   The start point of Segment 0.
   * @param B
   *   The end point of Segment 0.
   * @param C
   *   The start point of Segment 1.
   * @param D
   *   The end point of Segment 1.
   * @return
   *   An integer describing the type of the intersection between the segments.
   *   See CATPolyIntersection::IntersectionType.
   */
  int Intersect (const CATMathPoint& A, const CATMathPoint& B,
                 const CATMathPoint& C, const CATMathPoint& D);

  /**
  * Returns the type of the intersection point on a segment in the case of a point intersection.
  * If this method is called when the intersection between the two segments is not a point
  * (no intersection or intersection is a geodesic segment), then the method returns CATPoly::eUndefined.
  * @param iSegment
  *   0 or 1, respectively for the first or second segment.
  * @return 
  *   CATPoly::eVertex if the intersection point is an end-point of the segment.
  *   CATPoly::eBar if the intersection point is any other point of the segment.
  *   CATPoly::eUndefined if the intersection between the two segments is not a point intersection.
  */
  inline int GetEntityType (const int iSegment) const;

  /**
   * Returns the index of the intersecting vertex index for one of the two segments (0 or 1).
   */
  inline int GetVertexIndex (const int iSegment) const;

public:

  /**
   * Returns TRUE if the points A and B are points diametrically opposite on the sphere.
   * They cannot define a unique geodesic on the sphere.
   */
  inline CATBoolean AreDiametricallyOpposite (const CATMathPoint& A, const CATMathPoint& B) const;

  /**
   * Returns TRUE if the segments are colinear and FALSE otherwise after running the Intersect () method.
   * @return
   *   TRUE if the segments are colinear and FALSE otherwise.
   */
  inline CATBoolean AreSegmentsColinear () const;

  int Determinant (const CATMathPoint& P, const CATMathPoint& Q, const CATMathPoint& R) const;

  /**
   * Checks if the point C is within the sector A and B given that A, B and C are on the same geodesic line.
   */
  CATBoolean IsPointWithinSector (const CATMathPoint& A, const CATMathPoint& B, const CATMathPoint& C) const;

private:

  CATPolyTriangleIntersector _Intersector;

  const CATPolyExactArithmetic& _ExactArithmetic;
  const CATMathPoint& _Origin;

  CATBoolean _Colinear;
  int _IntersectionType; // Type of the intersection between the two segments.
  int _EntityType[2];    // Type of the intersection point, respectively on Segments 0 and 1.
  int _VertexIndex[2];   // The index of the vertex (0 or 1) when the intersection is an end point
                         // for the two segments.

private:

  // Check whether two points and the origin are colinear.
  CATBoolean ArePointsAndOriginColinear (const CATMathPoint& A, const CATMathPoint& B) const;

  // Check whether two colinear points are symmetric w.r.t. the origin.
  CATBoolean ArePointsOnOppositeSides (const CATMathPoint& A, const CATMathPoint& B) const;

  void Update (const CATPolyIntersectionPoint& I);

};


inline int CATPolyGeodesicIntersector::GetEntityType (const int iSegment) const
{
  return (iSegment == 0 || iSegment == 1) ? _EntityType[iSegment] : -1;
}


inline int CATPolyGeodesicIntersector::GetVertexIndex (const int iSegment) const
{
  return (iSegment == 0 || iSegment == 1) ? _VertexIndex[iSegment] : -1;
}


inline CATBoolean CATPolyGeodesicIntersector::AreSegmentsColinear () const
{
  return _Colinear;
}


inline CATBoolean CATPolyGeodesicIntersector::AreDiametricallyOpposite (const CATMathPoint& A, const CATMathPoint& B) const
{
  return ArePointsAndOriginColinear (A, B) && ArePointsOnOppositeSides (A, B) ? TRUE : FALSE;
}

#endif

