//===================================================================
// COPYRIGHT DS SolidWorks 2010/09/17
//===================================================================
// SWXUtMap.h
// Definition of SWXUtMap
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/09/17 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUTSET_H
#define SWXUTSET_H

#include "SWXUtTree.h"

template<class KEYTYPE, class KEY_COMPARE =  SWXUtLess<KEYTYPE> > class SWXUtSet : public SWXUtTree<KEYTYPE, KEY_COMPARE>
{
public:
    typedef KEYTYPE KeyType_t;
    typedef KEYTYPE ValueType_t;
    typedef KEY_COMPARE KeyCompare_t;

private:
    typedef SWXUtTree<KeyType_t, KeyCompare_t> Tree_t;

public:
	SWXUtSet() :
      Tree_t(&CompareKeys)
	{
	}

    SWXUtSet(const SWXUtSet& iMap) :
        Tree_t(&CompareKeys)
	{
        for (typename Tree_t::ConstIterator iter = iMap.Begin();iter != iMap.End();iter++)
        {
            this->Insert(*iter);
        }
	}

    SWXUtSet& operator=(const SWXUtSet& iRight)
    {
        Tree_t::operator=(iRight);

        return *this;
    }

	typename Tree_t::Iterator Find(const KeyType_t& iKeyVal) 
	{
		SWXUtAvlTreeCursor findCursor(this->mTree);

		Find(iKeyVal, findCursor);

		return typename Tree_t::Iterator(findCursor, this);
	}

	typename Tree_t::ConstIterator Find(const KeyType_t& iKeyVal) const
	{	
		SWXUtAvlTreeCursor findCursor(this->mTree);

		Find(iKeyVal, findCursor);

		return typename Tree_t::ConstIterator(findCursor, this);
	}

    typename Tree_t::Iterator LowerBound(const KeyType_t& iKeyVal) 
	{
		SWXUtAvlTreeCursor findCursor(this->mTree);

		LowerBound(iKeyVal, findCursor);

		return typename Tree_t::Iterator(findCursor, this);
	}

	typename Tree_t::ConstIterator LowerBound(const KeyType_t& iKeyVal) const
	{	
		SWXUtAvlTreeCursor findCursor(this->mTree);

		LowerBound(iKeyVal, findCursor);

		return typename Tree_t::ConstIterator(findCursor, this);
	}

    typename Tree_t::Iterator UpperBound(const KeyType_t& iKeyVal) 
	{
		SWXUtAvlTreeCursor findCursor(this->mTree);

		UpperBound(iKeyVal, findCursor);

		return typename Tree_t::Iterator(findCursor, this);
	}

	typename Tree_t::ConstIterator UpperBound(const KeyType_t& iKeyVal) const
	{	
		SWXUtAvlTreeCursor findCursor(this->mTree);

		UpperBound(iKeyVal, findCursor);

		return typename Tree_t::ConstIterator(findCursor, this);
	}

    size_t Count(const  KeyType_t& iKeyVal) const
	{
        typename Tree_t::ConstIterator findIter = Find(iKeyVal);

        if (findIter == this->End())
        {
            return 0;
        }
        else
        {
            return 1;
        }
	}

	size_t Erase(const KeyType_t& iKeyVal)
	{
        typename Tree_t::ConstIterator findIter = Find(iKeyVal);

		if (findIter != this->End())
		{
			this->RemoveItem((void*)findIter.Item());

			return 1;
		}

		return 0 ;
	}

	void Erase(typename Tree_t::Iterator iIter)
	{
        if (iIter != this->End())
        {
		    this->RemoveItem((void*)iIter.Item());
        }
	}

	void Erase(typename Tree_t::Iterator iFirst, typename Tree_t::Iterator iLast)
	{
		while (iFirst != iLast)
		{
			void* v = (void*)iFirst.Item();

			iFirst++;

		    this->RemoveItem(v);
		}
	}

protected:
    virtual void Find(const KeyType_t& iKeyVal, SWXUtAvlTreeCursor& iFindCursor) const
	{
		iFindCursor.ResetOnItem((void*)&iKeyVal);
	}

    virtual void LowerBound(const KeyType_t& iKeyVal, SWXUtAvlTreeCursor& iFindCursor) const
	{
        iFindCursor.ResetOnNode(this->mTree.LowerBound((void*)&iKeyVal));
	}

    virtual void UpperBound(const KeyType_t& iKeyVal, SWXUtAvlTreeCursor& iFindCursor) const
	{
        iFindCursor.ResetOnNode(this->mTree.UpperBound((void*)&iKeyVal));
	}

	static int CompareKeys(const void* iLeft, const void* iRight)
	{
        KeyType_t left = *(KeyType_t *)iLeft;
        KeyType_t right = *(KeyType_t *)iRight;

		if (KeyCompare_t()(left, right))
		{
			return -1;
		}
		else
		{
			if (KeyCompare_t()(right, left))
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}
};

#endif
