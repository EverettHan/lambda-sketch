//===================================================================
// COPYRIGHT Dassault Systemes 2021/03/29
//===================================================================
// CATIVariabilityExposition.cpp
// Header definition of class CATIVariabilityExposition
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2021/03/29 Creation: Code generated by the 3DS wizard
//===================================================================
#ifndef CATIVariabilityExposition_H
#define CATIVariabilityExposition_H

#include "CATBaseUnknown.h"
#include "CATListOfCATUnicodeString.h"
#include "KnowledgeItf.h"
#include "CATListValCATAttributeInfos.h"
#include "CATUnicodeString.h"
#include "CATSysBoolean.h"

class CATIVariabilityExposition_var;

/**
* This interface is dedicated to declaration, navigation, introspection, and possibly modification of input and output variables
* for objects that can't expose regular "knowledgeware" parameters (literal values persisted in representation streams)
* A variable is at the end provided as a volatile literal value (implementing CATICkeParm, CATIValue)
*
* The principle of exposition is a tree navigation
* An object implemented CATIVariabilityExposition. It can have children that also implement CATIVariabilityExposition
* It provides those children based on attributes declaration.
* It also can hold variables. It also provides those variables based on attributes declaration
*
* For children, the important informations are
* attribute key
* NLS translation of the key
* CATIIcon implementation
*
* For variables, the important informations are
* attribute key
* NLS translation of the key
* type (the variable value should be a volatile parameter of this type)
* read-write or read-only status (depending on this, the variable will be seen as an input or an output)
*
* Note that it's important to ensure that keys are constant information and that trees are stable :
* Some persistent model will reference the variables by storing link to
* persistent object implementing CATIVariabilityExposition and list of attribute keys to navigate from
* this object to wanted variable
*/



extern ExportedByKnowledgeItf  IID IID_CATIVariabilityExposition;

class ExportedByKnowledgeItf CATIVariabilityExposition : public CATBaseUnknown
{
  CATDeclareInterface;

public:

  /**
  * returns true if this object can be pointed
  */
  virtual CATBoolean IsPersistent() = 0;

  /**
  * Returns string for delegation process.
  * Some variable providers don't have any object in the session that they can use
  * to expose the variables. For example mass computation for a product. The product modeler
  * shouldn't have to know that another team provides mass computation.
  * So the product team will maybe not itself return any variable but it will call the adapter that will
  * look for variable providers.
  * This is based on declarative files : the adapter will look for files in the runtime view
  * <StringForDelegation>_ExpositionDelegation<anything>.CATRsc
  * The CATRsc file should contain : Implementation=<latetype>.
  * the latetype must implement CATIVariabilityExpositionDelegation
  */
  virtual CATUnicodeString GetStringForDelegation() = 0;

  /**
  * Returns the owner of the object. NULL for roots.
  * Returned object must itself implement CATIVariabilityExposition
  */
  virtual CATBaseUnknown_var GetOwner() = 0;


  /**
  * Returns the list of attributes defining of children that themselves expose some chilren and variables
  * For each of the attributes, the call of GetChild with the attribute name should return a valid object
  */
  virtual HRESULT GetChildrenAttributes(CATListValCATAttributeInfos &oAttributes) = 0;

  /**
  * Returns the list of attributes of variables exposed by this object
  * For each of the attributes, the call of GetVariableValue with the attribute name should return a literal value implemented as a volatile parameter
  */
  virtual HRESULT GetVariableAttributes(CATListValCATAttributeInfos &oAttributes) = 0;

  /**
  * Returns a child based on its attribute key
  */
  virtual HRESULT GetChild(const CATUnicodeString &iKey, CATIVariabilityExposition_var &oExposition) = 0;

  /**
  * Returns a variable value based on its attribute key
  */
  virtual HRESULT GetVariableValue(const CATUnicodeString &iKey, CATICkeParm_var &oValue) = 0;

  /**
  * Sets a variable value. The type of the passed parameters should be compliant with the type of
  * the attribute declared in CATAttributeInfos.
  * The method shouldn't be called on attributes that are declared as children and not variables nor on variables
  * declared as read only
  */
  virtual HRESULT SetVariableValue(const CATUnicodeString &iKey, const CATICkeParm_var &iValue) = 0;

  /**
  * Returns a variable value based on an attribute path.
  * the path should contain a list of attribute keys navigating the children structure and the attribute that
  * is a variable of the last child
  * (for example childKey1 childKey2 (of childKey1 child) variableKey (if childKey2 child)
  */
  virtual HRESULT GetVariableValueFromPath(const CATListOfCATUnicodeString &iPath, CATICkeParm_var &oValue) = 0;

  /**
  * Sets a variable value based on an attribute path.
  * the path should contain a list of attribute keys navigating the children structure and the attribute that
  * is a variable of the last child
  * (for example childKey1 childKey2 (of childKey1 child) variableKey (if childKey2 child)
  * The method shouldn't be called on on variables declared as read only
  */
  virtual HRESULT SetVariableValueFromPath(const CATListOfCATUnicodeString &iPath, const CATICkeParm_var &iValue) = 0;

  /**
  * Optional implementation
  * For complex hierarchies of variables created by modelers, it may be needed to have
  * graphical feedbacks about what a given attribute path represents
  * This method should be called by application showing those variables in a panel (tree display)
  * selecting a node in the tree should call Display(selectionpath, TRUE)
  * and unselecting it should call Display(selectionpath, FALSE).
  * Any selection should be removed when panel is closed
  * Implementation could just implement some cross highlight, or build visualization objects, etc.
  */
  virtual HRESULT Display(const CATListOfCATUnicodeString &keyPath, CATBoolean iValue) = 0;

};

//-----------------------------------------------------------------------
CATDeclareHandler(CATIVariabilityExposition, CATBaseUnknown);


#endif
