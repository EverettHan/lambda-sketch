// COPYRIGHT Dassault Systemes 2005
//===================================================================
//
// CATIParmVariable.h
// Define the CATIParmVariable interface
// Added on some objects implementing CATICkeParm that are variable inside the language
//
//===================================================================
//
// Usage notes:
//   New interface: describe its use here
//
//===================================================================
//
//  Apr 2005  Creation: Code generated by the CAA wizard  FRH
//===================================================================
#ifndef CATIParmVariable_H
#define CATIParmVariable_H

#include "CATLifSpecs.h"
#include "CATBaseUnknown.h"
#include "CATCke.h"

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATLifSpecs IID IID_CATIParmVariable;
#else
extern "C" const IID IID_CATIParmVariable ;
#endif

class CATICkeType_var;

//------------------------------------------------------------------

/**
 * Describe the functionality of your interface here
 * <p>
 * A parameter (that implements CATICkeParm) can be a value and a variable or a variable mainly.
 * For exemple, a literal is a value and it can be passed to an expression becoming a variable.
 * A local variable in the language (let x (Body)) implements also CATICkeParm but is mainly a variable that references a value.
 * 
 * What is the main difference between the two: a local variable is created with a given type (in our example, it is supposed to contain a Body)
 * When we valuate this variable (set x = y), we must verify that y is a kind of Body. 
 * Unfortunately the type of the variable was not available on CATICkeParm. CATICkeParm::Type was returning the type of the value !
 * It meant that if we set x with a Point and then x with a Circle (which is legal) it would fail because it would say
 * that a circle can not be put in a variable of type Point !
 *
 * As a consequence, we introduce a method VariableType that returns the type of the variable. In R15, it will be implemented 
 * only on local variable (CATCkeParmSpec). We may introduce it on CATICkeParm interface
 */
class ExportedByCATLifSpecs CATIParmVariable: public CATBaseUnknown
{
  CATDeclareInterface;   

  public:

    /**
     * Returns the type of the variable (opposed to the type of the value, which is the same in most cases but not all.
     */
	  virtual CATICkeType_var VariableType () const = 0;

	  enum ParameterIdentification { Value, List, Pointer, ValuePointer, ObjectReference, ApplicativeParameter, AttributeNode  };


  	/**
	 * This service returns the identification of a parameter 
	 */
	virtual HRESULT IdentifyParameter (ParameterIdentification &oIdentification) const =0;

   /*
	* A CATICkeParm is a variable in any case (meaning that it can be manipulated as a variable in the Knowledge Language
	* But some are just variables (volatile value, volatile list, volatile pointer, volatile valuePointer) and some are objects 
	* that can be referenced by a relation (literal, new literal, list, pointer, value pointer, and object reference)
	* this method indicates that the parameter is a pure volatile variable (watch out, answers false for an object reference)
	*/
	virtual CATCke::Boolean IsVolatile () const =0;


};


CATDeclareHandler(CATIParmVariable,CATBaseUnknown);

//------------------------------------------------------------------

#endif
