//===================================================================
// COPYRIGHT DS SolidWorks 2010/08/12
//===================================================================
// SWXUtHandlerOut.cpp
// Header definition of class SWXUtHandlerOut
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/08/12 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXUtHandlerOut_H
#define SWXUtHandlerOut_H

#include "SWXUtGeneral.h"
#include "CATBaseUnknown.h"

//-----------------------------------------------------------------------
//
// Intended to SAFELY return handlers through arguments.
// 
// HRESULT SomeFunction(CATBaseUnknown_var &oValue);
// is unsafe--it is possible to quietly pass a CATISomethingElse_var here,
// but since operator= is not virtual the result will not be properly converted
// to a CATISomethingElse. The result will usually be a mysterious crash.
// Instead, one can use
//
// HRESULT SomeFunction(SWXUtHandlerOut &oValue);
//
// and call it like this:
// CATIWhatever_var value;
// HRESULT rc = SomeFunction(value);
// The correct op= will be called.
//
// Perhaps it's better just to return handlers as return values, not as
// output arguments! See SWXHandlerAndResult
//
// The commented-out AssignFn stuff is an alternate method, possibly less
// efficient (it has to create thunks for the pointer-to-template functions),
// but possibly less susceptible to compiler weirdnesses with the op= 
// (e.g. why __stdcall?) ptr-to-member
//
class ExportedBySWXUtGeneral SWXUtHandlerOut
{
	typedef CATBaseUnknown_var& ( __stdcall CATBaseUnknown_var::*Opeq)(const CATBaseUnknown_var &base);
	//typedef void (*AssignFn)(CATBaseUnknown_var &iTo, const CATBaseUnknown_var &iFrom);
	CATBaseUnknown_var *mPtr;
	Opeq mOpeq;
	//AssignFn mAssignFn;
	

public:

	SWXUtHandlerOut() : mPtr(NULL), mOpeq(NULL)
		//, mAssignFn(NULL) 
	{}
	template <typename TVAR>
	SWXUtHandlerOut(TVAR &iPtr) : mPtr(&iPtr), mOpeq(GetOpeq<TVAR>())
		//, mAssignFn(GetAssign<TVAR>()) 
	{}
	template <typename TVAR>
	SWXUtHandlerOut(TVAR *iPtr) : mPtr(iPtr), mOpeq(GetOpeq<TVAR>())
		//, mAssignFn(GetAssign<TVAR>()) 
	{}

	CATBaseUnknown_var operator=(const CATBaseUnknown_var &iRhs) const
	{
		//if(mPtr && mAssignFn)
		//{
		//	mAssignFn(*mPtr, iRhs);
		//}
		if(mPtr && mOpeq)
		{
			(mPtr->*mOpeq)(iRhs);
		}
		return iRhs;
	}

	CATBaseUnknown_var GetHandler() const { return mPtr ? *mPtr : CATBaseUnknown_var(); }

	bool IsValid() const { return mPtr && mOpeq; }

private:
	//template <typename TVAR>
	//static void Assign(CATBaseUnknown_var &iTo, const CATBaseUnknown_var &iFrom)
	//{
	//	TVAR &handler = static_cast<TVAR &>(iTo);
	//	handler = iFrom;
	//}
	//template <typename TVAR>
	//static AssignFn GetAssign()
	//{
	//	return &Assign<TVAR>;
	//}

	template <typename TVAR>
	static Opeq GetOpeq()
	{
		typedef TVAR& (__stdcall TVAR::*Fn)(const CATBaseUnknown_var &base);
		Fn fn = &TVAR::operator=;
		return (Opeq)fn;
	}
};

//-----------------------------------------------------------------------

#endif
