//===================================================================
// COPYRIGHT DASSAULT SYSTEMES 2011/06/13
//===================================================================
// CATSYPDataBlock.h
// Header definition of class CATSYPDataBlock
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2011/06/13 Creation: Code generated by the 3DS wizard  VV6
//===================================================================

#ifndef CATSYPDataBlock_H
#define CATSYPDataBlock_H

#include <IntroInfra.h>
#include <CATSYPIntrospectableAdapter.h>
#include <CATUnicodeString.h>
#include <CATSYPArray.h>
#include <CATSYPMap.h>
#include <CATBaseUnknown.h>
#include <CATSYPEventHandlersSupport.h>
#include <CATSetOfCATUnicodeString.h>
#include <CATCollec.h>

class CATSYPDataBlockFactory;
class CATSYPEvent;
class CATSYPEventArgs;
class CATSYPEventFactory;
/**
 * Container of data which can be filled dynamically with introspectable
 * properties.
 *
 * It's an introspectable object, that is to say an object that implements
 * the CATISYPIntrospectable interface, so it can be used as any other objects
 * of that type (generally created using a sypintro file). However, the main 
 * feature of this class is to be able to create an introspectable class without
 * doing a sypintro file.
 *
 * @par Creation
 * To create a CATSYPDataBlock object, you must use the @ref
 * CATSYPDataBlockFactory class. First, this class lets you define the
 * properties and the event handlers of a CATSYPDataBlock object. Then, this
 * class allows you to create the corresponding CATSYPDataBlock object using
 * the @ref CATSYPDataBlockFactory#CreateDataBlock member function.
 *
 * @par Destruction
 * You are responsible to call Release on a CATSYPDataBlock object created
 * using the CATSYPDataBlockFactory#CreateDataBlock member function.
 *
 * @par Usage
 * Once a CATSYPDataBlock is created, you can modify the value of one of its
 * property by using the @ref SetProperty member function.
 * To read the value of one property, you must used @ref GetProperty.
 * All the properties held inside a CATSYPDataBlock are referenced by their name.
 * However, once a CATSYPDataBlock has been generated using a
 * @ref CATSYPDataBlockFactory, you can't add or remove a property on it: you
 * must create another CATSYPDataBlock object.
 *
 * @par AttachedProperties
 * Attached properties are not defined for a CATSYPDataBlock. So, the member
 * functions @ref CATISYPIntrospectable#SetAttachedProperty and 
 * CATISYPIntrospectable#GetAttachedProperty are not defined on a CATSYPDataBlock
 * object.
 *
 * @par Utility member functions
 * Some utility member functions are defined on CATSYPDataBlock object like
 *   - @ref GetPropertiesList that allows you to retrieve the list of all
 * properties name contained into the datablock object,
 *   - @ref GetPropertiesNumber allows you to retrieve the number of properties
 * held by the datablock object,
 *   - @ref ContainProperty allows you to check whether a given property is
 * held by the datablock object,
 *   - @ref GetPropertyType allows you to get the type of a given property,
 *   - @ref IsReadOnlyProperty indicates whether a property is read only or not.
 *
 * @par CATSYPMetaClass particularity of a CATSYPDataBlock
 * The list of properties held by a CATSYPDataBlock is stored into a
 * CATSYPMetaClass object. Datablock instances share the same SYP meta-class
 * as soon as they have all been created using the same instance of a
 * CATSYPDataBlockFactory and no modifications have been applied on the
 * set of properties defined onto the factory.
 * For example, let's consider the following code snippet:
 * @code
 * #include <CATSYPDataBlock.h>
 * #include <CATSYPDataBlockFactory.h>
 * #include <CATBasicBoxing.h>
 *
 * CATSYPDataBlockFactory dbFactory;
 * dbFactory.AddProperty("Name", "CATUnicodeString", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfCATUnicodeString::Box("Default"));
 *
 * CATSYPDataBlock * pDataBlock = dbFactory.CreateDataBlock();
 *
 * CATSYPDataBlock * pDataBlock2 = dbFactory.CreateDataBlock();
 *
 * // pDataBlock and pDataBlock2 share the same CATSYPMetaClass because no
 * // properties have been added or removed from the factory between their creation.
 *
 * dbFactory.AddProperty("Number", "int", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfint::Box(0));
 *
 * CATSYPDataBlock * pDataBlock3 = dbFactory.CreateDataBlock();
 *
 * // pDataBlock3 has a different CATSYPMetaClass from pDataBlock and pDataBlock2
 * // because a new property has been added onto the factory.
 *
 * dbFactory.RemoveProperty("Number");
 *
 * CATSYPDataBlock * pDataBlock4 = dbFactory.CreateDataBlock();
 *
 * // pDataBlock4 has also a totally different CATSYPMetaClass from pDataBlock,
 * // pDataBlock2 and pDataBlock3 even if this meta-class contains only
 * // one property called Name as for pDataBlock and pDataBlock2.
 * @endcode
 *
 * @par Differences between CATSYPDataBlock and other introspectable objects
 * The CATSYPDataBlock object lets you define an introspectable object with its
 * properties without having to write a sypintro file. As the sypintro file must
 * be written before build time, using a CATSYPDataBlock object, you can create
 * an introspectable object and define its properties at runtime.
 * Thus, you can create introspectable objects dynamically without knowing their
 * properties at build time.
 *
 * @par Emitting an event when the value of a property is modified
 * By default, as soon as the value of a property of the data block is modified
 * using the @ref SetProperty member function, the @ref PropertiesChanged event
 * is emitted by the CATSYPDataBlock object indicating which property has been
 * modified and what is its new value. You can handle this event by listening
 * to it with an event handler.
 *
 * @par
 * To register an event handler, you must call the @ref AddHandler member
 * function specifying the event that will trigger the call to the event
 * handler. The following code snippet show how to listen to the
 * @ref PropertiesChanged event emitted by a CATSYPDataBlock:
 *
 * @par
 * @code
 * #include <CATSYPCheck.h>
 * #include <CATSYPDataBlock.h>
 * #include <CATSYPDataBlockFactory.h>
 * #include <CATSYPPropertiesChangedEventArgs.h>
 * #include <CATSYPStaticEventHandler.h>
 * #include <CATBasicBoxing.h>
 * // The definition of the function used as callback
 * void my_static_callback(CATBaseUnknown * i_pSender, CATSYPPropertiesChangedEventArgs * i_pArgs)
 * {
 *    // its implementation...
 * }
 *
 * CATSYPDataBlockFactory dbFactory;
 *
 * // Register a property description for the Name property
 * dbFactory.AddProperty("Name", "CATUnicodeString", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfCATUnicodeString::Box("Default"));
 *
 * // Create the CATSYPDataBlock object
 * CATSYPDataBlock * pDataBlock = dbFactory.CreateDataBlock();
 * CHECK_POINTER_RET(pDataBlock);
 * CHECK_TRUE(AddCATSYPStaticEventHandler(pDataBlock,
 *                                        CATSYPDataBlock::PropertiesChanged(), 
 *                                        &my_static_callback));
 *
 * // Modify the value of the property called Name
 * // By doing that, the PropertiesChanged event is emitted, and the function
 * // my_static_callback is called with i_pArgs containing the name of the modified
 * // properties and its new value.
 * pDataBlock->SetProperty("Name", CATBoxingOfCATUnicodeString::Box("TheNewValue");
 *
 * pDataBlock->Release();
 * @endcode
 *
 *
 * @par
 * If this behavior is not required for performance issue, you can deactivate this
 * mechanism and only emit an event when the transaction has ended.
 * To disable the emission of events, you can use @ref BeginUpdateTransaction.
 * This member function disable the emission of events until
 * @ref EndUpdateTransaction is called. When EndUpdateTransaction is invoked,
 * the cache mode is deactivated and the data block dispatches the
 * @ref PropertiesChanged event with all the modified properties information
 * since the last call to @ref BeginUpdateTransaction. After
 * @ref EndUpdateTransaction has been called, the cache mode is deactivated,
 * and then, the emission of the @ref PropertiesChanged event restarts each
 * time the value of a property is modified.
 *
 */
class ExportedByIntroInfra CATSYPDataBlock : public CATSYPIntrospectableAdapter
{
  CATDeclareClass;
public:
  /** Destructor */
  virtual ~CATSYPDataBlock ();
  /**
   * Set a value for a property.
   * To succeed, the property must already exist into the CATSYPDataBlock.
   * By passing NULL_var as the second parameter (the property value to set),
   * the value of the property is erased (but the property is still defined
   * into the datablock).
   * The property value is set only if the type of the given property matches
   * the type of the given new value (boxed or not).
   *
   * @copydoc CATSYPIntrospectableAdapter#SetProperty
   */
  virtual void SetProperty(const CATUnicodeString & i_name, const CATBaseUnknown_var & i_spPropertyValue);
  /**
   * Retrieves the value stored for the given property name.
   * If the property doesn't exist or if the property doesn't have
   * a value set, NULL_var is returned.
   *
   * @copydoc CATSYPIntrospectableAdapter#GetProperty
   */
  virtual CATBaseUnknown_var GetProperty(const CATUnicodeString & i_name);
  /**
   * No attached property can be defined on a CATSYPDataBlock.
   * This method always asserts.
   *
   * @copydoc CATSYPIntrospectableAdapter#SetAttachedProperty
   */
  virtual void SetAttachedProperty(const CATBaseUnknown_var & i_index, const CATUnicodeString & i_name, const CATBaseUnknown_var & i_spPropertyValue);
  /**
   * No attached property can be defined on a CATSYPDataBlock.
   * So, this method always asserts and returns NULL_var.
   *
   * @copydoc CATSYPIntrospectableAdapter#GetAttachedProperty
   */
  virtual CATBaseUnknown_var GetAttachedProperty(const CATBaseUnknown_var & i_index, const CATUnicodeString & i_name);
  /**
   * Recovers a list that contains the name of all registered properties.
   * @param o_propertiesList the list to fill with properties names.
   */
  void GetPropertiesList(CATSYPArray<CATUnicodeString> & o_propertiesList) const;
  /**
   * Recovers the number of properties stored into this data block.
   * @return the number of properties stored into the data block (0 if no
   * properties are stored).
   */
  int GetPropertiesNumber() const;
  /**
   * Indicates whether the given property exists or not into the data block.
   * @param i_propertyName the name of the property to look for.
   * @return 0 if the property does not exist for the data block, otherwise 1
   * if it exists.
   */
  int ContainProperty(const CATUnicodeString & i_propertyName) const;
  /**
   * Recovers the type of the given property.
   * @param i_propertyName the name of the property.
   * @return the type of the given property or an empty CATUnicodeString
   * if the property is not valid.
   */
  const CATUnicodeString & GetPropertyType(const CATUnicodeString & i_propertyName) const;
  /**
   * Indicates whether the given property is read-only or not.
   * @param i_propertyName the name of the property.
   * @return 1 if the property is read-only, otherwise, 0 if the property is not
   * read-only, or does not exist, or i_propertyName is empty.
   */
  int IsReadOnlyProperty(const CATUnicodeString & i_propertyName) const;

  /**
   * Get the event factory to use to build datablock's events.
   *
   * This function should be used through the @ref
   * CATImplementSYPEvent macro.
   *
   * @return the event factory. Never @c NULL.
   *
   * @see CATImplementSYPEvent
   */
  static CATSYPEventFactory *GetEventFactory();

  /**
   * Add a handler for a given event.
   *
   * The handlers will be called in the order of their registration.
   *
   * If this function is called during the dispatch of an event, the
   * registered event handler won't be called for this dispatch but
   * will only be called for next dispatches.
   *
   * It is possible to call mutliple times this function with the same
   * event and the same handler instance. In that case there will be
   * multiple registrations; no checks are made for duplication (the
   * caller will have to call @ref #RemoveHandler multiple times).
   *
   * @param i_pEvent the event that we are interested in. Note that @c
   * AddRef will be called on the event. Can't be @c NULL.
   *
   * @param i_pHandler the handler to call. Can't be @c NULL. 
   * @c AddRef will be called on this pointer. Note that the type of 
   * @c CATSYPEventArgs supported by this handler will be compared to
   * the type of arguments of the event. It must be a super-type of
   * the one of the event.
   *
   * @param i_handleConsumedEvents @c !=0 if the handler should be
   * called for consumed events.
   *
   * @return @c !=0 if succeeded, @c 0 if failed to add handler due to
   * invalid input or internal error (in that case a @ref FAILURE has
   * been raised).
   */
  int AddHandler(CATSYPEvent *i_pEvent, CATSYPEventHandler *i_pHandler, int i_handleConsumedEvents = 0);

  /**
   * Remove an handler for an event.
   *
   * If this function is called during the dispatch of an event, the
   * unregistered event handler will be called for this dispatch but
   * will not be called for next dispatches.
   *
   * If the same handler has been added multiple times, this function
   * removes the first found registration (starting the look up from
   * the most ancient registration).
   *
   * @param i_pEvent the event. Can't be @c NULL.
   *
   * @param i_pHandler the handler. Can't be @c NULL.
   *
   * @return @c !=0 if succeeded, @c 0 if failed to remove handler due
   * to invalid input or internal error (in that case a @ref FAILURE has
   * been raised) or if the handler was never registered for the given
   * event (in that case NO @ref FAILURE is raised, it is valid to do
   * so; this is important for auto-remove handlers).
   *
   * @see #AddHandler
   */
  int RemoveHandler(CATSYPEvent * i_pEvent, CATSYPEventHandler * i_pHandler);

  /**
   * Dispatch the event.
   *
   * This call is synchronous; it is blocking until the dispatch is
   * ended.
   *
   * The dispatch is reentrant; it is safe to call @c Dispatch while
   * being called on a handler by another call to @c Dispatch. The
   * first @c Dispatch will simply be paused until the new @c Dispatch
   * has ended (@c Dispatch is synchronous) and then it will be
   * resumed an continue as expected.
   *
   * The event arguments instance will be passed to each handler; it
   * may be used to pass informations between handlers and/or to give
   * a result to the dispatch. Since the call of @c Dispatch is
   * synchronous, the caller may look at the state of the arguments
   * after the dispatch (for example after the dispatch the caller can
   * check if the event has been consumed).
   *
   * When a hanlder consume the event (@ref CATSYPEventArgs#Consume),
   * the handlers that should have been called after it and that are
   * not registered to be called for consumed events are not
   * called.<br/>
   * This include the handlers on the same widget. For example if two
   * handlers have been registered (with @c i_handleConsumedEvents=0)
   * on a widget for the same event and the first one consume the
   * event, the second one (in the order of registration) won't be
   * called.
   *
   * @param i_pArgs the arguments of the event to dispatch (the
   * dispatched event is retrieved using @ref
   * CATSYPEventArgs#GetEvent). @ref CATSYPEventArgs#GetOrigin must be
   * either this object or @c NULL.
   *
   * @return @c !=0 if the dispatch succeeded, @c 0 if failed.
   *
   */
  int Dispatch(CATSYPEventArgs * i_pArgs);

  /**
   * Activate the cache mode.
   *
   * The cache mode is a particular mode that stops the emission
   * of events when a property is modified. In this mode, each time
   * a property is modified, this action is registered by the
   * datablock. The advantage of this mode is to optimize performance
   * by reducing the number of emitted events.
   *
   * If a same property is modified several times in this mode, only
   * its last modification is recorded.
   *
   * Calling this member function when the cache mode is already
   * activated does nothing.
   */
  void BeginUpdateTransaction();

  /**
   * Deactivate the cache mode.
   *
   * When the cache mode is deactivated, all the recorded modifications
   * of properties values are notified by emitting the
   * @ref PropertiesChanged event. This event is sent with all the values
   * of the modified properties.
   *
   * Calling this member function when the cache mode is already
   * deactivated does nothing.
   * 
   * @param i_sendUpdatesFlag is used to specify if the @ref PropertiesChanged 
   * event must be sent.
   *
   * @see CATSYPDataBlock#BeginUpdateTransition.
   */
  void EndUpdateTransaction(int i_sendUpdatesFlag=1);
   
 /**
   * Instantiate a new data block that will be a clone of this one for data. 
   * Copy all the properties of the original data-block in the clone, with all
   * related attributes, including default value and current value.
   *
   * Copies all event handlers of the original data-block in the clone, but
   * not registrations to events. 
   *
   * All data-bindings and all triggers are lost in the clone.
   *
   * If cache mode is activated in the original data-block, cache mode will be
   * activated in the clone, but the cache of the clone will be empty.
   *
   * The clone is fully compatible with all data-templates supported by the
   * original data-block. If associated with a data-template, the clone 
   * will recreate all data bindings, event handlers and triggers described in 
   * the data-template on this new view instance, having kept no link to the 
   * view instance of the original data-block whatsoever.
   *
   * @return a new data-block with the same properties than this one.
   */
  CATSYPDataBlock * CloneData() const;

  /**
   * Get the @c PropertiesChanged event.
   *
   * The @c PropertiesChanged event is emitted when the value of some
   * properties of the datablock has been modified. Its origin will
   * be the datablock object on which the set of properties have been
   * updated.
   *
   * @par EventProperties
   *    - Name: @c "PropertiesChanged
   *    - Type of propagation: @c OriginToRoot
   *    - Type of argument: @ref CATSYPPropertiesChangedEventArgs
   *
   * @return the event instance. @c AddRef has NOT been called on
   * the returned pointer.
   */
  static CATSYPEvent * PropertiesChanged();
private:
  /**
   * Default constructor
   * Declared private to force using CATSYPDataBlockFactory to create a
   * CATSYPDataBlock.
   */
  CATSYPDataBlock ( CATSYPMetaClass * i_pMetaClass);

  /**
   * Initializes the given property.
   *
   * @param i_name the name of the property to initialize.
   *
   * @param i_spPropertyValue the value used to initialize the property.
   */
  void InitProperty(const CATUnicodeString & i_name, const CATBaseUnknown_var & i_spPropertyValue);

  /**
   * Dictionary that contains entries composed of a property name and a
   * property value.
   */
  //CATSYPProperties _properties;
  CATSYPHashMap<CATUnicodeString, CATBaseUnknown_var> _properties;

  /**
   * Support to handle events.
   */
  CATSYPEventHandlersSupport _support;

  /**
   * Flag that indicates whether the cache mode is activated or not.
   * If this mode is activated, no events are emitted by the datablock
   * when the value of a property is updated. Those modifications are cached
   * inside the data block and can be retrieved using the GetModifiedProperties
   * member function.
   * By default, cache mode is not activated.
   */
  int _cacheMode;
  int _propertiesChangedEventFlag;

  /**
   * The list of modified properties when the cache mode is
   * activated.
   */
  CATSetOfCATUnicodeString _modifiedProperties;

  // Copy constructor and equal operator
  // -----------------------------------
  CATSYPDataBlock (CATSYPDataBlock &);
  CATSYPDataBlock & operator=(CATSYPDataBlock &);

  friend class CATSYPDataBlockFactory;
};

#endif
