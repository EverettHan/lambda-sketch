//===================================================================
// COPYRIGHT DS SolidWorks 2010/04/22
//===================================================================
// SWXSvSolver.h
// Header definition of class SWXSvSolver
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2010/04/23 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef SWXSvSolver_H
#define SWXSvSolver_H

#include "SWXSvSolverAPI.h"
#include "SWXUtUniqueIdFactory.h"
#include "SWXUtUniqueId.h"
#include "CATMathTransformation.h"
#include "SWXSvEnums.h"
#include "SWXUtVector.h"
#include "SWXUtMap.h"
#include "CATBody.h"
#include "CATFace.h"
#include "SWXSvEnums.h"

class SWXUtPoint;
class SWXUtLine;
class SWXUtCircle;
class SWXUtEllipse;
class SWXUtPlane;
class SWXUtCylinder;
class SWXUtCone;
class SWXUtSphere;
class SWXUtTorus;
class SWXUtCSys;
class SWXUtArc;
class SWXSvCDSSolverWrapper;
class SWXSvSolverGeometry;
class SWXSvSolverSketch;
class SWXSvSolverConstraint;
class SWXSvSolverContainers;
class SWXSvHelpData;
class SWXSvConstraintAdditionalData;
class SWXUtSplineCondition;
class SWXUtBSpline;
class SWXUtGeometry_Ptr;
class SWXSvConstraintData;

class ExportedBySWXSvSolverAPI SWXSvSolver
{
public:

	SWXSvSolver(double iLinearTolerance = -1.0, double iAngularTolerance = -1.0);
	~SWXSvSolver();

	CATUnicodeString GetSWXCDSVersion();
	CATUnicodeString GetCDSGeomName(const SWXUtUniqueId &iGeomId);

	// funcs to update geometry on solver
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtPoint const &iPoint);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtLine const &iLine);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtCircle const &iCircle);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtEllipse const &iEllipse);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtPlane const &iPlane);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtCone const &iCone);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtCylinder const &iCylinder);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtSphere const &iSphere);
	bool SyncGeometryOnSolver(SWXUtUniqueId const &iGeomId, SWXUtTorus const &iTorus);

	// 3d geometry  
	SWXUtUniqueId AddGeometry(SWXUtPoint const &iPoint);
	SWXUtUniqueId AddGeometry(SWXUtLine const &iLine);
	SWXUtUniqueId AddGeometry(SWXUtCircle const &iCircle);
	SWXUtUniqueId AddGeometry(SWXUtEllipse const &iEllipse);
	SWXUtUniqueId AddSpline(int iDegree, SWXUtVector<SWXUtUniqueId> &iThroughPoints, SWXUtSplineCondition &iSplineCondition);
	SWXUtUniqueId AddSpline(SWXUtVector<SWXUtUniqueId> &iControlPoints, SWXUtBSpline const &iUtBSpline);

	SWXUtUniqueId AddGeometry(SWXUtPlane const &iPlane);
	SWXUtUniqueId AddGeometry(SWXUtCylinder const &iCylinder);
	SWXUtUniqueId AddGeometry(SWXUtTorus const &iTorus);
	SWXUtUniqueId AddGeometry(SWXUtSphere const &iSphere);
	SWXUtUniqueId AddGeometry(SWXUtCone const &iCone);

	SWXUtUniqueId AddSurface(CATBody_var const &iBody, CATFace_var const &iFace);

	void AddSkinParameterToConstraint(SWXUtUniqueId const &iConsId);

	// 2d geometry
	SWXUtUniqueId AddSketch(SWXUtCSys const &iSketch);
	SWXUtUniqueId AddGeometry(SWXUtPoint const &iPoint, SWXUtUniqueId const &iPlaneId);
	SWXUtUniqueId AddGeometry(SWXUtLine const &iLine, SWXUtUniqueId const &iPlaneId);
	SWXUtUniqueId AddGeometry(SWXUtCircle const &iCircle, SWXUtUniqueId const &iPlaneId);
	SWXUtUniqueId AddGeometry(SWXUtEllipse const &iEllipse, SWXUtUniqueId const &iPlaneId);
	SWXUtUniqueId AddGeometry(SWXUtUniqueId const &iPlaneId, SWXUtUniqueId const &iPoint1Id, SWXUtUniqueId const &iPoint2Id, SWXUtUniqueId const &iCenterId, double iParam = 1., svAlignment iAlignment = svAlignmentAlign);
	SWXUtUniqueId AddGeometry(SWXUtUniqueId const &iSketchId, SWXUtUniqueId const &iPoint1Id, SWXUtUniqueId const &iPoint2Id );
	SWXUtUniqueId AddSpline(int iDegree, SWXUtVector<SWXUtUniqueId> &iThroughPoints, SWXUtSplineCondition &iSplineCondition, SWXUtUniqueId const &iSketchId);
	SWXUtUniqueId AddSpline(SWXUtVector<SWXUtUniqueId> &iControlPoints, SWXUtBSpline const &iUtBSpline, SWXUtUniqueId const &iSketchId);
	
	void RemoveGeometry(SWXUtUniqueId& iGeom);
	void RemoveInternalGeometry(SWXSvSolverGeometry* iGeom);

	// constraints
	SWXUtUniqueId AddConstraint(svConstraintType iType, SWXUtUniqueId const &iGeom0, 
        SWXUtUniqueId const &iGeom1 = SWXUtUniqueId(), SWXUtUniqueId const &iGeom2 = SWXUtUniqueId(), 
        SWXUtUniqueId const &iGeom3 = SWXUtUniqueId(), double iValue = 0.0, svConstraintChirality = svChiralityNotSpecified, SWXSvConstraintData* ipConstraintData = NULL);
	SWXUtUniqueId AddDimension(svConstraintType iType, double iValue, SWXUtUniqueId const &iGeom0,
		SWXUtUniqueId const &iGeom1 = SWXUtUniqueId(), SWXUtUniqueId const &iGeom2 = SWXUtUniqueId(), SWXUtUniqueId const &iGeom3 = SWXUtUniqueId());

	SWXUtUniqueId AddPattern(svConstraintType iType,
									SWXUtUniqueId const &iAxis,
									int iNumInstances,
									double iDistanceBetweenInstances,
									SWXUtVector<SWXUtUniqueId> &iGeoms,
									SWXUtVector<SWXUtUniqueId> &iVars);

	SWXUtUniqueId AddLinearPattern2D(SWXUtUniqueId const &iAxisA,
										SWXUtUniqueId const &iAxisB,
										int iNumInstancesA,
										int iNumInstancesB,
										double iDistanceBetweenInstancesA,
										double iDistanceBetweenInstancesB,
									  SWXUtVector<SWXUtUniqueId> &iGeoms,
									  SWXUtVector<SWXUtUniqueId> &iVars);

	bool UpdateOffsetValue( SWXUtUniqueId const &iConstraint, double iValue );
	bool FixOffsetDistance( SWXUtUniqueId const &iConstraint, bool iIsFixed );

// -----------------------------------------------------------
// (KLB) - Mechanism Synthesis (BEGIN)
// -----------------------------------------------------------
	SWXUtUniqueId AddEqualDimValueConstraint (svConstraintType iDimType1, SWXUtVector<SWXUtUniqueId>const &iGeomsForDim1, svConstraintType iDimType2, SWXUtVector<SWXUtUniqueId>const &iGeomsForDim2, double iValue=0.0);
// -----------------------------------------------------------
// (KLB) - Mechanism Synthesis (end)
// -----------------------------------------------------------

	svConstraintType GetConstraintType(SWXUtUniqueId const &iConsId);	// added for tests

	void AddHelpDataToConstraint(SWXUtUniqueId const &iConsId, SWXUtUniqueId const &iGeomIndex, SWXSvHelpData const &iHelpData, int iIdx = 0);

	// EHV-HELPPOINTS
	bool GetHelpDataFromConstraint(SWXUtUniqueId const &iConsId, SWXUtUniqueId const &iGeomIndex, SWXSvHelpData &oHelpData, int iIdx = 0);

	void RemoveConstraint(SWXUtUniqueId const &iConstraint);
	bool UpdateConstraintValue(SWXUtUniqueId const &iConstraint, double iValue, bool iInitialiseSolverChirality);
	bool SetConstraintAdditionalData(SWXUtUniqueId const &iConstraint, SWXSvConstraintAdditionalData const &iConsData );
	double GetConstraintValue(SWXUtUniqueId const &iConstraint);
	void AttachVariableToDimension(SWXUtUniqueId const &iDimensionId, SWXUtUniqueId const &iVarId);
	void ConstrainEllipseEdgePoints(SWXUtUniqueId const &iEllipse, SWXUtUniqueId const &iEllipseCentre, SWXUtUniqueId const &iPointLeft, SWXUtUniqueId const &iPointTop, SWXUtUniqueId const &iPointRight, SWXUtUniqueId const &iPointLow);	

	// sets
	SWXUtUniqueId AddSet(SWXUtUniqueId const &iSketchId, bool iIsScalable = false);
	SWXUtUniqueId AddSet(bool iIsScalable = false);
	void SetSetScalability(SWXUtUniqueId const &iSetId, bool iIsScalable);
	void AddToSet(SWXUtUniqueId const &iSetId, SWXUtUniqueId const &iGeomId, bool iIsAdding /*and not removing*/);
	void RemoveSet(SWXUtUniqueId& iSet);

	// variables and equations
	SWXUtUniqueId AddVariable(double iValue);
	double GetVariableValue(SWXUtUniqueId const &iVarId) const;
	void SetVariableValue(SWXUtUniqueId const &iVarId, double iValue);
	void RemoveVariableFromDimension(SWXUtUniqueId const &iDimensionId);

	// update geometry with solve data, for use after a solve
	bool UpdateGeometry(SWXUtEllipse& ioEllipse, SWXUtUniqueId const &iEllipseId) const;
	bool UpdateGeometry(SWXUtCircle& ioCircle, SWXUtUniqueId const &iCircleId) const;
	bool UpdateGeometry(SWXUtLine& ioLine, SWXUtUniqueId const &iLineId) const;
	bool UpdateGeometry(SWXUtPoint& ioPoint, SWXUtUniqueId const &iPointId) const;
	bool UpdateGeometry(SWXUtPlane& ioPlane, SWXUtUniqueId const &iPlaneId) const;
	bool UpdateGeometry(SWXUtCSys& ioSketch, SWXUtUniqueId const &iSketchId) const;
	bool UpdateGeometry(SWXUtArc& ioArc, SWXUtUniqueId const &iArcId) const;
	bool UpdateGeometry(SWXUtBSpline& ioBSpline, SWXUtUniqueId const &iBSplineId) const;

	// get solve status for geometry or constraint
	svGeometryStatus GetGeomStatus(SWXUtUniqueId const &iGeomId);
	svConstraintStatus GetConstraintStatus(SWXUtUniqueId const &iConstrId);

	bool IsGeomTransformed(SWXUtUniqueId const &iGeomId) const;
	void ResetGeomTransformed(SWXUtUniqueId const &iGeomId, bool ibTransformed = false);
	void CorrectUntransformed2DGeom(SWXUtUniqueId const &iGeomId);
	bool GetTransform(SWXUtUniqueId const &iGeomId, CATMathTransformation& oXform) const;
	bool HasMoved(SWXUtUniqueId const &iGeomId, bool &oExact) const;

	void GetConstraintVariableValues(SWXUtUniqueId const &iConstrId, SWXUtVector<double>& oValues) const;

	// solving
	void Solve();
	void SolveWithoutDiagnostics();

	// drag a single entity
	int StartDrag(SWXUtUniqueId const &iGeomId, svDraggingMode iDragMode = svInitialPositionDrag );

	// drag a list of entities
	// Priority given to the geometry in the order it appears in the list
	int StartDrag(int iCount, SWXUtUniqueId const *iGeomId, svDraggingMode iDragMode = svInitialPositionDrag );

	// drag a list of entities and sets - EHV 27-Feb-2014 IR-278575
	int StartDragWithSets(int iGeomCount, int iSetCount,
							SWXUtUniqueId const *iGeomId, SWXUtUniqueId const *iSetId,
							svDraggingMode iDragMode = svInitialPositionDrag );


	// drag all entities with same transform/radius change
    bool DoDrag(CATMathTransformation const &iXform, double iRadius = -2);

	// give each geometry a different transform/radius change.
	// The array sizes *must* be the same as the number returned by StartDrag
	bool DoDrag(CATMathTransformation const *iXform, double *iRadius);

    void UndoLastDrag();

	void StopDrag();

	static bool GetTotalStatus(SWXUtVector<svConstraintStatus> const &iVecConsStatus, svConstraintStatusCombineModeType iCombineMode, svConstraintStatus& oStatus);

	void DetachFirstDerivativeDirection(SWXUtUniqueId const &iSplineId, SWXUtUniqueId const &iLineId );
	void DetachSplineThroughPoints(SWXUtUniqueId const &iSplineId, SWXUtUniqueId const &iPointId );

private:
    friend class SWXSvSolverTestHelper;
	friend class SWXSvProfileSetupHelper;
	friend class SWXSvOffsetConsSetupHelper;
	friend class SWXOffsetProfileUpdateHelper;

	SWXUtUniqueId AddGeometry(SWXSvSolverGeometry* iGeom);
	SWXUtUniqueId AddGeometry(SWXSvSolverGeometry* iGeom, SWXUtUniqueId& iId);

	SWXSvSolverSketch* SketchFromId(SWXUtUniqueId const &iSketchId);

	SWXUtUniqueIdFactory mIdFactory;
	SWXSvCDSSolverWrapper* mSolver;		// instance of the CDS wrapper and the CDS

	SWXSvSolverContainers* mMapContainer;
};

#endif
