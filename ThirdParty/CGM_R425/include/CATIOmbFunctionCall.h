/**
* @level Protected
* @usage U4 CATOmbFunctionCallAdapter
*/


// COPYRIGHT Dassault Systemes 2008
//===================================================================
//
//  May 2008  Creation: Code generated by the CAA wizard  KWU
//===================================================================
#ifndef CATIOmbFunctionCall_H
#define CATIOmbFunctionCall_H

#include "CATObjectModelerBase.h"
#include "CATBaseUnknown.h"
#include "sequence_octet.h"
#include "CATOmbTimeStamp.h"
#include "CATOmxSR.h"

class CATILinkableObject;
class CATIBindParameters;
class CATIOmbFunctionCall_var;
class CATOmbUniversalLinkResult;
class CATIOmbFunction_var;
class CATError;
class CATOmxAny ;
class CATILinkableObjectV2_var ;
class CATIOmbProxy;

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATObjectModelerBase IID IID_CATIOmbFunctionCall;
#else
extern "C" const IID IID_CATIOmbFunctionCall ;
#endif




/**
* Interface representing Function Calls.
*
* <br><b>Role</b>: Function Call is the object actually applying the function when asking for a target pointed
*                  with functional linking.
*                  Function Call is an object owning a Function and an input argument for this Function.
*                  When given a context Function Call is able to compute the Function result out from the input 
*                  argument.
* <p>
* Function Calls are created and managed by Omb (via applicative Function Call Factories). If you implement 
* CATIOmbFunctionCall do not forget to create the associated factory (implement @href CATIOmbFunctionCallFactory).
*
* @href CATOmbUniversalLinkResult, @href CATIOmbFunction, @href CATIOmbFunctionCallFactory
*/





class ExportedByCATObjectModelerBase CATIOmbFunctionCall : public CATBaseUnknown
{

    CATDeclareInterface;


public:
    

    /** 
    * Calls the Function and compute its result.
    *
    * <br><b>Role</b>: : applies the function to its input argument in the given context.
    *
    * @param iParam [in]
    *   Specifies if the Function is allowed to ask for the loading of not in session objects. 
    * @param iContext [in]
    *   The context the function needs to compute out its result. It can be a container for instance.
    * @param oTarget [out]
    *   The computed result. It is the object dynamically pointed at time t by a functional link.
    * @param oError[out]
    *   To give more details about the resolution failure. Can be NULL.
    *
    * @return
    *   <code>S_OK</code>                             if everything ran ok
    *   <code>E_INVALIDARG</code>                     if iContext is not recognized
    *   <code>HR_LINKSOLVE_ObjectNotLoaded</code>     if the result was not found because something is not loaded. 
    *                                                 HRESULT defined in CATOMBLinkResolutionError.h
    *   <code>HR_LINKSOLVE_ObjectDoesNotExist</code>  if the result could not be computed (when iParam is set to 
    *                                                 ANYWHERE). More details may be found in oError.
    *                                                 HRESULT defined in CATOMBLinkResolutionError.h
    *   <code>E_FAIL</code>                           otherwise
    */
    virtual HRESULT ComputeFunctionResult ( CATIBindParameters *iParam, CATILinkableObject *iContext, CATBaseUnknown_var &oTarget, CATError **oError = NULL) = 0;


    virtual HRESULT ComputeTargetWithProxy(const CATIOmbProxy & iProxy, CATOmxSR<CATBaseUnknown> &oTarget) = 0;

    
    
    /** 
    * Creates a copy of this.
    *
    * <br><b>Role</b>: Universal Link Result are not shared objects. Each Universal Link Result owns at most one 
    *                  Function Call. Function Calls being applicative objects they can be shared. To copy a 
    *                  Universal Link Result Omb needs to ask for the copy of its Function Call. The result of 
    *                  the copy of a Function Call can be a copy of the Function Call or the Function Call itself.
    *                  This and the returned copy must be identical. 
    *
    * @param oFunctionCallCopy [out]
    *   The copy of this or this itself.
    *
    * @return
    *   <code>S_OK</code> if everything ran ok
    *   <code>E_FAIL</code>       otherwise
    *
    */
    virtual HRESULT Copy ( CATIOmbFunctionCall_var &oFunctionCallCopy) = 0;
    

    /** 
    * Returns the persistent ID of the associated Function Call Factory. 
    *
    * <br><b>Role</b>: Each Function Call is associated to exactly one factory. Each Factory has its 
    *                  persistent ID. Persistent IDs are registered by Omb in 
    *                  CATOmbUniversalLinkFactoryRegisterKey.h. Function Call are able to return their 
    *                  associated Function Call Factory IDs for marshalling purpose.
    * @return
    *   the persistent ID of the associated Function Call Factory
    */
    virtual int GetFactoryID() = 0;

    /** 
    * Returns the Function Call function.
    *
    * <br><b>Role</b>: returns the Function Call function.
    *
    * @param oFunction [out]
    *   The function.
    *
    * @return
    *   <code>S_OK</code> if everything ran ok
    *   <code>E_FAIL</code>       otherwise
    *
    */
    virtual HRESULT GetFunction( CATIOmbFunction_var &oFunction ) = 0;

    /** 
    * Marshalls the function argument.
    *
    * <br><b>Role</b>: returns the stream of the function argument for marshalling purpose.
    *                  This stream will be interpreted by associated Function Call Factory at unmarshalling.
    *
    * @param oFunctionStream [out]
    *   The stream of the function argument.
    *
    * @return
    *   <code>S_OK</code> if everything ran ok
    *   <code>E_FAIL</code>       otherwise
    *
    */
    virtual HRESULT MarshallArgument(SEQUENCE(octet) & oArgumentStream) = 0;


     /** 
     * Gets the Function Call result update stamp.
     *
     * <br><b>Role</b>: Gets the Function Call result update stamp. The update stamp is necessary to compute the
     *                  synchro status of the link.
     *
     * @param iContext [in]
     *   the context needed to compute the result of the function.
     * @param oUS [out]
     *   The result update stamp. 
     *
     * @return
     *   <code>S_OK</code> if everything ran ok and the update stamp was succesfully computed
     *   <code>S_FALSE</code> if the result is not available and the update stamp was not computed
     *   <code>E_FAIL</code>       otherwise 
     *
     */
     virtual HRESULT GetUpdateStamp(CATILinkableObject *iContext, CATOmbTimeStamp &oUS) = 0;

    /**
     *  Gets the Function Call result synchronization stamp.
     * @param iContext [in]
     *   the context needed to compute the result of the function.
     * @param ioVersion [in, out]
     *    If version is 0 in input, then assign to it latest version.
     *    If version is 1, then oStamp must contain an integer (compatibility).
     *    If you use a delegation, be careful, it is not because you implement a version N that your callees do.
     *    Expected result (with a complex delegation on N objects sample) :
     *    version 1:
     *      ioVersion         = 1
     *      oLinkSynchroStamp = subObject_1.UpdateStamp + ... + subObject_N.UpdateStamp
     *    version 2:
     *      ioVersion         = [ 2 , subObject_1.Version_X1                   , ... , subObject_N.Version_XN                   ]
     *      oLinkSynchroStamp = [     subObject_1.LinkSynchroStamp(Version_X1) , ... , subObject_N.LinkSynchroStamp(Version_XN) ]
     * @param oStamp [out]
     *    The link synchronization stamp.  
     *    If version 1 (integer, compatibility) is used, the integer must be different from 0.
     *    Otherwise, it must be different from a null UUID.
     * @return
     *    An HRESULT value.
     *    <code>S_OK</code> if everything ran ok (the link synchronization stamp is available).
     *    <code>E_INVALIDARG</code> if input ioVersion is not supported (the link will be consider as not synchronized).
     *    Otherwise associated failure code.
     *    
     */
     virtual HRESULT GetSynchroStamp (CATILinkableObject * iContext, CATOmxAny & ioVersion, CATOmxAny & oStamp) = 0 ;

     /**
     * Gets the linkable target associated with the function call.
     * Used for CATBack : being able to compute through CATILinkableObjectV2 an identification which can make possible to find the corresponding object
     * in the corresponding V5 file.
     * @param ospLinkableTarget [out]
     *    The linkable target associated with the function call. 
     * @return
     *    An HRESULT value.
     *   <code>S_OK</code> if everything ran ok.
     *   <code>E_FAIL</code> otherwise.
     *    
     */ 
     virtual HRESULT GetLinkableTarget (CATILinkableObjectV2_var & ospLinkableTarget) = 0 ;

};

CATDeclareHandler(CATIOmbFunctionCall, CATBaseUnknown);

#endif
