//===================================================================
// COPYRIGHT Dassault Systemes 2019/10/10
//===================================================================
// CATPolyMeshTriangleKDTree.cpp
// Header definition of class CATPolyMeshTriangleKDTree
//===================================================================
//
// Usage notes:
//
// I (DGE2) developed this in 2019 for the prototype of a Boolean Operator.
// It was coded with performances in mind (time and memory-wise), to be built, updated and queried as fast as possible,
// while not being too naive when it comes to node subdivision.
// There aren't many functionalities, but feel free to expand them.
//
//===================================================================
//  2019/10/10 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATPolyMeshTriangleKDTree_H
#define CATPolyMeshTriangleKDTree_H

#include "CATPolyGriddingTools.h"

// PolyhedralBodyOperators
#include "CATPolyTriangleKDTree.h"

// PolyhedralInterfaces
#include "CATIPolyMeshObserver.h"

class CATIPolyMesh;
class CATIPolySurfaceVertexPositionConstLayer;

/**
* A KD-Tree for CATIPolyMesh triangles.
* It automatically tries to stay up to date with mesh updates.
* It was not built for ray-casting and is optimized to balance the number of triangles in each leaf.
* One triangle may be in several leaves at the same time.
*/
class ExportedByCATPolyGriddingTools CATPolyMeshTriangleKDTree
{
public:

  /**
  * @brief Main constructor.
  */
  CATPolyMeshTriangleKDTree (CATIPolyMesh& iMesh);

  ~CATPolyMeshTriangleKDTree ();

  /**
  * @brief Sets the safety margin regarding how close a triangle must be to the boundaries of a node to intersect it.
  * Default value is zero.
  * To be called before Initialize.
  */
  void SetTolerance (const double iEpsilon) { _Tree.SetTolerance(iEpsilon); }

  /**
  * @brief Sets how many less triangles there should at least be in each son of a node for this node to be subdivided,
  * with regard to the number of triangles in their father.
  * This measures how effective the split of a node should at least be to be performed.
  * Default value is 30.
  * To be called before Initialize.
  */
  void SetMinTriangleDelta (const size_t iMinTriangleDelta) { _Tree.SetMinTriangleDelta(iMinTriangleDelta); }

  /**
  * @brief Sets the number of cuts considered along each dimension when subdividing a node.
  * Default value is 100.
  * To be called before Initialize.
  * @details When we try to subdivide a node, we project triangles on all three axis, but we discretize space into buckets to avoid
  * having to sort projected triangles and thus increase performance. This means there 3 * iNbBuckets possible cuts at each node subdivision.
  */
  void SetNumberOfBuckets (const size_t iNbBuckets) { _Tree.SetNumberOfBuckets(iNbBuckets); }

  /**
  * @brief Sets the number of threads used during initialization and update of the KD-tree.
  * Default value is 1 (monothreaded behavior).
  * To be called before Initialize.
  */
  void SetNumberOfWorkers (const unsigned int iNbWorkers) { _Tree.SetNumberOfWorkers(iNbWorkers); }

  /**
  * @brief call this after the constructor.
  * @details It inserts all triangles present at the start and setups the observer on the mesh.
  */
  HRESULT Initialize ();

  /**
  * @brief Tries again to subdivide the leaves of the tree.
  * @details When triangles are added, removed or modified, we update the tree, but we do not try to subdivide leaves : the structure of the tree is unchanged.
  * We simply remember which leaves were affected. By calling this method, we will recursively subdivide all leaves which should be.
  */
  HRESULT Update ();

public:

  /**
  * @brief Get all triangles whose distance to iTriangle is at most iEpsilon in oTriangles.
  */
  HRESULT GetTriangles (const CATMathPoint iTriangle[3], const double iEpsilon, Poly::Set<int>& oTriangles);

  /**
  * @brief Get the first triangle encountered below iVertex (a vertex of the mesh the KD-Tree is build on) along the Z axis in oTriangleBelow.
  * oTriangleBelow is zero if no triangle is found.
  */
  HRESULT GetTriangleBelow (const CATPolyExactArithmetic& iArithmetic, const int iVertex, int& oTriangleBelow);

  /**
  * This method is used to navigate the tree and call user-defined methods on its chosen leaves.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a visited node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * The arguments to GetSides provide the dimension (0, 1 or 2) of the splitting plane and the splitting value for the current node.
  * @tparam Visitor : the object on which the method iCall is called for each visited leaf of the tree.
  * @tparam Call : the method type of the method called on iVisitor on leaves of the tree. It must have signature :
  * HRESULT Call(const Triangle* ipTriangles, const unsigned int iNbTriangles, Args... iArgs)
  * @tparam Args : remaining arguments of the method iCall beside the triangles in the visited leaf and the number of them.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT Traverse (Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

public:

  /**
  * Recovers the mesh the KD-Tree is built on.
  */
  inline CATIPolyMesh& GetMesh () { return _Mesh; }

private:

  //////////////////////
  // Triangle Helpers //
  //////////////////////

  HRESULT GetTriangle (const int iTriangle, CATMathPoint oPoints[3]);

  HRESULT GetTriangle (const int iFstVtx, const int iSndVtx, const int iTrdVtx, CATMathPoint oPoints[3]);

  HRESULT GetTriangle (const int iTriangle, const int iOldVertex, const int iNewVertex, CATMathPoint oOldPoints[3], CATMathPoint oNewPoints[3]);

private:

  /**
  * The updater trying to keep the KD-Tree up to date.
  * Remember that the updater does not try to subdivide leaves.
  * Also, due to the way CATIPolyMeshObserver works, we cannot react to the update of the position of a vertex,
  * because the interface does not provide us with the old position of the vertex.
  */
  class Updater : public CATIPolyMeshObserver
  {
  public:
    Updater (CATPolyMeshTriangleKDTree& iKDTree) : _KDTree (iKDTree) {}

    HRESULT ReactToAddTriangle (int v0, int v1, int v2, int t) override;

    HRESULT PrepareToRemoveTriangle (int t) override;

    HRESULT ReactToUpdateTriangle (int t0, int t1, int v0, int v1) override;

  private:

    CATPolyMeshTriangleKDTree& _KDTree;
  };

  class GetTrianglePosition
  {
  public:

    GetTrianglePosition(CATIPolyMesh& iMesh, CATIPolySurfaceVertexPositionConstLayer& iPositionLayer);

    ~GetTrianglePosition();

    HRESULT Get(const int iTriangle, CATMathPoint (&oPositions)[3]) const;

  private:
    CATIPolyMesh& _Mesh;
    CATIPolySurfaceVertexPositionConstLayer& _PositionLayer;
  };

private:

  inline CATIPolySurfaceVertexPositionConstLayer* PositionLayer () const { return _pPositionLayer; }

private:

  CATIPolyMesh& _Mesh; // The mesh the grid is describing.
  CATIPolySurfaceVertexPositionConstLayer* _pPositionLayer; // Position layer of the mesh.
  Updater* _pUpdater; // Observer on the overlay used to maintain the voxel grid up to date.

  CATPolyTriangleKDTree<int> _Tree;

};

#endif // CATPolyMeshTriangleKDTree_H
