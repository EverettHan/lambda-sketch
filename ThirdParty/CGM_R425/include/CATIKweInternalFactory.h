// COPYRIGHT Dassault Systemes 2004
//===================================================================
//
// CATIKweInternalFactory.h
// Define the CATIKweInternalFactory interface
//
//===================================================================
//
// Usage notes:
//   New interface: describe its use here
//
//===================================================================
//
//  Dec 2004  Creation: Code generated by the CAA wizard  tdv
//===================================================================
#ifndef CATIKweInternalFactory_H
#define CATIKweInternalFactory_H

#include "KnowledgeItf.h"
#include "CATBaseUnknown.h"
#include "CATLISTV_CATBaseUnknown.h"
#include "CATUnicodeString.h"
#include "CATBaseUnknown.h"
#include "CATICkeRelationForwards.h"
#include "sequence_CATBaseUnknown.h"
#include "CATIParmPublisher.h"

class CATICkeParm_var;
class CATIKweMatrix_var;
class CATPathElement;
class CATIPrdObject_var;
class CATICkeSheet_var;
class CATICkeRelation_var;
class CATIPLMComponent_var;

class CATIPLMDmtDocument_var;

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByKnowledgeItf IID IID_CATIKweInternalFactory;
#else
extern "C" const IID IID_CATIKweInternalFactory ;
#endif

//------------------------------------------------------------------

/**
 * Describe the functionality of your interface here
 * <p>
 * Using this prefered syntax will enable mkdoc to document your class.
 */
class ExportedByKnowledgeItf CATIKweInternalFactory: public CATBaseUnknown
{
  CATDeclareInterface;

  public:
	  
    /**
	* @nodoc
	* Creates an imported parameter. These parameter are created when pasting as 
	* result with link, when creating a formula in context, or between parameters 
	* of different documents.
	*/
	virtual CATICkeParm_var CreateImportedParameter(const CATICkeParm_var& iReference, int withLink = 1, int refref = 0) = 0;

	/**
	* @nodoc
	* Creates an imported parameter. These parameter are created when pasting as 
	* result with link, when creating a formula in context, or between parameters 
	* of different documents.
	*/
	virtual CATICkeParm_var CreateImport(CATPathElement* selected_element, CATPathElement* object_in_work = NULL) = 0 ; 

	virtual CATBaseUnknown_var CreateKwePattern(const CATUnicodeString &iName, 
		const CATUnicodeString &iComment, 
		CATLISTV(CATBaseUnknown_var) *iParameters, 
		const CATUnicodeString &iBody,
		const CATIParmPublisher_var &iRoot,
		CATBoolean iRealNames) = 0;


	/**
	* @nodoc
	*Creates an imported contextual parameter. These parameter are created when pasting as 
	* result with link or when creating a formula between parameters 
	* of two different contextual documents.
	*/
	virtual HRESULT CreateContextualImport(CATICkeParm_var &oPointingElt, 
		CATIPrdObject_var iPointingPrdObj, 
		const CATICkeParm_var &iPointedElt, 
		const CATIPrdObject_var &iPointedPrdObj) = 0;

	/**
	* @nodoc
	*Creates an imported contextual parameter. These parameter are created when pasting as 
	* result with link or when creating a formula between parameters 
	* of two different non contextual documents.
	*/
	virtual HRESULT CreateRepRepImport(CATICkeParm_var &oPointingElt, 
		const CATICkeParm_var &iPointedElt) = 0;

	/**
	 * @nodoc
	 * Creates a volatile sheet.
	 * @param iInputString
	 *   Could be:
	 *    - text sheet file path. Example: e:\tmp\toto.txt
	 *    - excel sheet file path using the first "excel worksheet". Example: e:\tmp\toto.xls
	 *    - excel sheet using the syntax: [filePath]excelWorkSheetIndex. Example: [e:\tmp\toto.xls]3
	 * @param ospSheet
	 *   The volatile sheet created
	 * @param oErrorsKey
	 *   The list of error keys allowing you to generate your own NLS error messages.
	 */
	virtual HRESULT CreateVolatileSheet(const CATUnicodeString & iInputString, 
		CATICkeSheet_var & ospSheet, 
		CATListOfCATString & oErrorsKey) = 0;

    virtual void RestoreLiteralForInit(const SEQUENCE(CATBaseUnknown_ptr)& members) = 0;


	// No constructors or destructors on this pure virtual base class

	      /**
        * Create a rule between parameters (example : if (x> 3) y=3*x else y = 2).<br>
		* Same service as CATICkeRelationFactory but without license control.<br> 
        * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised<br>
        * @param iRelationName  program's name
        * @param iComment comment  !!
        * @param iFamily not used !!
        * @param iListOfParameters (pointer on list of CATBaseUnknown_var) contains literal used in inputs or outputs (x and y  in our example)  
        * @param iBody contains the string describing the program ("if (x> 3) y=3*x else y = 2" in our example)
        * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method <br>
        * and so to be able to recognize parameters by their name<br>
        * Not used in realnames = false mode<br>
        * @param iRealnames  = 2 possibilities to name a parameter in the body.<br> 
        * <tt>CATCke::True</tt>  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
        * <tt>CATCke::False</tt> names used are a1,a2,a3,etc...<br>
        *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....<br>
        * We advise you strongly to use this second method in your application to avoid NLS problems .  
        * <br> 
        * @return Rule created or NULL_var if syntax error
		* <br>
		* only works on persistent factory. This object must be aggregated.
		* The parameters passed as arguments must be in the same container as the relation. This will be enforced in the future release
		* to allow only supported model.	
	    */
		virtual CATICkeRelation_var CreateProgram (	const CATUnicodeString    &iRelationName,
													const CATUnicodeString    &iComment,
													const CATUnicodeString    &iFamily,
													const CATCkeListOfParm     iListOfParameters,
													const CATUnicodeString    &iBody,
													const CATIParmPublisher_var &iRoot = NULL_var,
													const CATCke::Boolean     &iRealnames = 1) = 0;
    
        /**
        * Create a check between parameters (example : x > 3).<br>
	    * Same service as CATICkeRelationFactory but without license control.<br> 
        * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised<br>
        * @param iRelationName program's name
        * @param iComment comment
        * @param iFamily not used !!
        * @param iListOfParameters (pointer on list of CATBaseUnknown_var) contains literal used in inputs (x and y  in our example)  
        * @param iBody contains the string describing the check ("x> 3" in our example)
        * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method<br> 
        * and so to be able to recognize parameters by their name<br>
        * Not used in realnames = false mode<br>
        * @param iRealnames  = 2 possibilities to name a parameter in the body. <br>
        * <tt>CATCke::True</tt>  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
        * <tt>CATCke::False</tt> names used are a1,a2,a3,etc...<br>
        *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....<br>
        * We advise you strongly to use this second method in your application to avoid NLS problems .  
        * <br>
        * @return check created or NULL_var if syntax error
		* <br>
		* only works on persistent factory. This object must be aggregated.
		* The parameters passed as arguments must be in the same container as the relation. This will be enforced in the future release
		* to allow only supported model.
		*/
	    virtual CATICkeRelation_var CreateCheck   (	const CATUnicodeString     &iRelationName,
													const CATUnicodeString     &iComment,
													const CATUnicodeString     &iFamily,
													const CATCkeListOfParm    iListOfParameters,
													const CATUnicodeString     &iBody,
													const CATIParmPublisher_var &iRoot = NULL_var,
													const CATCke::Boolean    &iRealnames = 1) = 0;

		virtual void pushAggregator(CATBaseUnknown_var spAggregator) = 0;
		virtual CATBaseUnknown_var popAggregator() = 0;
		virtual CATBaseUnknown_var peekAggregator() = 0;

		/**
		* Creates a sheet feature. 
		* @param oSheet The sheet feature
		* @param iPLMDoc The PLM Document.	
		* @param iSheetWithoutFile
		*	If sheetWithoutFile = 1, a model sheet is created (sheet with persitent memory storage, but no file)
		*	and it won't be possible to associate a file to this sheet.
		* @return E_FAIL if the method fails for example if Excel or Lotus is asked on UNIX
		*		  S_OK if the method succeeds
		*/
		virtual HRESULT CreateSheetPLMDoc(CATICkeSheet_var& oSheet,const CATIPLMDmtDocument_var& iPLMDoc,int iSheetWithoutFile = 0) = 0;

		/**
		* Creates a fully functional design table (with its embedded sheet) from a PLM Document.<br>
		* Returns an handler on the new design table.
		*
		* @param oDesignTable the new design table. 
		* @param iRelationName The name of the design table
		* @param iComment The comment associated to the design table
		* @param iPLMDoc The PLM Document.	
		* @param iOrientation
		*	1 if vertical, 0 else (used only if path != "" and sheetWithoutFile = 0)
		* @param iSheetWithoutFile
		*	If sheetWithoutFile = 1, a model sheet is created (sheet with persitent memory storage, but no file)
		*	and it won't be possible to associate a file to this sheet.
		* @return E_FAIL if the method fails 
		*		  S_OK if the method succeeds
		* <br>
		* only works on persistent factory. This object must be aggregated.
		*/
		virtual HRESULT CreateDesignTablePLMDoc(CATIDesignTable_var& oDesignTable,
			                                    const CATUnicodeString     &iRelationName,
			                                    const CATUnicodeString &iComment,
			                                    const CATIPLMDmtDocument_var& iPLMDoc,
			                                    int iOrientation, 
			                                    int iSheetWithoutFile = 0) = 0;

		virtual CATBaseUnknown_var CreateReaction() =0;
		
		virtual CATICkeRelation_var CreateAction (const CATUnicodeString    &iRelationName,
														 const CATUnicodeString    &iComment,
														 const CATUnicodeString    &iFamily,
														 const CATICkeSignature_var    &iSignature,
														 const CATCkeListOfParm     iListOfParameters,
														 const CATUnicodeString    &iBody,
														 const CATIParmPublisher_var &iRoot,
														 const CATCke::Boolean     &iRealnames) =0;
		/**
		 * Creates a Parameter pointing a PLM attribute 
		 * @param iPointedComp: the PLM Component containing the attribute. The pointed component
		 * can only be a Reference or Rep Reference
		 * @param iAttrName: the Attribute name
		 * @param oParm: the created Parameter if the method was succesful
		 * @return 
		     S_OK if the parameter was succesfully created
			 E_FAIL otherwise
	     */
		virtual HRESULT CreateParameterOnPLMAttr (const CATIPLMComponent_var &iPointedComp,
			                                              const CATUnicodeString &iAttrName,
														  CATICkeParm_var &oParm)=0;


};

CATDeclareHandler(CATIKweInternalFactory,CATBaseUnknown);

#endif
