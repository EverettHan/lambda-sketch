// COPYRIGHT Dassault Systemes 2003
//===================================================================
//
// CATVizServices.h
// Header definition of CATVizServices
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Nov 2003  Creation: Code generated by the CAA wizard  svq
//===================================================================
#ifndef CATVizServices_H
#define CATVizServices_H

#include "CATViz.h" // JQT : Kept due to applicative build impact : CATViz --> SGInfra
#include "SGInfra.h"
#include "IUnknown.h"

#include "CATVizGlobals.h"
#include "CATViz3DFace.h"
#include "CATViz3DEdge.h"
#include "CATVizPtrList.h"
#include "CATReadWriteCgr.h"
//#include "CATVizViewer.h"

#include "DSYString.h" // NHD - MAC error for CATString
#include <cfloat> // HQ4 : Kept due to applicative build impact

class CATRep;
class CATILockBytes2;
class CAT3DFaceGP;
class CAT3DEdgeGP;
class CATVizUV3DRep;
class CATVizPrimitive;
class CATVizViewer;
class CATFrameManager;
class CATUnicodeString;


/**
  @enum CATVizReadCGRMode to force a mode for ReadCGRRep
  Masks can be combined. In this case, the priority would be first Smart Loading then Light then Standard
*/
enum CATVizReadCGRMode
{
  CATVizReadCGRUndef    = 0x0,       // no force, take env variables or CATSettings file
  CATVizReadCGRStandard = 0x1,       // force standard loading 
  CATVizReadCGRLight    = 0x2,       // force Light Scene Graph loading
  CATVizReadCGRSmart    = 0x4,       // force Smart loading
};

// Strip and Explode Geometry Services

/** @nodoc */
typedef struct CATVizEditModeList_
{
   CATViz3DFace * _face;
   CAT3DFaceGP  * _faceGP;
   unsigned int _lodIndex;
   //CATVizPtrList<CATViz3DEdge> _edges;
   CATVizPtrList<CAT3DEdgeGP> _edgesGP;
   CATVizVertexBuffer * _vb;
} CATVizEditModeList;

ExportedBySGInfra extern int CATInputNbVertices;
ExportedBySGInfra extern int CATOutputNbVertices;
ExportedBySGInfra extern int CATInputNbNormals;
ExportedBySGInfra extern int CATOutputNbNormals;


/**
 * @struct CATVizReadCGRSingleDescriptor hides the multiplicity of available types for one input
 */
struct ExportedBySGInfra CATVizReadCGRSingleDescriptor
{
public:
  inline CATVizReadCGRSingleDescriptor() {}
  inline CATVizReadCGRSingleDescriptor(const CATUnicodeString& iFileName) : filename(iFileName) {}
  inline CATVizReadCGRSingleDescriptor(char const* iFileName) : filename(iFileName) {}
  inline CATVizReadCGRSingleDescriptor(CATILockBytes2* iLB2) : iLB2(iLB2) {}
  inline CATVizReadCGRSingleDescriptor(char const* iBuffer, int iBufferSize) : buffer(iBuffer), bufferSize(iBufferSize) {}
  // combined buffer + identifier
  inline CATVizReadCGRSingleDescriptor(char const* iFileName, char const* iBuffer, int iBufferSize) : filename(iFileName), buffer(iBuffer), bufferSize(iBufferSize) {}
  inline CATVizReadCGRSingleDescriptor(CATILockBytes2* iLB2, char const* iBuffer, int iBufferSize) : iLB2(iLB2), buffer(iBuffer), bufferSize(iBufferSize) {}

public:
  const char* filename = nullptr;
  CATILockBytes2* iLB2 = nullptr;
  const char* buffer = nullptr;
  int bufferSize = 0;
  CATSettingCgr cgrSettings = USE_LODS_TEXTURE_EDGE;
};

/**
 * @struct CATVizReadCGRMultipleDescriptor hides the multiplicity of available types for multiple inputs
 */
struct ExportedBySGInfra CATVizReadCGRMultipleDescriptor
{
public:
  inline CATVizReadCGRMultipleDescriptor() {}

  inline CATVizReadCGRMultipleDescriptor(char const** iFileNames) : filenameArray(iFileNames) {}
  inline CATVizReadCGRMultipleDescriptor(CATILockBytes2** iLB2s) : iLB2Array(iLB2s) {}
  inline CATVizReadCGRMultipleDescriptor(char const** iBuffers, int* iBufferSizes) : bufferArray(iBuffers), bufferSizeArray(iBufferSizes) {}
  // combined buffer + identifier
  inline CATVizReadCGRMultipleDescriptor(char const** iFileNames, char const** iBuffers, int* iBufferSizes) : filenameArray(iFileNames), bufferArray(iBuffers), bufferSizeArray(iBufferSizes) {}
  inline CATVizReadCGRMultipleDescriptor(CATILockBytes2** iLB2s, char const** iBuffers, int* iBufferSizes) : iLB2Array(iLB2s), bufferArray(iBuffers), bufferSizeArray(iBufferSizes) {}

  inline CATVizReadCGRSingleDescriptor operator[](int index) const
  {
    if (filenameArray)
    {
      if (bufferArray) return CATVizReadCGRSingleDescriptor(filenameArray[index], bufferArray[index], bufferSizeArray[index]);
      else return CATVizReadCGRSingleDescriptor(filenameArray[index]);
    }
    else if (iLB2Array)
    {
      if (bufferArray) return CATVizReadCGRSingleDescriptor(iLB2Array[index], bufferArray[index], bufferSizeArray[index]);
      else return CATVizReadCGRSingleDescriptor(iLB2Array[index]);
    }
    else
    {
      if (bufferArray) return CATVizReadCGRSingleDescriptor(bufferArray[index], bufferSizeArray[index]);
      else return CATVizReadCGRSingleDescriptor();
    }
  }

public:
  const char** filenameArray = nullptr;
  CATILockBytes2** iLB2Array = nullptr;
  const char** bufferArray = nullptr;
  int* bufferSizeArray = nullptr;
  CATSettingCgr cgrSettings = USE_LODS_TEXTURE_EDGE;
};


/** @nodoc */
ExportedBySGInfra CATRep* AddCGRRepHeader(const CATVizReadCGRSingleDescriptor& iDescriptor, CATRep* iRep);
/** @nodoc */
ExportedBySGInfra CATRep * CATCreateSmartRep(const CATVizReadCGRSingleDescriptor& iDescriptor, int * oStatusCode);
/** @nodoc */
ExportedBySGInfra HRESULT CATVizStripGeometry(const CATVizPtrList<CATVizEditModeList> & iList, CATVizVertexBuffer * & oVertexBuffer, int cancelDrawJobs = 1);
/** @nodoc */
ExportedBySGInfra HRESULT CATVizExplodeGeometry(const CATVizPtrList<CATVizEditModeList> & iList, CATVizVertexBuffer * iVertexBuffer, int cancelDrawJobs = 1);
/** @nodoc */
ExportedBySGInfra CATRep * CATReadCGRRep(const CATVizReadCGRSingleDescriptor& iDescriptor, int * oStatusCode = NULL, CATVizReadCGRMode forceReadCGRMode = CATVizReadCGRUndef);
/** @nodoc */
ExportedBySGInfra CATRep * CATReadCGRRepSync(const CATVizReadCGRSingleDescriptor& iDescriptor, int * oStatusCode = NULL, CATVizReadCGRMode forceReadCGRMode = CATVizReadCGRUndef);
/** @nodoc */
ExportedBySGInfra HRESULT CATReadCGRReps(const CATVizReadCGRMultipleDescriptor& iDescriptor, int iNbFiles, CATRep ** oReps, int * oStatusCodes = NULL, CATVizReadCGRMode forceReadCGRMode = CATVizReadCGRUndef);
/** @nodoc */
ExportedBySGInfra CATVizUV3DRep * ExtractCells(CATVizUV3DRep *iRep, CATVizPtrList<CATVizPrimitive> *iCells);

/** @nodoc */
ExportedBySGInfra int ShaderPossible(void);
/** @nodoc */
void ExportedBySGInfra OptimizeSceneGraph(CATRep *rep);
/** @nodoc */
void ExportedBySGInfra CATSwitchToCGRReps(CATRep *rep, CATVizSemanticLevel iTargetLevel = HIGH);


/** @nodoc */
void ExportedBySGInfra RecursiveSetEditMode(CATRep* ipRep, int iEditMode);

//R7V IR-276007 ++
void ExportedBySGInfra    SetViewModeWindowType(CATVizViewer *viewer, const CATString& id);
CATString ExportedBySGInfra  GetViewModeWindowType(CATVizViewer *viewer);
// --

//IR-513914+
// View Modes Services
/** @nodoc */
struct CATVizViewModesFeedback
{
    enum RVMApplyStatus
    {
        eRVM_OK = 0,   //iRepViewMode is Compatilbe with iViewerViewMode.
        eRVM_IFV,    //iRepViewMode is Compatilbe IF oviewmode is enabled with iViewerViewMode.  
        eRVM_KOV,    //iRepViewMode is Incompatilbe because oviewmode can not be enabled with iViewerViewMode.
        eRVM_INV,    //iViewerViewMode is Invalid. oviewmode is validated value.  
        eRVM_INR,    //iRepViewMode is Invalid. oviewmode is validated value.  
        eRVM_UN      //Unknown or Unhandled Modes
    };
    RVMApplyStatus status;
    int oviewmode;
};
/** @nodoc */
int ExportedBySGInfra CATVizGetValidViewerViewMode(const int iViewMode, const int  iActive = 1, const int iCurrViewMode = 0);
/** @nodoc */
int ExportedBySGInfra CATVizGetValidRepFilterViewMode(const int iRepViewMode, const int iActive = 1, const int iCurrViewMode = 0);
/** @nodoc */
CATVizViewModesFeedback ExportedBySGInfra CATVizValidateRepFilterViewerViewMode(const int iViewerViewMode, const int iRepViewMode);
//IR-513914-
/** @nodoc */
void ExportedBySGInfra CATVizGetIncompatibleAndRemovedViewModes(const int iToBeChekedVM, const int iCurrentVM, int & oIncompatibleVM, int & oRemovedVM);
//-----------------------------------------------------------------------

#endif
