//===================================================================
// COPYRIGHT Dassault Systemes 2019/12/19
//===================================================================
// CATPolyMeshVertexKDTree.cpp
// Header definition of class CATPolyMeshVertexKDTree
//===================================================================
//
// Usage notes:
//
// I (DGE2) developed this in 2019 for the prototype of a Boolean Operator.
// It was coded with performances in mind (time and memory-wise), to be built, updated and queried as fast as possible,
// while not being too naive when it comes to node subdivision.
// There aren't many functionalities, but feel free to expand them.
//
//===================================================================
//  2019/12/19 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATPolyMeshVertexKDTree_H
#define CATPolyMeshVertexKDTree_H

#include "CATPolyGriddingTools.h"

// PolyhedralOperators
#include "CATPolyVertexKDTree.h"

// PolyhedralInterfaces
#include "CATIPolyMeshObserver.h"

// System
#include "CATErrorDef.h"

class CATIPolyMesh;
class CATIPolySurfaceVertexPositionConstLayer;

/**
* A KD-Tree for CATIPolyMesh vertices.
* It automatically tries to stay up to date with mesh updates.
*/
class ExportedByCATPolyGriddingTools CATPolyMeshVertexKDTree
{
public:

  /**
  * @brief Main constructor. Do not forget to call Initialize !
  */
  CATPolyMeshVertexKDTree (CATIPolyMesh& iMesh);

  ~CATPolyMeshVertexKDTree ();

  /**
  * @brief Sets the maximum number of vertices allowed in one leaf.
  * Leaves may occasionally contain more vertices than that, if there are too many coincident vertices.
  * Default value is set to 30.
  */
  void SetMaxNumberOfVerticesInLeaf (const unsigned int iMaxNbVerticesPerLeaf) { _Tree.SetMaxNumberOfVerticesInLeaf(iMaxNbVerticesPerLeaf); }

  /**
  * @brief Sets the number of threads used during initialization and update of the KD-tree.
  * Default value is 1 (monothreaded behavior).
  * To be called before Initialize.
  */
  void SetNumberOfWorkers (const unsigned int iNbWorkers) { _Tree.SetNumberOfWorkers(iNbWorkers); }

  /**
  * @brief Initializes the tree with all vertices of the mesh and setups the observer.
  */
  HRESULT Initialize ();

public:

  /**
  * @brief Gather all vertices closer than iRadius from iCenter in oVertices.
  * @param oVertices : array of all vertices in the sphere, with the square distance to its center for all of them.
  */
  HRESULT GetVerticesInSphere (const CATMathPoint& iCenter, const double iRadius, std::vector<std::pair<int, double>>& oVertices) const;

  /**
  * @brief Gets the closest vertex closer than iRadius from iCenter in oVertex, or zero otherwise.
  */
  HRESULT GetClosestVertexInSphere (const CATMathPoint& iCenter, const double iRadius, int& oVertex) const;

  /**
  * This method is used to navigate the tree and call user-defined methods on its chosen leaves.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a visited node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * The arguments to GetSides provide the dimension (0, 1 or 2) and threshold of the splitting plane for the current node.
  * @tparam Visitor : the object on which the method iCall is called for each visited leaf of the tree.
  * @tparam Call : the method type of the method called on iVisitor on leaves of the tree. It must have signature :
  * HRESULT Call(const Vertex* ipVertices, const unsigned int iNbVertices, Args... iArgs)
  * @tparam Args : remaining arguments of the method iCall beside the vertices in the visited leaf and the number of them.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT Traverse (Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

private:

  /**
  * The updater trying to keep the KD-Tree up to date.
  * Remember that the updater does not try to subdivide leaves.
  * Also, due to the way CATIPolyMeshObserver works, we cannot react to the update of the position of a vertex,
  * because the interface does not provide us with the old position of the vertex.
  */
  class Updater : public CATIPolyMeshObserver
  {
  public:

    Updater (CATPolyMeshVertexKDTree& iKDTree) : _KDTree (iKDTree) {}

    HRESULT ReactToAddVertex (int v) override;

    HRESULT PrepareToRemoveVertex (int v) override;

  private:

    CATPolyMeshVertexKDTree& _KDTree;
  };

private:

  inline CATIPolySurfaceVertexPositionConstLayer* PositionLayer () const { return _pPositionLayer; }

private:

  CATIPolyMesh& _Mesh; //!< The mesh the grid is describing.
  CATIPolySurfaceVertexPositionConstLayer* _pPositionLayer; //!< Position layer of the mesh.
  Updater* _pUpdater; //!< Observer on the overlay used to maintain the voxel grid up to date.

  CATPolyVertexKDTree<int> _Tree; //!< The KD-Tree.
};

#endif
