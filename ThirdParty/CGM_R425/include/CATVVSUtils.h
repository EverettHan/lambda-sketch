/**
* @level Private
* @usage U1
*/
//===================================================================
// COPYRIGHT Microsoft 2012/04/05
//===================================================================
// CATVVSUtils.cpp
// Header definition of class CATVVSUtils
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2012/04/05 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATVVSUtils_H
#define CATVVSUtils_H

// System
#include "CATUnicodeString.h"
#include "CATUuid.h"
// CATVirtualVaultSystem
#include "CATListOfCATVVSUrl.h"
#include "VVSUtils.h"
#include "CATOmxArray.h"
#include "CATVVSUrl.h"
#include "CATVVSURLConnection.h"
#include "CATVVSStreamSize.h"
#include "CATVVSStreamSizes.h"
#include "CATVVSUtils.h"

#define USE_CATVVSUTILS_COUNTER_2 1

typedef CATUuid CATVVSAsyncID;

namespace VVS
{
  CATUnicodeString ExportedByVVSUtils Uuid2Ucs(const CATUuid& iUuid);
  CATLONG64        ExportedByVVSUtils Kbyte2Byte(unsigned int iSizeInKb);
  unsigned int     ExportedByVVSUtils Byte2Kbyte(CATLONG64 iSizeInByte);
  HRESULT          ExportedByVVSUtils GetSizeOfConnection(CATVVSURLConnection& iConnection, DWORD iFlag, CATLONG64& oSizeInByte);

  CATOmxArray<CATVVSUrl> ExportedByVVSUtils Sys2Omx_Urls(const CATListOfCATVVSUrl& iSysList);

  template<typename T>
  HRESULT GetSizeOfSingleStream(const CATVVSUrl& iUrl, DWORD iFlag, CATVVSStreamSizes& oStreamSizes, const T* iConnectionManager)
  {
    T* pPtr = const_cast<T*>(iConnectionManager);
    if ((NULL == pPtr) || oStreamSizes.Size() != 0) return E_INVALIDARG;

      CATVVSURLConnection Connection;
      HRESULT HRLoop = pPtr->OpenConnection(iUrl, Connection);

      CATLONG64 SizeinByte = 0;
      if (SUCCEEDED(HRLoop))
        HRLoop = VVS::GetSizeOfConnection(Connection, iFlag, SizeinByte);
      if (SUCCEEDED(HRLoop))
        oStreamSizes.PutStreamSize(new CATVVSStreamSize(SizeinByte, iUrl, TRUE));

    HRESULT HR = E_FAIL;
    if (1 == oStreamSizes.Size())
      HR = S_OK;
    return HR;
  }

  template<typename T>
  HRESULT GetSizeOfStreams(CATListOfCATVVSUrl& iUrls, DWORD iFlag, CATVVSStreamSizes& oStreamSizes, const T* iConnectionManager)
  {
    T* pPtr = const_cast<T*>(iConnectionManager);
    if ((NULL == pPtr) || oStreamSizes.Size() != 0) return E_INVALIDARG;
    int NbofElem = iUrls.Size();
    for (int i = 1; i <= NbofElem; i++)
    {
      if (!iUrls[i]) continue;
      CATVVSUrl CurUrl = *(iUrls[i]);

      CATVVSURLConnection Connection;
      HRESULT HRLoop = pPtr->OpenConnection(CurUrl, Connection);

      CATLONG64 SizeinByte = 0;
      if (SUCCEEDED(HRLoop))
        HRLoop = VVS::GetSizeOfConnection(Connection, iFlag, SizeinByte);
      if (SUCCEEDED(HRLoop))
        oStreamSizes.PutStreamSize(new CATVVSStreamSize(SizeinByte, CurUrl, TRUE));
    }
    HRESULT HR = E_FAIL;
    if (NbofElem == oStreamSizes.Size())
      HR = S_OK;
    else if (oStreamSizes.Size() > 0)
      HR = S_FALSE;
    return HR;
  }
}


struct CATVVSAsyncObject
{
  CATVVSAsyncObject(CATBoolean iMD5ToBeCheckedByFCS) : MD5ToBeCheckedByFCS(iMD5ToBeCheckedByFCS)
  {}
  CATVVSAsyncID TaskID;
  CATUuid       TransactionID;
  IUnknown* CallBack;
  CATBoolean    MD5ToBeCheckedByFCS;
};

//-----------------------------------------------------------------------

class ExportedByVVSUtils CATVVSUtils
{
  //friend class xMQLQueryFilter;//for use of void _SetTraceCounter(CATUINT32 iCounter);

  static CATUnicodeString _NewDirectoryPath;
  static CATBoolean _IsNewDirectoryPathSet;
  static CATUINT32 _TraceCounter;
  static CATBoolean _StopIncrement;
  CATVVSUtils();

public:
  CATUnicodeString _NRCDir;
  CATBoolean _IsNRCSet;

  CATUnicodeString _NRCWithStreamDir;
  CATBoolean _IsNRCWithStreamDirSet;

  CATUnicodeString _InvalidNRCDir;

  static const CATVVSUtils& s();

  /*
  * Delete a file hardlink.
  * The method succeeds if the file is read only.
  * If at least one hardlink of the same file remains after the hardlink deletion, the file is not deleted.
  * In such case, if the file is RO, it remains RO.
  *
  * @param iFilePath : the hardlink path
  * @returns S_OK if the hardlink is deleted
  *          E_FAIL otherwise
  */
  static HRESULT DeleteHardLink(const CATUnicodeString& iFilePath);

  /*
  * Check if new directory is set.
  * @returns TRUE if directory is set
  *          FALSE if directory is not set
  */
  static CATBoolean IsNewDirectoryPathSet();

  /*
  * Return the trace directory path.
  *
  * This method assumes that the variable NetRecordCapture is exported and contains a valid path.
  * If the variable is not exported, the method return E_FAILS.
  *
  * @param oNewDir : the new directory path
  * @returns S_OK if the new directory path is accessible
  *          E_FAIL otherwise
  */
  static CATUnicodeString GetNewDirectoryPath();

  /*
  * Return the trace directory path.
  *
  * This method assumes that the variable NetRecordCapture is exported and contains a valid path.
  * If the variable is not exported, the method return E_FAILS.
  *
  * @param oNewDir : the new directory path
  * @returns S_OK if the new directory path is accessible
  *          E_FAIL otherwise
  */
  static HRESULT GetNewDirectoryPath(CATUnicodeString& oNewDir);

  /*
   * Set the new directory path.
   *
   * This method sets the new directory path to iNewDir.
   * If iNewDir is not a valid path, E_FAIL is returned
   *
   * @param iNewDir : the new directory path
   * @returns S_OK if the new directory path is accessible
   *          E_FAIL otherwise
   */
   static HRESULT SetNewDirectoryPath(const CATUnicodeString& iNewDir, CATBoolean iCreateDirectory = FALSE);

   static CATUINT32 GetTraceCounterAsUInt32(CATBoolean iIncrement);

  static CATUnicodeString GetTraceCounter(CATBoolean iIncrement, CATUINT32& oCounter);
  static CATUnicodeString GetTraceCounter(CATBoolean iIncrement);

  static CATUnicodeString StreamCounter(CATUINT32 iCounter);
  static CATUnicodeString GetTraceNameSuffix();
  static CATUnicodeString StopIncrementForCompare() { _StopIncrement = TRUE; CATUINT32 temp; return GetTraceCounter(FALSE, temp); }
  static CATUnicodeString ResumeIncrementForCompare() { _StopIncrement = FALSE; CATUINT32 temp; return GetTraceCounter(FALSE, temp); }

  static void InitCaptureSrv(CATUnicodeString& iDumpDirPath,
    CATUnicodeString& mappingFileName);

  static void setMappingFile(CATUnicodeString& iFilePath);

  static void setStreamDumpDir(CATUnicodeString& idumpDirPath);

  static HRESULT DumpUrlsAndStreams(const CATListOfCATVVSUrl& iFromUrlList,
    const CATListOfCATVVSUrl& iToUrlList,
    CATBoolean iIsCheckOut);
  static HRESULT DumpUrlsAndStreams(const CATOmxArray<CATVVSUrl>& iFromUrlList,
    const CATOmxArray<CATVVSUrl>& iToUrlList,
    CATBoolean iIsCheckOut);

  static HRESULT _getFileName(CATUnicodeString& iPath, CATUnicodeString& oFileName);

  static HRESULT getStreamDirectory(CATUnicodeString& iProcessorName, CATUnicodeString& oStreamDir);

  static HRESULT ExpandPath(CATUnicodeString* ioPath);

private:
  //static void _SetTraceCounter(CATUINT32 iCounter);

  static HRESULT _dumpURLMAndStreams(const CATOmxArray<CATVVSUrl>& ifcsUrlList,
    const CATOmxArray<CATVVSUrl>& ifileURLList,
    CATBoolean idoFileCapture);
  static HRESULT _dumpStreams(const CATOmxArray<CATVVSUrl>& ifcsUrlList,
    const CATOmxArray<CATVVSUrl>& ifileURLList,
    CATListOfCATUnicodeString& oCpfileURL,
    CATBoolean idoFileCapture);

  static HRESULT GetRealPathLnk(const CATUnicodeString* iLogicalPath, CATUnicodeString** oPhysicalPath, void** mode);

  static CATUnicodeString _mappingFilePath;
  static CATUnicodeString _streamDumpDir;

};

//-----------------------------------------------------------------------

#endif
