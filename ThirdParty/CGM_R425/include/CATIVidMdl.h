//===================================================================
// COPYRIGHT DASSAULT SYSTEMES 2011/06/07
//===================================================================
// CATIVidMdl.h
// Header definition of class CATIVidMdl
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2011/06/07 Creation: Code generated by the 3DS wizard  VV6
//===================================================================
#ifndef CATIVidMdl_H
#define CATIVidMdl_H

#include <VisuDialog.h>
#include <CATListOfCATUnicodeString.h>
#include <CATBaseUnknown.h>
#include <CATBoolean.h>
#include <CATSYPArray.h>
#include <CATVidMdlIndex.h>
#include <CATISYPIntrospectable.h>
#include <CATVid.h>
#include <CATVidDnD.h>
#include <CATUnicodeString.h>

class CATVidCtlAbstractItemsView;
class CATVidAbstractCloneProvider;

class CATVidMdlEventEmitter;

extern ExportedByVisuDialog  IID IID_CATIVidMdl;


/** @ingroup groupVidModelView
 * @defgroup groupVidModelViewModel Model Components
 *
 * The <b>Model Components</b> sub-module groups the classes used to define a
 * model of data. The main goal of a model (model in the sense of the CID model
 * view architecture) is to provide an abstraction to make uniform the way of
 * how a data element is retrieved from a data source. Thus, a CID view
 * component is able to communicate with the model to retrieve data items to
 * display them.
 *
 * @par Using a basic model
 * CID provides by default some basic implementations of model that let you
 * define some data elements to be displayed by a view component. Currently,
 * there is a basic implementation of a model for a list based model called
 * CATVidMdlStandardList. This component is a model of list that stores all
 * the data items that can be displayed by a list view.
 * The following code snippet shows how the create a list based model and
 * populate it with some data items:
 *
 * @par
 * @code
 * CATVidMdlStandardList * pModelList = new CATVidMdlStandardList;
 * if (pModelList)
 * {
 *    pModelList->Append(new DataItem("Object number 1"));
 *    pModelList->Append(new DataItem("Object number 2"));
 *    pModelList->Append(new DataItem("Object number 3"));
 *    pModelList->Append(new DataItem("Object number 4"));
 *    pModelList->Append(new DataItem("Object number 5"));
 *    pModelList->Append(new DataItem("Object number 6"));
 * }
 * @endcode
 *
 * @par
 * The model is created using the new operator and then some data elements
 * are inserted into it using the Append member function. For the purpose of
 * the example, DataItem is an introspectable object. This is mandatory to be
 * able to build its view.
 *
 *
 * @par Reference your data items
 * To abstract the way how your data items are retrieved from a data source,
 * a model must be able to reference a particular data item contained inside
 * the data source. This behavior is implemented by the CATVidMdlIndex class.
 * CATVidMdlIndex is a kind of generalization of the concept of pointer: a
 * CATVidMdlIndex is able to point to a data item stored inside a data source.
 * To cover a wide variety of model designs, a CATVidMdlIndex references a
 * data items using four elements:
 *    - a row number
 *    - a column number
 *    - an internal pointer on the item
 *    - a model
 *
 * @par
 * For example, for a list based model, only the row number and the model
 * attributes are relevant. However, for a tree based model, the row number,
 * internal pointer and model attributes are useful to identify a data item.
 * The following code snippet shows how to reference a data item stored inside
 * a list model using a CATVidMdlIndex:
 *
 * @par
 * @code
 * // Build the model
 * CATVidMdlStandardList * pModelList = new CATVidMdlStandardList;
 * if (pModelList)
 * {
 *    pModelList->Append(new DataItem("Object number 1"));
 *    pModelList->Append(new DataItem("Object number 2"));
 *    pModelList->Append(new DataItem("Object number 3"));
 *    pModelList->Append(new DataItem("Object number 4"));
 *    pModelList->Append(new DataItem("Object number 5"));
 *    pModelList->Append(new DataItem("Object number 6"));
 * 
 *
 *    // Retrieve a CATVidMdlIndex on the first element
 *    CATVidMdlIndex firstIdx = pModelList->CreateIndex(0, 0, CATVidMdlIndex());
 *    // firstIdx points to the data element identified by the string
 *    // "Object Number 1"
 *
 *    // Retrieve a CATVidMdlIndex on the third element
 *    CATVidMdlIndex thirdIdx = pModelList->CreateIndex(2, 0, CATVidMdlIndex());
 *    // thirdIdx points to the data element identified by the string
 *    // "Object Number 3"
 * }
 * @endcode
 *
 * @par
 * To create a model index associated to a model, you can use the CreateIndex
 * member function of a model specifying the row number, column number and
 * parent element to reference it.
 *
 *
 * @par Implementing your own model
 * If the basic implementation of a model doesn't suit your needs, you can
 * implement your own model thanks to the CATIVidMdl interface. By implementing
 * it, you are able to define how your data source must communicate with the
 * CID view components. To implement CATIVidMdl, you need to use the
 * CATVidMdlAdapter adapter class.
 *
 * @par Drag-and-drop
 * When drag-and-drop is activated on a view of your model, by default, all
 * items can be dragged and all items are susceptible of accepting drops. 
 * 
 * To disallow some items to be dragged:
 * @li If your data is of type data-block, simply add a @c DragEnabledFlag of 
 * type int on the data-block of your item and set it to @c 0. On that case, 
 * you will not receive indexes of those items through 
 * @ref CATIVidMdl#ExportDataFromItems. 
 * @li Else, implement rejection of undraggable items by skimming them in 
 * an override of @ref CATIVidMdl#ExportDataFromItems.  
 *
 * Similarly, to disallow some items to accept drops:
 * @li If your data is of type data-block, simply add a @c DropEnabledFlag of 
 * type int on the data-block of your item and set it to @c 0. On that case, 
 * the drag-and-drop infrastructure will not call you on 
 * @ref CATIVidMdl#CanDropData if this item is hovered during drag-and-drop. 
 * @li Else, implement rejection of the drop over a specific item by 
 * overriding the default @ref CATIVidMdl#CanDropData.
 */


/** @ingroup groupVidModelViewModel
 * Base interface for CID models (like list or tree based models for example).
 *
 * This interface is intented to be used as an object modeler inheritance.
 * Some adaptors exist for this interface that ease the implementation
 * in the case of a list for example.
 *
 * A CID model ensures the communication between a user defined data source
 * and the view component that must displays the items of the data source.
 * A model item is referenced using a CATVidMdlIndex object.
 *
 * Note: elements of a CID model are manipulated using 0-based index.
 * Be careful when using an underlying collection that is not 0-based indexed
 * to convert properly the index value inside the implementation.
 *
 * Before implementing your own model by using this interface, you can consider
 * to directly use a provided implementation by CID such as CATVidMdlStandardList
 * or CATVidMdlStandardTree depending on your needs. 
 *
 * You can also consider to derive from adapters and reimplement only few methods.
 * This is the case for dynamic model adapters such as CATVidMdlCacheTreeAdapter and 
 * CATVidMdlDynamicTreeAdapters.
 */
class ExportedByVisuDialog CATIVidMdl : public CATBaseUnknown
{
CATDeclareInterface;
public:
  /**
   * Indicates whether the given row number, column number and parent index
   * can reference a valid item stored into this model.
   *
   * @param i_row the row number to use for testing whether the 
   * item exists or not.
   * @param i_column the column number to use for testing whether
   * the item exists or not.
   * @param i_parent the parent index to use for testing whether the item
   * exists or not.
   * @return 0 if no item exists at this location, 1 otherwise.
   */
  virtual int HasIndex(int i_row, int i_column, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Creates a new index that references the item located by the given row, column and
   * parent.
   * Use CreateIndex rather than the index constructor in order to make sure to
   * work with consistant indexes.
   *
   * @param i_row the row number that references the item for which an index is
   * requested.
   * @param i_column the column number that references the item for which an
   * index is requested.
   * @param i_parent the index that points to the parent of the item specified for which an
   * index is requested.
   * @return the model index of the item specified by the given parameter if it
   * exists inside the model or, otherwise, an invalid index.
   */
  virtual CATVidMdlIndex CreateIndex(int i_row, int i_column, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Recovers the parent model index for the given index.
   * @param i_index the index of the item to look for its parent.
   * @return the index of the parent of the element referenced by i_index if it
   * exists, or an invalid index otherwise.
   */
  virtual CATVidMdlIndex GetParent(const CATVidMdlIndex & i_index) = 0;
  /**
   * Retrieves an index on the element located at i_row rows and i_column columns and that shares
   * the same parent as the given i_index.
   *
   * @param i_row the row number at which the element looked for is located.
   * @param i_column the column number at which the element looked for is located.
   * @param i_index the index for which a sibling is looked for.
   * @return an index on the siblingof the item pointed by i_index if it exists,
   * or otherwise and invalid index.
   */
  virtual CATVidMdlIndex GetSibling(int i_row, int i_column, const CATVidMdlIndex & i_index) = 0;
  /**
   * Indicates whether the given item pointed by i_index has at least one child.
   *
   * @param i_index the index of the item to look for children.
   * @return 1 if the item has at least one child, 0 otherwise.
   */
  virtual int HasChildren(const CATVidMdlIndex & i_index) = 0;
  /**
   * Retrieves the number of columns contained for the given i_index.
   *
   * @param i_index the index that references the item for which the column number
   * is requested.
   * @return the column number for the given item referenced by i_index.
   */
  virtual int GetColumnCount(const CATVidMdlIndex & i_index) = 0;
  /**
   * Retrieves the number of rows for the given i_index.
   *
   * @param i_index the index that references the item for which the row number
   * is requested.
   * @return the row number for the given item referenced by i_index.
   */
  virtual int GetRowCount(const CATVidMdlIndex & i_index) = 0;
  /**
   * --- DEPRECATED --- To migrate.
   *
   * @note Use GetRowCount
   */
  virtual int GetRowNumber(const CATVidMdlIndex & i_index) = 0;
  /**
   * Inserts a new empty row into the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_row the row number after which a new row is inserted.
   * @param i_parent an index on the parent element of the item that receives
   * the new row.
   * @return TRUE if the row has been successfully inserted, FALSE otherwise.
   */
  virtual CATBoolean InsertRow(int i_row, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Inserts a new empty column into the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_column the column number after which a new column is inserted.
   * @param i_parent an index on the parent element of the item that receives
   * the new column.
   * @return TRUE if the column has been successfully inserted, FALSE otherwise.
   */
  virtual CATBoolean InsertColumn(int i_column, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Removes a given row from the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_row the row number to remove.
   * @param i_parent an index on the parent element of the item from which the
   * row is removed.
   * @return TRUE if the row has been successfully removed, FALSE otherwise.
   */
  virtual CATBoolean RemoveRow(int i_row, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Removes a given column from the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_column the column number to remove.
   * @param i_parent an index on the parent element of the item from which the
   * column is removed.
   * @return TRUE if the column has been successfully removed, FALSE otherwise.
   */
  virtual CATBoolean RemoveColumn(int i_column, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Removes the given list of indexes from the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * Note that for several columns models, entire row are removed if at least an index is given as input!!!!
   * No management of model with holes...
   *
   * i_listOfIndexes items must have same parent index!!!
   *
   * @param i_listOfIndexes the list of indexes to remove.
	 * @param i_updateAfterInsertion a boolean specifying if view need to be updated after remove.
   * @return TRUE if the list of indexes has been successfully removed, FALSE otherwise.
   */
  virtual CATBoolean RemoveList(const CATSYPDynArray<CATVidMdlIndex> & i_listOfIndexes, CATBoolean i_updateAfterInsertion = TRUE) = 0;
  /**
   * Removes the given index from the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_index the index to remove.
   * @return TRUE if the index of indexes has been successfully removed, FALSE otherwise.
   */
  virtual CATBoolean RemoveItem(const CATVidMdlIndex & i_index) = 0;
  /**
   * Retrieves the element corresponding to i_index from the model.
   *
   * @param i_index the index on the element to retrieve.
   * @returns the corresponding element if the index is valid and
   * references an element of the model, otherwise, returns NULL_var.
   */
  virtual CATBaseUnknown_var GetElement(const CATVidMdlIndex & i_index) = 0;
  /**
   * Build an introspectable item (e.g. a data block) from an element of the model
   * containing the properties to display (label, icon, ...).
   *
   * @param i_item the CATBaseUnknown_var item to build an introspectable item from.
   * @return an introspectable item containing the properties of i_item.
   */
  virtual CATISYPIntrospectable_var GetIntrospectable(const CATBaseUnknown_var & i_item) = 0;
  /**
   * Sets an element in a particular location into the model.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_index the index corresponding to the location at which the new
   * element is set.
   * @param i_value the element to insert into the model at the given index.
   * @returns TRUE if the element is correctly set, otherwise FALSE.
   */
  virtual CATBoolean SetElement(const CATVidMdlIndex & i_index, const CATBaseUnknown_var & i_value) = 0;
  /**
   * Inserts the item referenced by i_fromIndex at the i_row position of the given i_toIndex.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   * If the item to insert already has a parent, it is removed from its previous hierarchy.
   *
   * @param i_toIndex the index corresponding to the location at which the new
   * item is inserted.
   * @param i_fromIndex the index that reference the item to insert into the model.
   * @param o_pResultingIndex the position of the inserted item after insertion.
   *
   * @returns TRUE if the item is correctly inserted, otherwise FALSE.
   */
  virtual CATBoolean InsertItem(int i_row, const CATVidMdlIndex & i_toIndex, const CATVidMdlIndex & i_fromIndex, CATVidMdlIndex * o_pResultingIndex = NULL) = 0;
  /**
   * Appends the item referenced by i_fromIndex to the given i_toIndex.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   * If the item to append already has a parent, it is removed from its previous hierarchy.
   *
   * @param i_index the index corresponding to the location to which the new
   * element is appended.
   * @param i_fromIndex the index that reference the item to append into the model.
   * @param o_pResultingIndex the position of the appended item after insertion.
   *
   * @returns TRUE if the item is correctly appended, otherwise FALSE.
   */
  virtual CATBoolean AppendItem(const CATVidMdlIndex & i_toIndex, const CATVidMdlIndex & i_fromIndex, CATVidMdlIndex * o_pResultingIndex = NULL) = 0;
  /**
   * Clone an part of the model and insert the clone in a model.
   *
   * @param i_row the row where the clone must be inserted.
   * @param i_toIndex the parent index under which the clone must be inserted.
   * @param i_fromIndex index pointing on the submodel to clone. The item 
   * pointed by this index will be duplicated with all its complete children
   * lineage.
   * @param o_pResultingIndex the position of the inserted item after insertion.
   *
   * @return @c TRUE if the insertion succeeded, @c FALSE else.
   */
  virtual CATBoolean InsertItemClone(int i_row, const CATVidMdlIndex & i_toIndex, const CATVidMdlIndex & i_fromIndex, CATVidMdlIndex * o_pResultingIndex = NULL) = 0;
  /**
   * Clone an part of the model and append the clone in a model.
   *
   * @param i_toIndex the parent index under which the clone must be appended.
   * @param i_fromIndex index pointing on the submodel to clone. The item 
   * pointed by this index will be duplicated with all its complete children
   * lineage.
   * @param o_pResultingIndex the position of the appended item after insertion.
   *
   * @return @c TRUE if the appending succeeded, @c FALSE else.
   */
  virtual CATBoolean AppendItemClone(const CATVidMdlIndex & i_toIndex, const CATVidMdlIndex & i_fromIndex, CATVidMdlIndex * o_pResultingIndex = NULL) = 0;
  /**
   * Appends the given list of items to the given i_parent.
   * In case of a read-only model, this method must return FALSE without doing
   * anything.
   *
   * @param i_parent the index corresponding to the parent element to which the new
   * elements are appended.
   * @param i_listOfItems the list of items to append into the model.
   * @returns TRUE if the items are correctly appended, otherwise FALSE.
   */
  virtual CATBoolean AppendList(const CATSYPDynArray<CATBaseUnknown_var> & i_listOfItems, const CATVidMdlIndex & i_parent) = 0;
  /**
   * Get the index of the root element for the column i_Column.
   *
   * @return the CATVidMdlIndex of the root element of the model.
   */
  virtual CATVidMdlIndex GetRoot(int i_Column = 0) = 0;
  /**
   * Resets the content of the model by removing all the elements contained
   * and by reducing its dimension to 0 row, and 0 column.
   */
  virtual void Reset() = 0;
  /**
   * Updates the model by sending an event to inform the view that the model has changed
   * and needs to be updated.
   *
   * @param i_parent the parent index of the part of the model to update (default : root index).
   *
   * @note if reimplemented, do not forget to call CATVidMdlAdapter::Update() method.
   */
  virtual void Update(const CATVidMdlIndex & i_parent = CATVidMdlIndex()) = 0;
  
  
  virtual void PartialUpdate(const CATVidMdlIndex & i_parent = CATVidMdlIndex(), CATSYPDynArray <CATVidMdlIndex> * ipChildIndexToUpdateList = NULL, CATListOfCATUnicodeString * iColumnIDs = NULL ) = 0;
   
  /**
   * Hasher method used by the view.
   * By default, this method use the value of the pointer on the user object.
   *
   * @param i_key the index to hash.
   *
   * @return The hashcode value for the given index.
   *
   * @note redefine this method only if you use different instances to represent a single 
   * data element of your model.
   * @see CATVidMdlDirectoryBrower#ComputeHash
   */
  virtual int ComputeHash(const CATVidMdlIndex &i_key) = 0;
  /**
	 * Deprecated. Prefer use of AreEquals which is less time consuming.
   * Compares two data items.
   *
   * @param i_obj1 the first data item to compare.
   * @param i_obj2 the second data item to compare.
   *
   * @return TRUE if i_obj1 and i_obj2 reference the same data item, otherwise FALSE.
   *
   * @note in the case of a dynamic model, you can redefine this method in order to be able to
   * compare two different instances of the same data element of your model 
   * (e.g. if GetChild or GetChildren method returns one or several new introspectable objects).
   */
  virtual CATBoolean IsEqual(const CATBaseUnknown_var & i_obj1, const CATBaseUnknown_var & i_obj2) = 0;
  /**
   * Compares two data items.
   *
   * @param i_obj1 the first data item to compare.
   * @param i_obj2 the second data item to compare.
   *
   * @return TRUE if i_obj1 and i_obj2 reference the same data item, otherwise FALSE.
   *
   * @note in the case of a dynamic model, you can redefine this method in order to be able to
   * compare two different instances of the same data element of your model 
   * (e.g. if GetChild or GetChildren method returns one or several new introspectable objects).
   */
  virtual CATBoolean AreEquals(CATBaseUnknown * i_obj1, CATBaseUnknown * i_obj2) = 0;

  /**
   * Used internally, do not redefined.
   */
  virtual CATBoolean _IsEqual(const CATVidMdlIndex & i_left, const CATVidMdlIndex & i_right) = 0;
  /**
   * Returns the type of the model used in ModelView.
   *
   * @returns the type of the model used in ModelView.
   */
  virtual CATVid::ModelType GetModelType() = 0;
  /**
   * Associate the given control to this model. So, the given control will
   * display the view and will be updated when modifications will append to
   * the model.
   */
  virtual void AssociateToView(CATVidCtlAbstractItemsView *) = 0;
  /**
   * Separate the given control to this model. So, the given control will no
   * longer display this model and will not be warmed by events coming from
   * this model.
   */
  virtual void SeparateFromView(CATVidCtlAbstractItemsView * i_pView) = 0;
  /**
   * Returns the emitter of all the model events.
   * @c AddRef has been called on the returned pointer so the caller must @c Release it.
   */
  virtual CATVidMdlEventEmitter * GetEventEmitter() const = 0;
  /**
   * Creates a data container from the list of indexes of all items that have
   * been dragged on drag-and-drop, ie. all items currently selected that are
   * draggable.
   *
   * @param i_indexes indexes of the items dragged.
   * 
   * @return the data contained. By default, a @c CATVidMdlDnDData containing
   * the list of dragged indexes.
   */
  virtual CATVidDnDData * ExportDataFromItems(const CATSYPDynArray<CATVidMdlIndex> & i_indexes) = 0;
  /**
   * @par
   * To be used as a callback of @c CATVidCtl#CanImportData by views. Called
   * on move over during drag-and-drop in a view, unless the drag-and-drop
   * infrastructure is able to determine by itself that the data cannot be 
   * dropped.
   * @par
   * Determines wether some dragged data can be dropped inside the model at a 
   * given position. 
   * @par
   * The input position may be corrected from the actual
   * position of the mouse by the view, depending on the state of the view. 
   * For exemple, in a tree view, if a source item must be inserted after an 
   * expanded target item, the index and location received will correspond to 
   * the first child of the target item and @ref CATVidDnD#DropBefore (instead 
   * of the target item and @c CATVidDnD#DropAfter).
   *
   * @param i_pData the data dragged over a view.
   * @param i_effect the current drop effect.
   * @param i_index the index pointing to the item where the drop would
   * happen if the mouse were release at its current position in the view. Most
   * of the time, the index corresponding to the item view currently hovered.
   * The rest of the time, a corrected position calculated by the view in
   * coordination with @c i_location. 
   * @param i_location the location inside the item view to consider if a drop
   * happened at this position. Most of the time, the location of the mouse
   * inside the currently hovered item view. The rest of the time, a
   * corrected position calculated by the view in coordination with 
   * @c i_location.
   *
   * @return @c TRUE if the data can be dropped, @c FALSE else.
   *
   * @see CATVidCtl#CanImportData
   */
  virtual CATBoolean CanDropData(CATVidData * i_pData, CATVidDnD::Effect i_effect, const CATVidMdlIndex & i_index, const CATVidDnD::DropLocation & i_location) = 0;
  /**
   * @par
   * To be used as a callback of @c CATVidCtl#ImportData by views. Called
   * once on drop if @ref CanDropData is successful.
   * @par
   * Imports the dragged data inside the model.
   *
   * @param i_pData the dragged data.
   * @param i_effect the drop effect to apply.
   * @param i_index the index of the item where the drop occured (or 
   * corrected index calculated by the view in coordination with 
   * @c i_location, see @ref #CanDropData).
   * @param i_location the location of drop inside the item view (or 
   * corrected location calculated by the view in coordination with 
   * @c i_index, see @ref #CanDropData).
   *
   * @return @c TRUE if the data can be dropped, @c FALSE else.
   *
   * @see #CanDropData
   * @see CATVidCtl#ImportData
   */
  virtual CATBoolean DropData(CATVidData * i_pData, CATVidDnD::Effect i_effect, const CATVidMdlIndex & i_index, const CATVidDnD::DropLocation & i_location) = 0;
  /**
   * Defines a drop location inside the model when a drop happen on the 
   * viewport of a view instead than over view items. The model will do as if
   * the drop happened over the item @c o_index,  
   *
   * @param o_index the index where to drop in the model.
   * @param o_location the location where to drop inside the item corresponding
   * to @c o_index.
   */
  virtual void GetViewportDropLocation(CATVidMdlIndex & o_index, CATVidDnD::DropLocation & o_location) = 0;
  /** 
   * @return a helper able to clone an element of the model, if any.
   */
  virtual CATVidAbstractCloneProvider * GetElementCloneProvider() const = 0;
  /**
   * Sorts the model items according to the given column identifier and sort order.
   * The base class implementation does nothing. Use the proxy CATVidMdlSortFilterProxy class as
   * a source model to enable the sorting capability.
   * @see CATVidMdlSortFilterProxy
   */ 
  virtual void Sort(const CATUnicodeString& i_propertyName, CATVid::SortOrder i_sortOrder = CATVid::AscendingOrder) = 0;  
  /**
  * New method from R419. To manage insertion of row(s) in a model containing several columns (also works in single-column).  
  * @param i_listOfRows the list of rows of items you want add to the multi-columns model.
  * @param i_parent the index parent used to append the rows.(Must be valid for a standard tree, CATVidMdlIndex() for a standardlist.)
  * @param i_row the index where row is inserted. Default value is -1. An append row is done in this case.
	* @param i_updateAfterInsertion a boolean specifying if view need to be updated after insertion.
  * Warning the number of items MUST MATCH MODEL COLUMN NUMBER (GetColumnCount).
  * An assertion will occured if not.  
  *
  * Exemple : model is :   item0.0 item0.1 item0.2 item0.3 item0.4 item0.5
  *                        item1.0 item1.1 item1.2 item1.3 item1.4 item1.5 
  *                        item4.0 item4.1 item4.2 item4.3 item4.4 item4.5
  *
  *
  * We want add 2 rows "item2" and "item3" after item1.* row  :
  *
  * CATSYPDynArray<CATSYPDynArray<CATBaseUnknown_var> > ListOfRows;
  * CATSYPDynArray<CATBaseUnknown_var> ColumnsList2;
  * CATSYPDynArray<CATBaseUnknown_var> ColumnsList3;
  * 
  * for(i=0; i<5; i++)  
  *   ColumnsList2.Add(item2.i);
  *
  * for(i=0; i<5 ; i++)  
  *   ColumnsList3.Add(item3.i);
  * 
  * ListOfRows.Add(ColumnsList2);
  * ListOfRows.Add(ColumnsList3);
  *
  * CATIVidMdl * MyModel = ...;
  * CATVidMdlIndex ParentIndex = ...;
  * MyModel->InsertListOfRowsAt(ListOfRows, ParentIndex, 2);
  *
  */
  virtual CATBoolean InsertListOfRowsAt(const CATSYPDynArray<CATSYPDynArray<CATBaseUnknown_var> > & i_listOfRows, const CATVidMdlIndex & i_parent, int i_row=-1, CATBoolean i_updateAfterInsertion = TRUE)=0;
  /**
  * New method from R419. To manage insertion of column(s) in a model containing several columns (works also in single-column).
  * A root index need to exist for a standard tree to succeed with this method! (should succeed in any case with standard list.)  
  * @param i_listOfColumns the list of columns of items you want add to the multi-columns model.
  * @param i_parent the index parent used to append the columns.(Is ignored for standard tree and list.)
  * @param i_column the index where column is inserted. Default value is -1. An append column is done in this case.
	* @param i_updateAfterInsertion a boolean specifying if view need to be updated after insertion.
  * Warning the number of items MUST MATCH MODEL ROW NUMBER (GetRowCount).
  * An assertion will occured if not.
  *
  * Exemple : model is :   item0.0 item0.1 item0.2 item0.3 item0.6 item0.7
  *                        item1.0 item1.1 item1.2 item1.3 item1.6 item1.7 
  *                        item2.0 item2.1 item2.2 item2.3 item2.6 item2.7
  *
  *
  * We want insert 2 columns "item.4" and "item5" after "item*.3" column :
  *
  * CATSYPDynArray<CATSYPDynArray<CATBaseUnknown_var> > ListOfColumns;
  * CATSYPDynArray<CATBaseUnknown_var> ColumnsList4;
  * CATSYPDynArray<CATBaseUnknown_var> ColumnsList5;
  * 
  * for(i=0; i<3; i++)  
  *   ColumnsList4.Add(item4.i);
  *
  * for(i=0; i<3 ; i++)  
  *   ColumnsList5.Add(item5.i);
  * 
  * ListOfColumns.Add(ColumnsList4);
  * ListOfColumns.Add(ColumnsList5);
  *
  * CATIVidMdl * MyModel = ...;
  * CATVidMdlIndex ParentIndex = ...;
  * MyModel->AppendList(ListOfColumns, ParentIndex, 4);  
  *
  */ 
  virtual CATBoolean InsertListofColumnsAt(const CATSYPDynArray<CATSYPDynArray<CATBaseUnknown_var> > & i_listOfColumns, const CATVidMdlIndex & i_parent, int i_column=-1, CATBoolean i_updateAfterInsertion = TRUE)=0;

	/*
	* Method called to find an index matching a string (for example string built by user keyboard type). Comparison are not case sensitive.
	* This method allows, from a starting index (and navigating from first to last index), to find the first index owning an element whose given property value begins with a given string.
	*
	* Example : A list view represents a list model (CATVidMdlStandardList), owning 5 datablocks. Each datablock owns the "Name" property. Here are the 5 indexes :
	*
	* 0 : Name = "Albert"
	* 1 : Name = "Rodrigue"
	* 2 : Name = "Robert"
	* 3 : Name = "Alphonse"
	* 4 : Name = "Thomas"
	*
	* Starting from index number 1 ("Rodrigue"), if we want to find element next to "Rodrigue" beginning by "Ro", this API can be called the following way (Note that there is a single model column, so i_modelColumn value is 0) :
	*
	* CATVidMdlIndex FoundIndex;
	* FindMatchingItemFromIndex("Name", "Ro", CreateIndex(1, 0, CATVidMdlIndex()), 0, FoundIndex);
	*
	* In this case, the returned value is TRUE and FoundIndex is a CATVidMdlIndex built on 2 model row ("Robert").
	*
	* @param i_SearchedProperty : the property of index element whose value is compared to i_TypedString.
	* @param i_TypedString : the string whose we look if current element value begins with (No case sensitive).
	* @param i_StartingIndex : the CATVidMdlIndex from which we start the comparison.
	* @param i_modelColumn : model column on which indexes are searched.
	* @return TRUE if a matching index has been found (returned o_FoundIndex). 
	*/
	virtual CATBoolean FindMatchingItemFromIndex(CATUnicodeString i_SearchedProperty, CATUnicodeString i_TypedString, CATVidMdlIndex& i_StartingIndex, int i_modelColumn, CATVidMdlIndex& o_FoundIndex) = 0;

};

//-----------------------------------------------------------------------
CATDeclareHandler( CATIVidMdl, CATBaseUnknown );

#endif
