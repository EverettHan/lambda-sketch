//===================================================================
// COPYRIGHT Dassault Systemes 2017/06/19
//===================================================================
// CATOmxJsonSchema.cpp
// Header definition of class CATOmxJsonSchema
//===================================================================
//
// Usage notes:
//
// CATOmxJsonSchema can be used to load a json schema compliant with the json schema specification.
// Official specification available here: http://json-schema.org/
//
// Then the loaded schema can be used to validate a given json item, using the method Validate(yourJsonItem).
// If Validate method returns true, it means your json item is valid against the schema,
// otherwise, you can retrieve errors using GetErrors() method.
//
// Note that the validation stops at the first encountered error, which mean there may be other errors.
//
// This implementation does not support the following specifications:
//   type string: format
//   type object: dependencies
//
// CATOmxJsonSchema constructors have an optional input parameter: ipExtendedResolver
// Use this to give an extended schema resolver, for example to resolved schema in flattables, or on web.
// ipExtendedResolver lifecycle is managed by the instance.
//
//===================================================================
//
// Example:
// CATOmxJsonObject myJsonObject;
// ... initialize 'myJsonObject'
//
// bool valid = false;
// CATOmxJsonSchema mySchema(/*your schema as string, file, CATOmxJsonObject, CATOmxAny...*/);
// HRESULT hr = mySchema.Validate(myJsonObject, valid);
// ... check 'hr' and 'valid'
//
// CATOmxArray<CATUnicodeString> validationErrors;
// mySchema.GetErrors(validationErrors);
//
// for(int i = 1; i <= validationErrors.Size(); i++)
// {
//    CATUnicodeString currentError = validationErrors[i];
//    ... handle currentError
// }
//
// /* Schema with extended resolved */
// CATUnicodeString mySchemaAsString = "{}";
// CATOmxJsonSchema mySchema(mySchemaAsString, new CATPLMJsonSchemaResolver()); // CATPLMJsonSchemaResolver will be deleted on mySchema destruction
//
//===================================================================
//  2017/06/19 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATOmxJsonSchema_H
#define CATOmxJsonSchema_H

#include "CATOMY.h"
#include "CATOmxJsonObject.h"
#include "CATOmxJsonArray.h"
#include "CATOmxArray.h"
#include "CATOmxOSet.h"
#include "CATOmxJsonItem.h"
#include "CATOmxJsonSchemaResolver.h"
#include "CATOmxAutoPtr.h"

class ExportedByCATOMY CATOmxJsonSchema
{
  enum CombinedLogic
  {
    CombinedLogicNone,
    CombinedLogicAllOf,
    CombinedLogicAnyOf,
    CombinedLogicOneOf
  };

public:
  /*
  * Constructor's input parameter is the json schema as a String, JsonObject or CATOmxAny
  * ipExtendedResolver lifecycle is managed by the CATOmxJsonSchema instance.
  */
  CATOmxJsonSchema();
  CATOmxJsonSchema(const CATUnicodeString& iJsonString, CATOmxJsonSchemaResolver* ipExtendedResolver = NULL);
  CATOmxJsonSchema(const CATOmxFilePath& iFilePath, CATOmxJsonSchemaResolver* ipExtendedResolver = NULL);
  CATOmxJsonSchema(const CATOmxAny& iMap, CATOmxJsonSchemaResolver* ipExtendedResolver = NULL);
  CATOmxJsonSchema(const CATOmxJsonObject& iJsonObject, CATOmxJsonSchemaResolver* ipExtendedResolver = NULL);
  CATOmxJsonSchema(const CATOmxJsonSchema& iJsonSchema);
  CATOmxJsonSchema& operator=(const CATOmxJsonSchema& iJsonSchema);
  virtual ~CATOmxJsonSchema();

  /*
  * Returns true if the input json item is valid against the current schema.
  * Returns false otherwise. You can retrieve validation errors using GetErrors() method.
  *
  * @param iJsonItem [in]
  *   The json item to validate against the current schema
  * @param oValid [out]
  *   true if the item is valid, false otherwise. You can retrieve validation errors using GetErrors() method.
  *
  * @return
  *   <dt> <code>S_OK</code>            <dd> the json item is valid or invalid (check the output param).
  *   <dt> <code>E_INVALIDARG/code>     <dd> the schema is invalid (IsValidJsonSchema() returned false). You can retrieve validation errors using GetErrors() method.
  */
  HRESULT Validate(const CATOmxJsonItem& iJsonItem, bool& oValid);
  HRESULT Validate(const CATOmxJsonObject& iJsonObject, bool& oValid);
  HRESULT Validate(const CATOmxJsonArray& iJsonArray, bool& oValid);

  /*
  * Returns the error list of the last validation.
  * It has to be called after validation, otherwise it returns an empty array.
  * It can be used to known why the Validate method returned false.
  * Note that for schema error (if your schema is invalid) fields name begin with "schema".
  */
  void GetErrors(CATOmxArray<CATUnicodeString>& oErrors);

  /*
  * Returns true if the current schema is valid. Returns false otherwise.
  * It can be invalid:
  *   - if referenced schemas are not resolved.
  *   - if schema format is invalid: contains unknown keyword for example
  * You can retrieve validation errors using GetErrors() method.
  *
  * @return
  *   true or false
  */
  bool IsValidJsonSchema();

  /*
  * Sets the extended resolver to use during schema resolution.
  * NULL is accepted, the previous extended resolver will be removed.
  */
  void SetExtendedResolved(CATOmxJsonSchemaResolver* ipExtendedResolver);

  /*
  * Encodes this schema as a compact JSON string, such as:
  *   {"query":"Pizza","locations":[94043,90210]}
  *
  * @return
  *   The JsonObject string.
  */
  CATUnicodeString ToString();

  /*
  * Returns the hash code of the current JsonObject.
  *
  * @return
  *   the computed hash code
  */
  CATHashKey Hash() const;

  /*
  * Returns the hash code of the given JsonObject.
  *
  * @return
  *   the computed hash code or 0 if given object is NULL
  */
  static CATHashKey Hash(const CATOmxJsonSchema* ipSchema);

  /*
  * Compares the current instance with the given one.
  *
  * @return
  * Return  1 if this > other,
  *         0 if this == other,
  *        -1 if this < other.
  */
  int CompareTo(const CATOmxJsonSchema* ipSchemaOther) const;

  /*
  * Compares the two given instances.
  *
  * @return
  * Return  1 if left > right,
  *         0 if left == right,
  *        -1 if left < right.
  */
  static int Compare(const CATOmxJsonSchema* ipSchemaLeft, const CATOmxJsonSchema* ipSchemaRight);

  /*
  * Returns the valid specification schema to validate json schema.
  * The validation schema is loaded from runtimeview: resources/json/schema_validation.json
  */
  static HRESULT GetValidationSchema(CATOmxJsonSchema& oValidationSchema);

private:

  // Validation methods
  bool _Validate(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, const CATOmxJsonItem& iJsonItem);

  // Types validation
  bool _ValidateNull(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName);
  bool _ValidateBoolean(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName);
  bool _ValidateEnum(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, const CATOmxJsonItem& iItem);
  bool _ValidateJsonObject(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, CATOmxJsonObject& iJsonObject);
  bool _ValidateJsonArray(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, CATOmxJsonArray& iJsonArray);
  bool _ValidateNumeric(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, double iValue);
  bool _ValidateDouble(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, double& iValue);
  bool _ValidateLong(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, CATLONG64& iValue);
  bool _ValidateInteger(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, int& iValue);
  bool _ValidateString(CATOmxJsonObject& iSchema, CATUnicodeString& iFullPathName, CATUnicodeString& iValue);

  /*
  * Checks the given actual type is equals to one of the declared schema types.
  * Returns true if equals, false otherwise.
  * Schema "type" value can be a string (the expected type) or an array (list of expected types).
  */
  bool _ValidateType(CATOmxJsonObject& iSchema, CATOmxJsonType::Type iActualType, CATUnicodeString& iFullPathName);

  /*
  * Checks the given actual type is equal to  the given input schema type.
  * Returns true if equals, false otherwise.
  */
  bool _ValidateType(CATUnicodeString& iSchemaType, CATOmxJsonType::Type iActualType);

  /*
  * This method iterates, recursively, every given schema's properties.
  * Everytime the "$ref" key is encountered, the referenced schema is loaded.
  * If loading is successful (schema exists), it is added in _ResolvedReferencedSchemas
  * Otherwise (schema doesn't exist), it is added in _UnresolvedReferencedSchemas
  *
  * Not empty _UnresolvedReferencedSchemas leads to invalid schema.
  */
  HRESULT _ResolveReferences(CATOmxJsonObject& iJsonSchema);
  HRESULT _ResolveEmbeddedReference(CATUnicodeString& iReference);
  bool _IsReferenceEmbedded(CATUnicodeString& iReference);

  /*
  * Returns true if the schema is valid: it is compliant with json schema standard
  * Otherwise it returns false.
  * Push an error if schema is invalid.
  */
  bool _ValidateSchema();

  /*
  * Adds an error on the schema.
  * The errors can be retrieved with GetErrors.
  * An error can be:
  *   - Input json validity
  *   - Current schema validity
  *   - Validation error: input json against the schema
  */
  void _PushError(const CATUnicodeString& iError);

  /*
  * Adds error list on the schema.
  * The errors can be retrieved with GetErrors.
  * An error can be:
  *   - Input json validity
  *   - Current schema validity
  *   - Validation error: input json against the schema
  */
  void _PushErrors(const CATOmxArray<CATUnicodeString>& iErrors);

  // Attributes
  CATOmxJsonObject _RootSchema;
  CATOmxOMap<CATUnicodeString, CATOmxJsonObject> _ResolvedReferencedSchemas;
  CATOmxOSet<CATUnicodeString> _UnresolvedReferencedSchemas;
  CATOmxArray<CATUnicodeString> _ValidationErrors;
  CATOmxAutoPtr<CATOmxJsonSchemaResolver> _spExtendedResolver;

  // friends
  friend class CATPLMJsonSchemaResolver;
};

template<> CATOmxCollecManager& CATOmxDefaultCollecManager<CATOmxJsonSchema>::manager();

#endif
