//===================================================================
// COPYRIGHT Dassault Systemes 2018/03/26
//===================================================================
// CATAsyncLatency.cpp
// Header definition of class CATAsyncLatency
//===================================================================
//
// Usage notes:
//  Singleton for getting the latency
//  Model for computation : 
// Compute NetworkElapse Estimation and latency : 
//  ---------|-----------------------------|#####---------#####--------#####|----------- time -->
//           1                             2                                3
//  1-----------> RequestGenerationFinished
//  2-----------> answerParsingStartedMs
//  3-----------> answerParsingFinishedMs
//  #####-------> 1 chunck
//  sum(####)--->  chunckElapse 
//  Card(#####)-> = nbChunck

//===================================================================
//  2018/03/26 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATAsyncLatency_H
#define CATAsyncLatency_H

//CATPLMServices
#include "CATPLMxMQL.h"//ExportedBy
#include "CATA5ParserStatistics.h"

//SpecialAPI
#include "CATDataType.h"

//System
#include "IUnknown.h"
#include "CATSysBoolean.h"
#include "CATUuid.h"

//ObjectModelerCollection
#include "CATOmxSR.h"

#include <atomic>

class ExportedByCATPLMxMQL CATAsyncLatency
{
public:

  /**
  * This function add the latency and if this one is valid (positive) the computed latency will be returned by a call to 'GetLatency'
  * and 'IsLatencyAvailble' will return TRUE.
  * The latency saved in the class is : a single latency value or the mean of computed latency during now and -at most- the past 10 minutes(this time is customizable)
  * <br><b>Add a new latency</b>:
  * @return
  * <dl>
  * <dt><code>S_OK</code>    The latency has been successfully added and will be available during a call to 'GetLatency' <dd>
  * <dt><code>E_FAIL</code>
  *                           The latency is negative due to some approximations, the value is not added, the Latency could be not available or usable
  * <dd>
  * </dl>
  */
  HRESULT AddNewLatency(double iLatency);

  /**
  * Getter to the latency if Latency if it's available
  * Please use 'IsLatencyAvailable' to avoid that the function returns 'E_FAIL'
  * <br><b>Getter to the latency </b>:
  * @param oLatency
  * [out] double to get the latency
  * @return
  * <dl>
  * <dt><code>S_OK</code>
  The value returned with 'oLatency' is valid and represents :
                 - the last successfully computed latency if no latency has been computed the last past N(default :10) minutes
                 - the mean of the computed latency during -at most- the last past N(default :10) minutes
  * <dd>
  * <dt><code>E_FAIL</code>The value returned with 'oLatency' is NOT valid and represents NOTHING<dd>
  * </dl>
  */
  HRESULT GetLatency(double& oLatency);

  /**
  * Boolean to know the availability of the latency
  * <br><b>Boolean to know the availability of the latency</b>:
  * @return
  *  TRUE : the latency is avaible
  *  FALSE : it is not possible to retrieve the latency, in this case a call to 'GetLatency' will return 'E_FAIL'
  */
  bool IsLatencyAvailable();

  static CATAsyncLatency& s();

  virtual ~CATAsyncLatency();

private:
  // Copy constructor and equal operator
  // -----------------------------------
  CATAsyncLatency(CATAsyncLatency&);
  CATAsyncLatency& operator=(CATAsyncLatency&);


  CATBoolean _IsLatencyObsolete(CATLONG64 iTimeOutInMinute = 10 /*10 min*/);

  CATBoolean _ParserStatisticsAvailable;
  CATLONG64 _RequestGenerationFinished;
  std::atomic<bool> _IsLatencyAvailable;
  CATUuid _CurLatencyKey;
  std::atomic<double> _Latency;
  int _NbOfLatencyInMean;
  CATLONG64 _TimeStampBeginLatencyMean;

  CATAsyncLatency();
};

#endif
