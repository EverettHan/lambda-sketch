//===================================================================
// COPYRIGHT Dassault Systemes 2019/10/10
//===================================================================
// CATPolyTriangleKDTree.cpp
// Header definition of class CATPolyTriangleKDTree
//===================================================================
//
// Usage notes:
//
// I (DGE2) developed this in 2019 for the prototype of a Boolean Operator.
// It was coded with performances in mind (time and memory-wise), to be built, updated and queried as fast as possible,
// while not being too naive when it comes to node subdivision.
// There aren't many functionalities, but feel free to expand them.
//
// This is a template because this KD-Tree is used for CATIPolyMesh and CATPolyBody,
// and triangles cannot be represented and positions of vertices queried the same way for both.
// This template is wrapped separately for both, with observers taking care of keeping the tree up to date.
//
//===================================================================
//  2019/10/10 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATPolyTriangleKDTree_H
#define CATPolyTriangleKDTree_H

// PolyhedralOperators
#include "CATPolyBaseKDTree.h"
#include "CATPolyGriddingTools.h"

// PolyhedralMathematics
#include "CATPolyExactArithmetic.h"
#include "Poly/Set.h"
#include "Poly/TemplateUtils.h"

// Mathematics
#include "CATMathPoint.h"
#include "CATMathPoint2D.h"
#include "CATMathBox.h"
#include "CATMathFP.h"

// System
#include "CATErrorDef.h"

#include <vector>
#include <array>
#include <queue>
#include <stack>
#include <algorithm>
#include <functional>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <cfloat>

/**
* A KD-Tree for triangles.
* It was not built for ray-casting and is optimized to balance the number of triangles in each leaf.
* One triangle may be in several leaves at the same time.
*
* This KD-tree has to be manually edited by adding, removing triangles and updating the tree.
* There are wrappers for this template wich take charge of automatically keeping the KD-tree up to date.
* @see CATPolyMeshTriangleKDTree
* @see CATPolyOverlayTriangleKDTree
*/
template<typename Triangle>
class CATPolyTriangleKDTree : public CATPolyBaseKDTree<Triangle>
{
public:

  /**
  * @brief Main constructor.
  */
  CATPolyTriangleKDTree ();

  ~CATPolyTriangleKDTree ();

  /**
  * @brief Sets the safety margin regarding how close a triangle must be to the boundaries of a node to intersect it.
  * Default value is zero.
  * To be called before Initialize.
  */
  void SetTolerance (const double iEpsilon) { _Epsilon = iEpsilon; }

  /**
  * @brief Sets how many less triangles there should at least be in each son of a node for this node to be subdivided,
  * with regard to the number of triangles in their father.
  * This measures how effective the split of a node should at least be to be performed.
  * Default value is 30.
  * To be called before Initialize.
  */
  void SetMinTriangleDelta (const size_t iMinTriangleDelta) { _MinTriangleDelta = iMinTriangleDelta; }

  /**
  * @brief Sets the number of cuts considered along each dimension when subdividing a node.
  * Default value is 100.
  * To be called before Initialize.
  * @details When we try to subdivide a node, we project triangles on all three axis, but we discretize space into buckets to avoid
  * having to sort projected triangles and thus increase performance. This means there 3 * iNbBuckets possible cuts at each node subdivision.
  */
  void SetNumberOfBuckets (const size_t iNbBuckets) { _NbBuckets = iNbBuckets; _MaxBucketIdx = iNbBuckets - 1; }

  /**
  * @brief Sets the number of threads used during initialization and update of the KD-tree.
  * Default value is 1 (monothreaded behavior).
  * To be called before Initialize.
  */
  void SetNumberOfWorkers (const unsigned int iNbWorkers) { this->_NbWorkers = iNbWorkers; }

  /**
  * @brief call this after the constructor.
  * @details It builds the tree from scratch using all provided triangles.
  * @param iBox : the bounding box of all the provided triangles.
  * @param iNbTriangles : the number of inserted triangles. Technically unnecessary but useful to pre-allocate memory.
  * @param iGetPosition : this is an object with a public method of signature : HRESULT Get (Triangle iTriangle, CATMathPoint (&oPositions)[3]).
  * It is used to get the positions of the three vertices of a triangle.
  * @param itriItr : an iterator over inserted triangles, in the same fashion as all iterators used in the Polyhedral frameworks.
  */
  template<class GetTrianglePosition, class TriangleIterator>
  HRESULT Initialize (const CATMathBox& iBox, const size_t iNbTriangles, GetTrianglePosition& iGetPosition, TriangleIterator& iTriItr);

  /**
  * @brief Tries again to subdivide the leaves of the tree.
  * @details When triangles are added, removed or modified, we update the tree, but we do not try to subdivide leaves : the structure of the tree is unchanged.
  * We simply remember which leaves may be. By calling this, we will recursively subdivide all leaves which should be.
  */
  template<class GetTrianglePosition>
  HRESULT Update (const CATMathBox& iBox, GetTrianglePosition& iGetPosition);

public:

  /**
  * @brief Adds a new triangle to the KD-tree.
  * The triangle is added in the relevant leaves and the tree structure is left unchanged.
  * @param iTriangle : the triangle to add.
  * @param iPositions : the positions of the three points of the triangle.
  */
  HRESULT AddTriangle (const Triangle iTriangle, const CATMathPoint iPositions[3]);

  /**
  * @brief Removes triangle from the KD-tree.
  * @param iTriangle : the triangle to remove.
  * @param iPositions : the positions of the three points of the triangle, which should be identical to the ones used to add it.
  */
  HRESULT RemoveTriangle (const Triangle iTriangle, const CATMathPoint iPositions[3]);

  /**
  * @brief Move a triangle which was already inserted in the KD-tree.
  * @param iTriangle : the triangle to move.
  * @param iOldPositions : the positions of the three points of the triangle, which should be identical to the ones used to add it.
  * @param iNewPositions : the new positions of the three points of the triangle.
  */
  HRESULT UpdateTriangle (const Triangle iTriangle, const CATMathPoint iOldPositions[3], const CATMathPoint iNewPositions[3]);

  /**
  * This method is used to navigate the tree and call user-defined methods on its chosen leaves.
  * @tparam Traverser : an object with a public method of signature :
  * unsigned char GetSides (const unsigned char iDim, const double iValue)
  * This method is called to decide which children of a visited node should be visited in turn.
  * It is supposed to return 0 if the left child is to be visited, 1 if the right child is to be visited, and 2 if both are.
  * The arguments to GetSides provide the dimension (0, 1 or 2) of the splitting plane and the splitting value for the current node.
  * @tparam Visitor : the object on which the method iCall is called for each visited leaf of the tree.
  * @tparam Call : the method type of the method called on iVisitor on leaves of the tree. It must have signature :
  * HRESULT Call(const Triangle* ipTriangles, const unsigned int iNbTriangles, Args... iArgs)
  * @tparam Args : remaining arguments of the method iCall beside the triangles in the visited leaf and the number of them.
  */
  template<typename Traverser, typename Visitor, typename Call, typename... Args>
  HRESULT Traverse (Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const;

  /**
  * @brief Get all triangles whose distance to iTriangle is at most iEpsilon in oTriangles.
  */
  HRESULT GetTrianglesAroundTriangle (const CATMathPoint iTriangle[3], const double iEpsilon, Poly::Set<Triangle>& oTriangles) const;

  /**
  * @brief Get all triangles whose distance to iBar is at most iEpsilon in oTriangles.
  */
  HRESULT GetTrianglesAroundBar (const CATMathPoint iBar[2], const double iEpsilon, Poly::Set<Triangle>& oTriangles) const;

  /**
  * @brief Get the first triangle encountered below iVertex (a vertex of the mesh the KD-Tree is build on) along the Z axis in oTriangleBelow.
  * oTriangleBelow is zero if no triangle is found.
  */
  template<class GetTrianglePosition>
  HRESULT GetTriangleBelow (const CATPolyExactArithmetic& iArithmetic,
                            GetTrianglePosition& iGetPosition,
                            const CATMathPoint& iPosition,
                            Triangle& oTriangleBelow,
                            Poly::Condition<const Triangle &> & isActif = Poly::noCondition<const Triangle&>) const;

private:

  using typename CATPolyBaseKDTree<Triangle>::Position;
  using typename CATPolyBaseKDTree<Triangle>::Box;
  using typename CATPolyBaseKDTree<Triangle>::Polygon;
  using typename CATPolyBaseKDTree<Triangle>::Node;
  using typename CATPolyBaseKDTree<Triangle>::Leaf;
  using typename CATPolyBaseKDTree<Triangle>::Child;
  using typename CATPolyBaseKDTree<Triangle>::DefaultTraverser;

  struct TrianglePolygon
  {
    TrianglePolygon () :
      _Triangle (),
      _Polygon ()
    {}

    TrianglePolygon (const Triangle iTriangle, const Polygon& iPolygon) :
      _Triangle (iTriangle),
      _Polygon (iPolygon)
    {}

    TrianglePolygon (const Triangle iTriangle, Polygon&& iPolygon) :
      _Triangle (iTriangle),
      _Polygon (iPolygon)
    {}

    TrianglePolygon (const Triangle iTriangle, const CATMathPoint iPositions[3], const Box& iBox) :
      _Triangle (iTriangle),
      _Polygon (iPositions, iBox)
    {}

    Triangle _Triangle;
    Polygon _Polygon;
  };

  struct PolygonPair
  {
  public:

    PolygonPair () :
      _OldPolygon (),
      _NewPolygon (),
      _OldSide (0u),
      _NewSide (0u)
    {}

    PolygonPair (const CATMathPoint iOldPositions[3], const CATMathPoint iNewPositions[3]) :
      _OldPolygon (iOldPositions),
      _NewPolygon (iNewPositions),
      _OldSide (0u),
      _NewSide (0u)
    {}

    PolygonPair (const PolygonPair& iOther) :
      _OldPolygon (iOther._OldPolygon),
      _NewPolygon (iOther._NewPolygon),
      _OldSide (0u),
      _NewSide (0u)
    {
    }

    PolygonPair (PolygonPair&& iOther) :
      _OldPolygon (std::move (iOther._OldPolygon)),
      _NewPolygon (std::move (iOther._NewPolygon)),
      _OldSide (0u),
      _NewSide (0u)
    {
    }


    PolygonPair& operator=(PolygonPair&& iOther)
    {
      _OldPolygon = std::move (iOther._OldPolygon);
      _NewPolygon = std::move (iOther._NewPolygon);
      _OldSide = 0u;
      _NewSide = 0u;
      return *this;
    }

  public:

    unsigned char GetSides (const unsigned char iDim, const double iValue, const double iEpsilon);

    void Cut (const unsigned char iDim, const double iValue, const bool iSide, PolygonPair& oPolygons);

    void Cut (const unsigned char iDim, const double iValue, const bool iSide);

  public:

    bool IsOldPolygonOnSide (const unsigned char iSide) { return _OldSide & (1u + iSide); }

    bool IsNewPolygonOnSide (const unsigned char iSide) { return _NewSide & (1u + iSide); }

  private:

    Polygon _OldPolygon;
    Polygon _NewPolygon;

    unsigned char _OldSide;
    unsigned char _NewSide;

  };

  using Polygons = std::vector<TrianglePolygon>;

  /** @name Node building methods */
  //@{

  HRESULT BuildChild (const Box& iBox, Polygons& iPolygons, Child& oNode, bool& oLeafFlag);

  HRESULT BuildNode (const Box& iBox, Polygons& iPolygons, const unsigned char iDim, const double iValue, size_t& iNbLeftPolygons, size_t& iNbRightPolygons, Node*& opNode);

  HRESULT BuildLeaf (const Box& iBox, Polygons& iPolygons, Leaf*& opLeaf);

  HRESULT BuildLeaf (const Box& iBox, Poly::Set<Triangle>& iTriangles, Leaf*& opLeaf);

  //@}

private:

  /** @name Node splitting methods */
  //@{

  void Project (Polygons& iPolygons, const unsigned char iDim, const double iMin, const double iMax, std::vector<std::array<size_t, 2>>& ioBuckets);

  size_t BuildCut (const Box& iBox, Polygons& iPolygons, unsigned char& oDim, double& oCut, size_t& oNbLeftPolygons, size_t& oNbRightPolygons);

  void SplitPolygons (Node& iNode, Polygons& iPolygons, Polygons& oLeftPolygons, Polygons& oRightPolygons);

  void PropagateUpdateFlags (Node& iNode, bool& oToUpdate);

  template<class GetTrianglePosition>
  void GetNodesToUpdate (Node& iNode, Box& iNodeBox, GetTrianglePosition& iGetPosition, HRESULT& oHR);

  template<class GetTrianglePosition>
  HRESULT UpdateNode (Node& iFather, const unsigned char iChildIdx, const Box& iNodeBox, GetTrianglePosition& iGetPosition);

  void FreeChildSubTree (Node& iFather, const unsigned char iChildIdx);

  //@}

private:

  /** @name Leaf operators */
  //@{

  HRESULT UpdateInLeaf (Node& iNode, const unsigned char iChildIdx, const Triangle& iTriangle, PolygonPair& iOldAndNewPolygon);

  //@}

private:

  template<class GetTrianglePosition>
  class BelowPointTraverser
  {
  public:
    BelowPointTraverser (const CATPolyExactArithmetic& iArithmetic,
                         const GetTrianglePosition& iGetPosition,
                         const CATMathPoint& iPoint,
                         const Poly::Condition<const Triangle&> & isActif);

    unsigned char GetSides (const unsigned char iDim, const double iValue);

    HRESULT FindTriangleBelowInLeaf (const Node& iNode, const unsigned char iLeafIdx);

    inline bool FoundTriangleBelow () const { return _FoundTriangleBelow; }

    inline Triangle GetTriangleBelow () const { return _TriangleBelow; }

  private:

    bool IsTriangleBelow (const CATMathPoint iTriangle[3]);

    static inline bool Unequal (const CATMathPoint& iFst, const CATMathPoint& iSnd);

  private:

    const CATPolyExactArithmetic& _Arithmetic;
    const GetTrianglePosition& _GetPosition;
    const Poly::Condition<const Triangle &> _IsActif;

    CATMathPoint _Point;
    Position _Position;

    CATMathPoint _CrtTriangle[3];
    Triangle _TriangleBelow;
    bool _FoundTriangleBelow;
  };

private:

  static inline const size_t& GetMin (const size_t& iFst, const size_t& iSnd);

private:

  double _Epsilon; //!< The safety margin regarding how close to the boudaries of a leaf a triangle must be to be considered intersecting it.
  size_t _MinTriangleDelta; //!< How many less triangles there should at least be in each son of a node for this node to be subdivided.

  size_t _NbBuckets; //!< In how many buckets do we discretize space when we project all triangles on an axis for node subdivision.
  size_t _MaxBucketIdx; //!< = _NbBuckets - 1.
};


//////////////////////
//  IMPLEMENTATION  //
//////////////////////

template<typename Triangle>
CATPolyTriangleKDTree<Triangle>::CATPolyTriangleKDTree () :
  CATPolyBaseKDTree<Triangle> (),
  _Epsilon (0.),
  _MinTriangleDelta (30),
  _NbBuckets (100),
  _MaxBucketIdx (99)
{
}

template<typename Triangle>
CATPolyTriangleKDTree<Triangle>::~CATPolyTriangleKDTree ()
{
}

template<typename Triangle>
template<class GetTrianglePosition, class TriangleIterator>
HRESULT CATPolyTriangleKDTree<Triangle>::Initialize (const CATMathBox& iBox, const size_t iNbTriangles, GetTrianglePosition& iGetPosition, TriangleIterator& iTriItr)
{
  HRESULT ret = S_FALSE;

  if (SUCCEEDED (ret = this->BuildWorkers ()))
  {
    Polygons triangles;
    triangles.reserve (iNbTriangles);

    CATMathPoint positions[3];
    Triangle triangle;
    for (; !iTriItr.End () && SUCCEEDED (ret); ++iTriItr)
      if (SUCCEEDED (ret = iGetPosition.Get (triangle = *iTriItr, positions)))
        triangles.emplace_back (triangle, Polygon (positions));

    if (SUCCEEDED (ret))
    {
      Box box;
      if (SUCCEEDED (ret = iBox.GetLimits (box[0][0], box[1][0], box[0][1], box[1][1], box[0][2], box[1][2])))
      {
        unsigned char dim = 0;
        double cut = 0.;
        size_t nbLeftTriangles = 0;
        size_t nbRightTriangles = 0;
        BuildCut (box, triangles, dim, cut, nbLeftTriangles, nbRightTriangles);
        ret = BuildNode (box, triangles, dim, cut, nbLeftTriangles, nbRightTriangles, this->_pRoot);
        if (this->_NbWorkers > 1 && FAILED (this->WaitForCompletion ()) && SUCCEEDED (ret))
          ret = E_FAIL;
      }
    }
  }
  return ret;
}

template<typename Triangle>
void CATPolyTriangleKDTree<Triangle>::PropagateUpdateFlags (Node& iNode, bool& oToUpdate)
{
  for (unsigned char childIdx = 0u; childIdx < 2u; ++childIdx)
    if (!iNode._IsChildLeaf[childIdx] && iNode._Child[childIdx]._pNode)
      PropagateUpdateFlags (*iNode._Child[childIdx]._pNode, iNode._IsChildToUpdate[childIdx]);
  oToUpdate = iNode._IsChildToUpdate[0] && iNode._IsChildToUpdate[1];
}

template<typename Triangle>
template<class GetTrianglePosition>
void CATPolyTriangleKDTree<Triangle>::GetNodesToUpdate (Node& iNode, Box& iNodeBox, GetTrianglePosition& iGetPosition, HRESULT& oHR)
{
  for (unsigned char childIdx = 0u; childIdx < 2u && SUCCEEDED (oHR); ++childIdx)
  {
    double temp = iNodeBox[1u - childIdx][iNode._CutDimension];
    iNodeBox[1u - childIdx][iNode._CutDimension] = iNode._CutValue;
    if (iNode._IsChildToUpdate[childIdx])
    {
      if (this->_NbWorkers > 1)
      {
        this->_Mutex.lock ();
        this->_Tasks.push (std::bind (&CATPolyTriangleKDTree::UpdateNode<GetTrianglePosition>, this, std::ref (iNode), childIdx, iNodeBox, std::ref (iGetPosition)));
        ++this->_NbTasksLeft;
        this->_Mutex.unlock ();
        this->_WorkerNotifier.notify_one ();
        oHR = S_OK;
      }
      else
        oHR = UpdateNode (iNode, childIdx, iNodeBox, iGetPosition);
    }
    else if (!iNode._IsChildLeaf[childIdx])
      GetNodesToUpdate (*iNode._Child[childIdx]._pNode, iNodeBox, iGetPosition, oHR);

    iNodeBox[1u - childIdx][iNode._CutDimension] = temp;
  }
}

template<typename Triangle>
template<class GetTrianglePosition>
HRESULT CATPolyTriangleKDTree<Triangle>::CATPolyTriangleKDTree::Update (const CATMathBox& iBox, GetTrianglePosition& iGetPosition)
{
  HRESULT ret = S_FALSE;
  Box box;
  ret = iBox.GetLimits (box[0][0], box[1][0], box[0][1], box[1][1], box[0][2], box[1][2]);

  bool updateRoot = false;
  PropagateUpdateFlags (*this->_pRoot, updateRoot);
  GetNodesToUpdate (*this->_pRoot, box, iGetPosition, ret);

  if (this->_NbWorkers > 1 && FAILED (this->WaitForCompletion ()) && SUCCEEDED (ret))
    ret = E_FAIL;

  return ret;
}

template<typename Triangle>
inline const size_t& CATPolyTriangleKDTree<Triangle>::GetMin (const size_t& iFst, const size_t& iSnd)
{
  return iFst < iSnd ? iFst : iSnd;
}

template<typename Triangle>
void CATPolyTriangleKDTree<Triangle>::Project (Polygons& iPolygons, const unsigned char iDim, const double iMin, const double iMax, std::vector<std::array<size_t, 2>>& ioBuckets)
{
  double inverseStep = _NbBuckets / (iMax - iMin);
  for (auto pItr = iPolygons.begin (), pEnd = iPolygons.end (); pItr != pEnd; ++pItr)
  {
    if (!pItr->_Polygon.IsEmpty ())
    {
      int idMin = GetMin(static_cast<size_t>(CATMax(CATFloor((pItr->_Polygon.GetBoundingBox()[0][iDim] - _Epsilon - iMin) * inverseStep), 0)), _MaxBucketIdx);
      int idMax = GetMin(static_cast<size_t>(CATMax(CATFloor((pItr->_Polygon.GetBoundingBox()[1][iDim] + _Epsilon - iMin) * inverseStep), 0)), _MaxBucketIdx);
      ++ioBuckets[idMin][0];
      ++ioBuckets[idMax][1];
    }
  }
}

template<typename Triangle>
size_t CATPolyTriangleKDTree<Triangle>::BuildCut (const Box& iBox, Polygons& iPolygons, unsigned char& oDim, double& oCut, size_t& oNbLeftPolygons, size_t& oNbRightPolygons)
{
  size_t nbTriangles = iPolygons.size ();

  size_t maxCost = 0;
  size_t bestCost = (nbTriangles + 1) / 2;

  std::vector<std::array<size_t, 2>> buckets (_NbBuckets, { 0, 0 });

  for (unsigned char dim = 0; dim < 3; ++dim)
  {
    double step = (iBox[1][dim] - iBox[0][dim]) / _NbBuckets;
    Project (iPolygons, dim, iBox[0][dim], iBox[1][dim], buckets); // Project triangles on current axis.

    size_t lftNbTriangles = 0;
    size_t rgtNbTriangles = nbTriangles;

    auto bBgn = buckets.begin ();
    auto bEnd = buckets.end ();
    for (auto bItr = bBgn; bItr != bEnd; ++bItr)
    {
      if ((*bItr)[0] || (*bItr)[1])
      {
        lftNbTriangles += (*bItr)[1];
        rgtNbTriangles -= (*bItr)[0];

        size_t cost = lftNbTriangles < rgtNbTriangles ? lftNbTriangles : rgtNbTriangles;
        if (cost > maxCost) // New best cut ?
        {
          double prevCutValue = iBox[0][dim] + (std::distance(bBgn, bItr)) * step;
          double cutValue = iBox[0][dim] + (std::distance(bBgn, bItr) + 1) * step;
          if (prevCutValue != cutValue) // might not be the case if step too small and numerical noise
          {
            maxCost = cost;
            oDim = dim;
            oCut = cutValue;
            oNbLeftPolygons = nbTriangles - rgtNbTriangles;
            oNbRightPolygons = nbTriangles - lftNbTriangles;
            if (maxCost == bestCost) // Optimal cut ?
            {
              for (; bItr != bEnd; ++bItr)
                (*bItr)[0] = (*bItr)[1] = 0;
              return maxCost;
            }
          }
        }
        (*bItr)[0] = (*bItr)[1] = 0;
      }
    }
  }
  return maxCost;
}

template<typename Triangle>
void CATPolyTriangleKDTree<Triangle>::SplitPolygons (Node& iNode, Polygons& iPolygons, Polygons& oLeftPolygons, Polygons& oRightPolygons)
{
  Polygon leftPolygon;
  Polygon rightPolygon;
  unsigned int sides = 0;
  for (auto pItr = iPolygons.begin (), pEnd = iPolygons.end (); pItr != pEnd; ++pItr)
  {
    if (!pItr->_Polygon.IsEmpty ())
    {
      sides = pItr->_Polygon.GetSides (iNode._CutDimension, iNode._CutValue, _Epsilon);
      if (sides == 0)
        oLeftPolygons.push_back (std::move (*pItr));
      else if (sides == 1)
        oRightPolygons.push_back (std::move (*pItr));
      else
      {
        pItr->_Polygon.Cut (iNode._CutDimension, iNode._CutValue + _Epsilon, false, leftPolygon);
        pItr->_Polygon.Cut (iNode._CutDimension, iNode._CutValue - _Epsilon, true, rightPolygon);
        oLeftPolygons.emplace_back (pItr->_Triangle, leftPolygon);
        oRightPolygons.emplace_back (pItr->_Triangle, rightPolygon);
      }
    }
  }
}

template<typename Triangle>
template<class GetTrianglePosition>
HRESULT CATPolyTriangleKDTree<Triangle>::UpdateNode (Node& iFather, const unsigned char iChildIdx, const Box& iNodeBox, GetTrianglePosition& iGetPosition)
{
  HRESULT ret = S_FALSE;

  if (iFather._IsChildLeaf[iChildIdx])
  {
    Leaf* pLeaf = iFather._Child[iChildIdx]._pLeaf;
    if (pLeaf->_Size >= 2 * _MinTriangleDelta)
    {
      Box nodeBox = iNodeBox;
      for (unsigned char dim = 0; dim < 3; ++dim)
      {
        nodeBox[0][dim] -= _Epsilon;
        nodeBox[1][dim] += _Epsilon;
      }

      Polygons trianglePositions;
      trianglePositions.reserve (static_cast<size_t>(pLeaf->_Size));
      Triangle* pTriangles = pLeaf->GetElements ();
      CATMathPoint positions[3];
      for (unsigned int triIdx = 0; triIdx < pLeaf->_Size && SUCCEEDED (ret); ++triIdx)
        if (SUCCEEDED (ret = iGetPosition.Get (pTriangles[triIdx], positions)))
          trianglePositions.emplace_back (pTriangles[triIdx], positions, nodeBox);

      if (SUCCEEDED (ret))
      {
        unsigned char dim = 0;
        double cut = 0.;
        size_t nbLeftTriangles = 0;
        size_t nbRightTriangles = 0;
        size_t triangleLoss = BuildCut (iNodeBox, trianglePositions, dim, cut, nbLeftTriangles, nbRightTriangles);
        if (triangleLoss >= _MinTriangleDelta)
        {
          FreeChildSubTree (iFather, iChildIdx);
          iFather._IsChildLeaf[iChildIdx] = false;
          ret = BuildNode (iNodeBox, trianglePositions, dim, cut, nbLeftTriangles, nbRightTriangles, iFather._Child[iChildIdx]._pNode);
        }
      }
    }
  }
  else
  {
    Poly::Set<Triangle> triangles;
    DefaultTraverser traverser;
    ret = this->InternalTraverse (iFather._Child[iChildIdx]._pNode, traverser, this, &CATPolyTriangleKDTree::GatherElements, std::ref (triangles));

    if (triangles.Size () < 2 * _MinTriangleDelta)
    {
      FreeChildSubTree (iFather, iChildIdx);
      iFather._IsChildLeaf[iChildIdx] = true;
      ret = SUCCEEDED (ret) ? BuildLeaf (iNodeBox, triangles, iFather._Child[iChildIdx]._pLeaf) : ret;
    }
    else
    {
      Box nodeBox = iNodeBox;
      for (unsigned char dim = 0; dim < 3; ++dim)
      {
        nodeBox[0][dim] -= _Epsilon;
        nodeBox[1][dim] += _Epsilon;
      }

      Polygons trianglePositions;
      trianglePositions.reserve (static_cast<size_t>(triangles.Size ()));
      CATMathPoint positions[3];
      for (typename Poly::Set<Triangle>::Iterator triItr (triangles); !triItr.End () && SUCCEEDED (ret); ++triItr) // Initialize polygons.
        if (SUCCEEDED (ret = iGetPosition.Get (*triItr, positions)))
          trianglePositions.emplace_back (*triItr, positions, nodeBox);

      unsigned char dim = 0;
      double cut = 0.;
      size_t nbLeftTriangles = 0;
      size_t nbRightTriangles = 0;
      size_t triangleLoss = BuildCut (iNodeBox, trianglePositions, dim, cut, nbLeftTriangles, nbRightTriangles);
      if (triangleLoss >= _MinTriangleDelta)
      {
        FreeChildSubTree (iFather, iChildIdx);
        iFather._IsChildLeaf[iChildIdx] = false;
        ret = SUCCEEDED (ret) ? BuildNode (iNodeBox, trianglePositions, dim, cut, nbLeftTriangles, nbRightTriangles, iFather._Child[iChildIdx]._pNode) : ret;
      }
      else
      {
        FreeChildSubTree (iFather, iChildIdx);
        iFather._IsChildLeaf[iChildIdx] = true;
        ret = SUCCEEDED (ret) ? BuildLeaf (iNodeBox, trianglePositions, iFather._Child[iChildIdx]._pLeaf) : ret;
      }
    }
  }
  iFather._IsChildToUpdate[iChildIdx] = false;
  return ret;
}

template<typename Triangle>
void CATPolyTriangleKDTree<Triangle>::FreeChildSubTree (Node& iFather, const unsigned char iChildIdx)
{
  if (iFather._IsChildLeaf[iChildIdx])
  {
    free (iFather._Child[iChildIdx]._pLeaf);
    iFather._Child[iChildIdx]._pLeaf = nullptr;
  }
  else
  {
    FreeChildSubTree (*iFather._Child[iChildIdx]._pNode, 0u);
    FreeChildSubTree (*iFather._Child[iChildIdx]._pNode, 1u);
    delete iFather._Child[iChildIdx]._pNode;
    iFather._Child[iChildIdx]._pNode = nullptr;
    iFather._IsChildLeaf[iChildIdx] = true;
  }
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::BuildChild (const Box& iBox, Polygons& iPolygons, Child& oNode, bool& oLeafFlag)
{
  if (iPolygons.size () < 2 * _MinTriangleDelta)
  {
    oLeafFlag = true;
    return BuildLeaf (iBox, iPolygons, oNode._pLeaf);
  }
  else
  {
    unsigned char dim = 0;
    double cut = 0.;
    size_t nbLeftTriangles = 0;
    size_t nbRightTriangles = 0;
    size_t triangleLoss = BuildCut (iBox, iPolygons, dim, cut, nbLeftTriangles, nbRightTriangles);
    if (triangleLoss < _MinTriangleDelta)
    {
      oLeafFlag = true;
      return BuildLeaf (iBox, iPolygons, oNode._pLeaf);
    }
    else
    {
      oLeafFlag = false;
      return BuildNode (iBox, iPolygons, dim, cut, nbLeftTriangles, nbRightTriangles, oNode._pNode);
    }
  }
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::BuildNode (const Box& iBox, Polygons& iPolygons, const unsigned char iDim, const double iValue, size_t& iNbLeftPolygons, size_t& iNbRightPolygons, Node*& opNode)
{
  HRESULT ret = E_OUTOFMEMORY;
  if (opNode = new Node ())
  {
    opNode->_CutDimension = iDim;
    opNode->_CutValue = iValue;

    Polygons leftPolygons;
    Polygons rightPolygons;
    leftPolygons.reserve (iNbLeftPolygons);
    rightPolygons.reserve (iNbRightPolygons);

    SplitPolygons (*opNode, iPolygons, leftPolygons, rightPolygons);
    iPolygons.clear ();
    iPolygons.shrink_to_fit ();

    Box leftBox = iBox;
    Box rightBox = iBox;
    leftBox[1][iDim] = iValue;
    rightBox[0][iDim] = iValue;

    if (this->_NbWorkers > 1)
    {
      this->_Mutex.lock ();
      this->_Tasks.push (std::bind (&CATPolyTriangleKDTree::BuildChild, this, std::move (leftBox), std::move (leftPolygons), std::ref (opNode->_Child[0]), std::ref (opNode->_IsChildLeaf[0])));
      this->_Tasks.push (std::bind (&CATPolyTriangleKDTree::BuildChild, this, std::move (rightBox), std::move (rightPolygons), std::ref (opNode->_Child[1]), std::ref (opNode->_IsChildLeaf[1])));
      this->_NbTasksLeft += 2;
      this->_Mutex.unlock ();
      this->_WorkerNotifier.notify_one ();
      this->_WorkerNotifier.notify_one ();
      ret = S_OK;
    }
    else if (SUCCEEDED (ret = BuildChild (leftBox, leftPolygons, opNode->_Child[0], opNode->_IsChildLeaf[0])))
      ret = BuildChild (rightBox, rightPolygons, opNode->_Child[1], opNode->_IsChildLeaf[1]);
  }
  return ret;
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::BuildLeaf (const Box& iBox, Polygons& iPolygons, Leaf*& opLeaf)
{
  unsigned int size = static_cast<unsigned int>(iPolygons.size ());
  if (opLeaf = Leaf::CreateLeaf (size, size))
  {
    Triangle* pTriangles = opLeaf->GetElements ();

    unsigned int tIdx = 0;
    for (auto tItr = iPolygons.begin (), tEnd = iPolygons.end (); tItr != tEnd; ++tItr, ++tIdx)
      pTriangles[tIdx] = tItr->_Triangle;

    iPolygons.clear ();
    iPolygons.shrink_to_fit ();

    return S_OK;
  }
  return E_OUTOFMEMORY;
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::BuildLeaf (const Box& iBox, Poly::Set<Triangle>& iTriangles, Leaf*& opLeaf)
{
  if (opLeaf = Leaf::CreateLeaf (iTriangles.Size (), iTriangles.Size ()))
  {
    Triangle* pTriangles = opLeaf->GetElements ();

    unsigned int tIdx = 0;
    for (typename Poly::Set<Triangle>::Iterator tItr (iTriangles); !tItr.End (); ++tItr, ++tIdx)
      pTriangles[tIdx] = *tItr;

    return S_OK;
  }
  return E_OUTOFMEMORY;
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::UpdateInLeaf (Node& iNode, const unsigned char iChildIdx, const Triangle& iTriangle, PolygonPair& iOldAndNewPolygon)
{
  if (iOldAndNewPolygon.IsOldPolygonOnSide (iChildIdx))
    return !iOldAndNewPolygon.IsNewPolygonOnSide (iChildIdx) ? this->RemoveFromLeaf (iNode, iChildIdx, iTriangle) : S_FALSE;
  else if (iOldAndNewPolygon.IsNewPolygonOnSide (iChildIdx))
    return this->InsertInLeaf (iNode, iChildIdx, iTriangle);
  else
    return S_FALSE;
}

template<typename Triangle>
unsigned char CATPolyTriangleKDTree<Triangle>::PolygonPair::GetSides (const unsigned char iDim, const double iValue, const double iEpsilon)
{
  _OldSide = _OldPolygon.IsEmpty () ? 0u : _OldPolygon.GetSides (iDim, iValue, iEpsilon) + 1u;
  _NewSide = _NewPolygon.IsEmpty () ? 0u : _NewPolygon.GetSides (iDim, iValue, iEpsilon) + 1u;
  return (_OldSide | _NewSide) - 1u;
}

template<typename Triangle>
void CATPolyTriangleKDTree<Triangle>::PolygonPair::Cut (const unsigned char iDim, const double iValue, const bool iSide, PolygonPair& oPolygons)
{
  _OldPolygon.Cut (iDim, iValue, iSide, oPolygons._OldPolygon);
  _NewPolygon.Cut (iDim, iValue, iSide, oPolygons._NewPolygon);
}

template<typename Triangle>
void CATPolyTriangleKDTree<Triangle>::PolygonPair::Cut (const unsigned char iDim, const double iValue, const bool iSide)
{
  _OldPolygon.Cut (iDim, iValue, iSide);
  _NewPolygon.Cut (iDim, iValue, iSide);
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::AddTriangle (const Triangle iTriangle, const CATMathPoint iPositions[3])
{
  Polygon polygon (iPositions);
  return this->InternalTraverse (this->_pRoot, polygon, _Epsilon, this, &CATPolyTriangleKDTree::InsertInLeaf, iTriangle);
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::RemoveTriangle (const Triangle iTriangle, const CATMathPoint iPositions[3])
{
  Polygon polygon (iPositions);
  return this->InternalTraverse (this->_pRoot, polygon, _Epsilon, this, &CATPolyTriangleKDTree::RemoveFromLeaf, iTriangle);
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::UpdateTriangle (const Triangle iTriangle, const CATMathPoint iOldPositions[3], const CATMathPoint iNewPositions[3])
{
  PolygonPair polygons (iOldPositions, iNewPositions);
  return this->InternalTraverse (this->_pRoot, polygons, _Epsilon, this, &CATPolyTriangleKDTree::UpdateInLeaf, iTriangle, std::ref (polygons));
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::GetTrianglesAroundTriangle (const CATMathPoint iTriangle[3], const double iEpsilon, Poly::Set<Triangle>& oTriangles) const
{
  Polygon polygon (iTriangle);
  return this->InternalTraverse (this->_pRoot, polygon, iEpsilon, this, &CATPolyTriangleKDTree::GatherElements, std::ref (oTriangles));
}

template<typename Triangle>
HRESULT CATPolyTriangleKDTree<Triangle>::GetTrianglesAroundBar (const CATMathPoint iBar[2], const double iEpsilon, Poly::Set<Triangle>& oTriangles) const
{
  typename CATPolyTriangleKDTree<Triangle>::Bar bar (iBar);
  return this->InternalTraverse (this->_pRoot, bar, iEpsilon, this, &CATPolyTriangleKDTree::GatherElements, std::ref (oTriangles));
}

template<typename Triangle>
template<typename Traverser, typename Visitor, typename Call, typename... Args>
HRESULT CATPolyTriangleKDTree<Triangle>::Traverse (Traverser& iTraverser, Visitor* ipVisitor, Call iCall, Args ... iArgs) const
{
  return this->InternalTraverse (this->_pRoot, iTraverser, this, &CATPolyTriangleKDTree::template VisitLeaf<Visitor, Call, Args...>, ipVisitor, iCall, iArgs...);
}

template<typename Triangle>
template<class GetTrianglePosition>
inline bool CATPolyTriangleKDTree<Triangle>::BelowPointTraverser<GetTrianglePosition>::Unequal (const CATMathPoint& iFst, const CATMathPoint& iSnd)
{
  return iFst.GetX () != iSnd.GetX () || iFst.GetY () != iSnd.GetY () || iFst.GetZ () != iSnd.GetZ ();
}

template<typename Triangle>
template<class GetTrianglePosition>
CATPolyTriangleKDTree<Triangle>::BelowPointTraverser<GetTrianglePosition>::BelowPointTraverser (const CATPolyExactArithmetic& iArithmetic,
                                                                                                const GetTrianglePosition& iGetPosition,
                                                                                                const CATMathPoint& iPoint,
                                                                                                const Poly::Condition<const Triangle &> & isActif) :
  _Arithmetic (iArithmetic),
  _GetPosition (iGetPosition),
  _Point (iPoint),
  _Position (),
  _CrtTriangle (),
  _TriangleBelow (),
  _FoundTriangleBelow (false),
  _IsActif(isActif)
{
  _Position[0] = iPoint.GetX ();
  _Position[1] = iPoint.GetY ();
  _Position[2] = iPoint.GetZ ();
}

template<typename Triangle>
template<class GetTrianglePosition>
unsigned char CATPolyTriangleKDTree<Triangle>::BelowPointTraverser<GetTrianglePosition>::GetSides (const unsigned char iDim, const double iValue)
{
  if (iDim != 2)
  {
    if (_Position[iDim] < iValue)
      return 0;
    else if (_Position[iDim] > iValue)
      return 1;
    else
      return 2;
  }
  else if (_Position[iDim] < iValue)
    return 0;
  else
    return 2;
}

template<typename Triangle>
template<class GetTrianglePosition>
bool CATPolyTriangleKDTree<Triangle>::BelowPointTraverser<GetTrianglePosition>::IsTriangleBelow (const CATMathPoint iTriangle[3])
{
  CATMathPoint2D position2D (_Point.GetX (), _Point.GetY ());
  CATMathPoint2D triangle2D[3];

  for (unsigned int v = 0; v < 3; v++)
  {
    triangle2D[v].SetX (iTriangle[v].GetX ());
    triangle2D[v].SetY (iTriangle[v].GetY ());
  }

  int orientation = _Arithmetic.Orientation2D (triangle2D[0], triangle2D[1], triangle2D[2]);

  if (orientation)
  {
    unsigned int u = 2;
    unsigned int v = 0;
    while (v < 3 && _Arithmetic.Orientation2D (triangle2D[u], triangle2D[v], position2D) * orientation >= 0)
      u = v++;

    if (v == 3 && _Arithmetic.Orientation3D (iTriangle[0], iTriangle[1], iTriangle[2], _Point) * orientation >= 0)
      return true;
  }
  return false;
}

template<typename Triangle>
template<class GetTrianglePosition>
HRESULT CATPolyTriangleKDTree<Triangle>::BelowPointTraverser<GetTrianglePosition>::FindTriangleBelowInLeaf (const Node& iNode, const unsigned char iLeafIdx)
{
  HRESULT ret = S_FALSE;
  if (iNode._Child[iLeafIdx]._pLeaf)
  {
    const Triangle* pTriangles = iNode._Child[iLeafIdx]._pLeaf->GetElements ();
    unsigned int nbTriangles = iNode._Child[iLeafIdx]._pLeaf->_Size;
    CATMathPoint points[3];

    for (unsigned int triIdx = 0; triIdx < nbTriangles && SUCCEEDED (ret); ++triIdx)
    {
      if (SUCCEEDED (ret = _GetPosition.Get (pTriangles[triIdx], points)) && Unequal (_Point, points[0]) && Unequal (_Point, points[1]) && Unequal (_Point, points[2]))
      {
        if (IsTriangleBelow (points) && _IsActif(pTriangles[triIdx]))
        {
          if (!_FoundTriangleBelow || _Arithmetic.CompareTrianglesAlongVerticalRay (_Point, _CrtTriangle, points) == 1)
          {
            _CrtTriangle[0] = points[0];
            _CrtTriangle[1] = points[1];
            _CrtTriangle[2] = points[2];
            _TriangleBelow = pTriangles[triIdx];
            _FoundTriangleBelow = true;
          }
        }
      }
    }
  }
  return ret;
}

template<typename Triangle>
template<class GetTrianglePosition>
HRESULT CATPolyTriangleKDTree<Triangle>::GetTriangleBelow (const CATPolyExactArithmetic& iArithmetic,
                                                           GetTrianglePosition& iGetPosition,
                                                           const CATMathPoint& iPosition,
                                                           Triangle& oTriangleBelow,
                                                           Poly::Condition<const Triangle &> & isActif) const
{
  HRESULT ret = S_FALSE;

  BelowPointTraverser<GetTrianglePosition> traverser (iArithmetic, iGetPosition, iPosition, isActif);
  if (SUCCEEDED (ret = this->InternalTraverse (this->_pRoot, traverser, &traverser, &BelowPointTraverser<GetTrianglePosition>::FindTriangleBelowInLeaf)))
    oTriangleBelow = traverser.GetTriangleBelow ();
  return FAILED (ret) ? ret : traverser.FoundTriangleBelow () ? S_OK : S_FALSE;
}

extern template class ExportedTemplateByCATPolyGriddingTools CATPolyTriangleKDTree<int>;

#endif
