//===================================================================
// COPYRIGHT Dassault Systemes 2021/03/29
//===================================================================
// CATIVariabilityExpositionAdapter.cpp
// Header definition of class CATIVariabilityExpositionAdapter
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2021/03/29 Creation: Code generated by the 3DS wizard
//===================================================================
#ifndef CATIVariabilityExpositionAdapter_H
#define CATIVariabilityExpositionAdapter_H

#include "CATIVariabilityExposition.h"
#include "CATLISTV_CATBaseUnknown.h"

class CATSysWeakRef;

/**
* Adapter for CATIVariabiltyExposition interface
*/

class ExportedByKnowledgeItf CATIVariabilityExpositionAdapter : public CATIVariabilityExposition
{
  CATDeclareClass;
public:
  /**
  * owner has to be provided for all objects that dont tell they are persistent
  * no add ref is done on owner : a weak ref is used to avoid references cycles
  */
  CATIVariabilityExpositionAdapter(const CATIVariabilityExposition_var &iOwner = NULL_var);
  virtual ~CATIVariabilityExpositionAdapter();

  /**
* returns true if this object can be pointed
* must be overloaded
*/
  virtual CATBoolean IsPersistent() = 0;

  /**
  * Returns string for delegation process.
  * Some variable providers don't have any object in the session that they can use
  * to expose the variables. For example mass computation for a product. The product modeler
  * shouldn't have to know that another team provides mass computation.
  * So the product team will maybe not itself return any variable but it will call the adapter that will
  * look for variable providers.
  * This is based on declarative files : the adapter will look for files in the runtime view
  * <StringForDelegation>_<anything>.CATRsc
  * The CATRsc file should contain : Implementation=<latetype>.
  * the latetype must implement CATIVariabilityExpositionRootAdapterDelegation
  *
  * Default implementation returns an empty string
  */
  virtual CATUnicodeString GetStringForDelegation();

  /**
  * Returns the owner of the object. NULL for roots.
  * Returned object must itself implement CATIVariabilityExpositionRootAdapter
  *
  * Default implementation : returns owner provided in the constructor
  */
  virtual CATBaseUnknown_var GetOwner();


  /**
  * Returns the list of attributes defining of children that themselves expose some chilren and variables
  * For each of the attributes, the call of GetChild with the attribute name should return a valid object
  *
  * Returns no attribute in default implementation
  */
  virtual HRESULT GetChildrenAttributes(CATListValCATAttributeInfos &oAttributes);

  /**
  * Returns the list of attributes of variables exposed by this object
  * For each of the attributes, the call of GetVariableValue with the attribute name should return a literal value implemented as a volatile parameter
  *
  * Must be overloaded
  */
  virtual HRESULT GetVariableAttributes(CATListValCATAttributeInfos &oAttributes) = 0;

  /**
  * Returns a child based on its attribute key
  *
  * Returns E_FAIL in default implementation
  */
  virtual HRESULT GetChild(const CATUnicodeString &iKey, CATIVariabilityExposition_var &oExposition);

  /**
  * Returns a variable value based on its attribute key
  *
  * Must be overloaded
  */
  virtual HRESULT GetVariableValue(const CATUnicodeString &iKey, CATICkeParm_var &oValue) = 0;

  /**
  * Sets a variable value. The type of the passed parameters should be compliant with the type of
  * the attribute declared in CATAttributeInfos.
  * The method shouldn't be called on attributes that are declared as children and not variables nor on variables
  * declared as read only
  *
  * Must be overloaded
  */
  virtual HRESULT SetVariableValue(const CATUnicodeString &iKey, const CATICkeParm_var &iValue) = 0;

  /**
  * Returns a variable value based on an attribute path.
  * the path should contain a list of attribute keys navigating the children structure and the attribute that
  * is a variable of the last child
  * (for example childKey1 childKey2 (of childKey1 child) variableKey (if childKey2 child)
  *
  * Only overload if you really need to
  * Default implementation :
  * if the path contains only one attribute, call GetVariableValue
  * Otherwise, gets the child with the right key and recursively calls GetVariableValueFromPath with shortened path
  */
  virtual HRESULT GetVariableValueFromPath(const CATListOfCATUnicodeString &iPath, CATICkeParm_var &oValue);

  /**
  * Sets a variable value based on an attribute path.
  * the path should contain a list of attribute keys navigating the children structure and the attribute that
  * is a variable of the last child
  * (for example childKey1 childKey2 (of childKey1 child) variableKey (if childKey2 child)
  * The method shouldn't be called on on variables declared as read only
  *
  * Only overload if you really need to
  * Default implementation :
  * if the path contains only one attribute, call SetVariableValue
  * Otherwise, gets the child with the right key and recursively calls SetVariableValueFromPath with shortened path
  */
  virtual HRESULT SetVariableValueFromPath(const CATListOfCATUnicodeString &iPath, const CATICkeParm_var &iValue);

  /**
  * Optional implementation
  * For complex hierarchies of variables created by modelers, it may be needed to have
  * graphical feedbacks about what a given attribute path represents
  * This method should be called by application showing those variables in a panel (tree display)
  * selecting a node in the tree should call Display(selectionpath, TRUE)
  * and unselecting it should call Display(selectionpath, FALSE).
  * Any selection should be removed when panel is closed
  * Implementation could just implement some cross highlight, or build visualization objects, etc.
  *
  * Default implementation
  * if the path contains only one attribute, return E_FAIL
  * Otherwise, gets the child with the right key and recursively calls Display with shortened path
  * When overloading : if the path contains more than 1 key, you should call the adapter
  * Otherwise manage the display
  */
  virtual HRESULT Display(const CATListOfCATUnicodeString &keyPath, CATBoolean iValue);

protected:
  CATSysWeakRef *_Owner;
};



#endif
