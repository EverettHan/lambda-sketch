/* -*-c++-*- */
/**
* @level Protected
* @usage U3
*/
// COPYRIGHT Dassault Systemes 2009
//===================================================================
//
// CATIOmyIncidentCollector.h
// Define the CATIOmyIncidentCollector interface
//
//===================================================================
//
// Usage notes:
//   New interface: describe its use here
//
//===================================================================
//
//  Apr 2009  Creation: Code generated by the CAA wizard  vcs
//===================================================================
#ifndef CATIOmyIncidentCollector_H
#define CATIOmyIncidentCollector_H

// System
#include "CATError.h"
#include "CATString.h"
#include "CATBaseUnknown.h"

//ObjectModelerCollection
#include "CATOmxArray.h"
#include "CATOmxIter.h"
#include "CATOmxSR.h"

// ObjectModelerSystem
#include "CATOmyIncidentCollect.h"
#include "CATIOmyIncidentIterator.h"

class CATOmyIncidentCell;

#define VCS_IR122569V6R2013

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATOmyIncidentCollect IID IID_CATIOmyIncidentCollector;
#else
extern "C" const IID IID_CATIOmyIncidentCollector;
#endif

//------------------------------------------------------------------

/**
* Interface intended to handle PLM Component monitoring for all errors raised by
* its life cycle operations in any interactive or batch context.
* The IncidentCollector accessed through this interface is the stack for all errors happening
* during each PLM Component operations (switch, stream/unstream, export, ...), that means all code layers
* where error information is to be collected and reported to End User.
*
* Life Cycle:
* The IncidentCollector is created at first invocation : @href CATOmyIncidentCollectorFactory::GetIncidentCollector
* as a unique stack during the whole CATSession life cycle.
* It can be emptied after each /transfer/display/report operation, on user will: @href CATIOmyIncidentCollector::EmptyCollector
* It is deleted at CATSession destruction
*
* Error Stack and trace
* @href CATIOmyIncidentCollector::CreateIncidentCell creates a new CATError, with eventual parameters and context,
* traces it to output logs, and stacks it into IncidentCollector

* Error Trace:
*  outputs ErrorKey/Catalog/Severity/NLS with parameters/debug Context/ to general traces logs:
*  - statistics error log, activable through General\Statistics setting.
*  - OMB_XML_TRACE log, activable through set OMB_XML_TRACE=<aUserTraceDir>
*  - Standard Error output log.
*  To be efficiently traced, each error should be created with
*  - its eventual parameters
*  - an eventual Context input: any concise text formatted information, that really helps debugging error cause.
*
* Error Group and Pack
* for error filtering and packing
* @href CATOmyIncidentGroup to create a group
* @href CATOmyIncidentGroup.Summarize to replace a group of errors by a resulting one


* Error Unstack:
* for any transfer/display/report purpose
* @href CATOmxIter<CATIOmyIncidentCell> CATIOmyIncidentCollector#Iterator() to get the collector stack
* @href CATOmxIter#Next to iterate on collector errors @href CATIOmyIncidentCell#GetError

* CATIOmyIncidentCell* pCell = NULL;
* CATOmxIter<CATIOmyIncidentCell> Iter = hCollector->Iterator();
* while (pCell = Iter.Next())
* {
*   CATOmxSR<CATError> pError = pCell->GetError();
*    ...
* }
*
*/

class ExportedByCATOmyIncidentCollect CATIOmyIncidentCollector : public CATBaseUnknown
{
  CATDeclareInterface;

public:

  /**
  * @deprecated  V6R2015
  * @use CATOmxSR<CATError> CATIOmyIncidentCollector#CreateIncidentCell
  */
  virtual HRESULT CreateIncidentCell(const char * iErrorKey, const char * iErrorCatalog, CATErrorType iSeverity, const CATString iIdEntityType,
    const CATUnicodeString  iUSIdEntityInError, CATIOmyIncidentCell_var & ohIncidentCell) = 0;

/**
* @deprecated  V6R2015
* @use CATOmxSR<CATError> CATIOmyIncidentCollector#CreateIncidentCell
*/
  virtual HRESULT CreateIncidentCell(const char * iErrorKey, const char * iErrorCatalog, CATErrorType iSeverity, const CATString iIdEntityType,
    CATBaseUnknown * ipBUIdEntity, CATIOmyIncidentCell_var & ohIncidentCell) = 0;
/**
* @deprecated  V6R2015
* @use CATOmxIter<CATIOmyIncidentCell> CATIOmyIncidentCollector#Iterator
*/
  virtual HRESULT GetIncidentIterator(CATString & iEntityTypeFilter, CATIOmyIncidentIterator_var & ohIncidentIterator) = 0;

  /**
  * @deprecated  V6R2015
  * @use CATOmxSR<CATError> CATIOmyIncidentCollector#CreateIncidentCell
  */
  virtual HRESULT CreateIncidentCell(CATError& iError) = 0;

  /**
  * Empties the Incident Collector
  * Deletes all Incident Cells remaining into the Incident Collector
  * It should be performed after errors reporting, display or transfer to another error stack
  */
  virtual HRESULT EmptyCollector() = 0;

  /**
  * Creates a new Incident Cell in the Incident Collector from an existing CATError
  * @param iError
  *        the input CATError derivate
  *        If the Input error references an invalid key or catalog, a new generic one is created instead,
  *        that indicates the original key/catalog in default.
  * @param iContext
  *        Any text formatted information that really helps debugging error cause.
  *        This context is output in trace logs:
  * @return
  *        An handler on the error, usefull if new error created.
  */
  virtual CATOmxSR<CATError> CreateIncidentCell(CATError& iError, const CATUnicodeString& iContext) = 0;

  /**
  * Creates a new Incident Cell in the Incident Collector
  * @param iErrorKey
  *        the key describing this specific error in a given error messages catalog
  * @param iErrorCatalog
  *        the error messages catalog the error is described into
  * @param iSeverity
  *        the severity to be set on this Error
  * @param iContext
  *        Any text formatted information that really helps debugging error cause
  * @return
  *        An handler on the error created
  *
  * If the Input error references an invalid key or catalog, it is changed into a generic one that stores
  * the original key/catalog in default.
  */
  virtual CATOmxSR<CATError> CreateIncidentCell(const char* iErrorKey, const char* iErrorCatalog, CATErrorType iSeverity, const CATUnicodeString& iContext) = 0;

  /**
  * Creates a new Incident Cell in the Incident Collector
  * @param iErrorKey
  *        the key describing this specific error in a given error messages catalog
  * @param iErrorCatalog
  *        the error messages catalog the error is described into
  * @param iSeverity
  *        the severity to be set on this Error
  * @param iContext
  *        Any text formatted information that really helps debugging error cause.
  * @param iReqParms
  *        The table of parameters to be added to error message, in numbering order : /p1, /p2..etc
  *        The Request parameter tables if composite (Request-Diagnostic-Advice) message, the single parameter table otherwise.
  * @param iDiagParms
  *        The Diagnostic parameter table if composite (Request-Diagnostic-Advice) message, empty table otherwise.
  * @param iAdvParms
  *        The Advice parameter table if composite (Request-Diagnostic-Advice) message, empty table otherwise.
  * @return
  *        An handler on the error created
  *
  * If the Input error references an invalid key or catalog, it is changed into a generic one that stores
  * the original key/catalog in default.
  */
  virtual CATOmxSR<CATError> CreateIncidentCell(const char* iErrorKey, const char* iErrorCatalog, CATErrorType iSeverity, const CATUnicodeString& iContext, const CATOmxArray<CATUnicodeString>& iReqParms, const CATOmxArray<CATUnicodeString>& iDiagParms, const CATOmxArray<CATUnicodeString>& iAdvParms) = 0;

  /**
  * Gets an Iterator to scan all incidents cells in collector stack
  */
  virtual CATOmxIter<CATIOmyIncidentCell> Iterator() = 0;

  /**
   * return last created error (or null)
   */
  virtual CATOmxSR<CATIOmyIncidentCell> Last() const = 0;
};

CATDeclareHandler(CATIOmyIncidentCollector, CATBaseUnknown);
//------------------------------------------------------------------

#endif
