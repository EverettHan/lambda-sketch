// COPYRIGHT Dassault Systemes 2009
//===================================================================
//
// CATICkeExpressionRestriction.h
// This interface enables an application to restrict the types, keywords, functions that can 
// Be used in a particular expression
//
//===================================================================
//
// Usage notes:
//   New interface: describe its use here
//
//===================================================================
//
//  Jan 2009  Creation: Code generated by the CAA wizard  FRH
//===================================================================
#ifndef CATICkeExpressionRestriction_H
#define CATICkeExpressionRestriction_H

#include "CATLifSpecs.h"
#include "CATBaseUnknown.h"
#include "CATBoolean.h"
#include "CATICkeSignature.h"

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATLifSpecs IID IID_CATICkeExpressionRestriction;
#else
extern "C" const IID IID_CATICkeExpressionRestriction ;
#endif

class CATUnicodeString;

//------------------------------------------------------------------

/**
* Interface representing an object that takes the responsibility to restrict the keywords, types and methods
* that can be used in a particular expression.<br>
*
* This interface is implemented by an application (MUST inherit from CATCkeExpressionRestrictionAdapter.
* Then it is passed to the CATCkeParser class that represents
* an editor of such an expression. When the parser finds types/methods/keywords, it calls this interface to validate or invalidate
* the presence of keywords.<br
* @see CATICkeSignature
*
*/
class ExportedByCATLifSpecs CATICkeExpressionRestriction: public CATBaseUnknown
{
  CATDeclareInterface;

  public:

     /**
     * This enum indicates the result of the restriction on a keyword/method/type.<br>
 	 * @param Supported
 	 * The keyword/type/method is authorized in the context of this kind of expression 
 	 * @param Forbidden
 	 * The keyword/type/method is forbidden in the context of this kind of expression /
	 * Only in this case, a parse error will be raised
  	 * @param Hidden
 	 * The keyword/type/method is hidden in the browser but authorized
  	 * @param NotEnoughInformation
 	 * Sometimes we ask for the validation having partial information (names). If it is not sufficient, the application
	 * returns NotEnoughInformation. Ideally, it should never happen. Then the more precise method will be called
  	 * @param DontKnow
     * Sometimes the application knows that it wants to forbid some elements but cannot assess everything. 
	 * In this case, it answers DontKnow.
     */
	  enum RestrictionStatus { Authorized, Forbidden, Hidden, NotEnoughInformation, DontKnow };

	/**
     * This method retrieves the NLS name of the kind of expression (reason why there is a restriction).<br>
	 * This name is used to build parse errors saying something like this "the keyword else can not be used in a ** "
	 * ** is replaced by the name returned by NameOfExpressionKind.<br>
	 * @return NLS name of the kind of expression
     */
	  virtual CATUnicodeString NameOfExpressionKind () const = 0;

  	  /** 
       * Declares interest of the restriction. Do we want to be called.<br>
	   * Very important method for performance
	   * @param iInterestedInTypes I want to be called on ValidateType on types of objects
	   * @param iInterestedInTypesOfValues I want to be called on ValidateType on types of values
	   * @param iInterestedInKeyword I want to be called on ValidateKeyword
	   * @param iInterestedInSignature I want to be called on ValidateSignature
	   * @param iInterestedInAttributes I want to be called on ValidateAttribute
	   * @return the answer from the application
       */
	  virtual void DeclareInterest (  CATBoolean &iInterestedInTypes,
									  CATBoolean &iInterestedInTypesOfValues,
									  CATBoolean &iInterestedInKeyword,
									  CATBoolean &iInterestedInSignature,
									  CATBoolean &iInterestedInAttributes) const = 0; 

	  /**
       * Asks for the validation of a keyword (let for while).<br>
	   * @param iKeyword the keyword (if, for)
	   * @return the answer from the application
       */
	  virtual RestrictionStatus ValidateKeyword (const CATUnicodeString &iKeyword) const = 0; 

	  /**
       * Asks for the validation of a signature. Use CATICkeSignature::Notation if you're interested by some cases.<br>
	   * @param iSignature the function
	   * @return the answer from the application
       */
	  virtual RestrictionStatus ValidateSignature (const CATICkeSignature_var &iSignature) const = 0; 

	  /**
       * Asks for the validation of a signature.<br>
	   * At this stage we have only the name and the notation which could be sufficient. 
	   * @param iSignatureName the name of the type.
	   * @param iSignatureNotation the name of the type.
	   * @return the answer from the application
       */
	  virtual RestrictionStatus ValidateSignature (const CATUnicodeString &iSignatureName, const CATICkeSignature::Mode iNotation	) const = 0; 

	  /**
       * Asks for the validation of a type.<br>
	   * @param iType the type
	   * @param iIsAValue TRUE is the type is a type of value, FALSE if it is a type of object
	   * @return the answer from the application
       */
	  virtual RestrictionStatus ValidateType (const CATICkeType_var &iType,const CATBoolean iIsAValue=FALSE) const = 0; 

	  /**
       * Asks for the validation of a type.<br>
	   * At this stage we have only the name which could be sufficient. 
	   * @param iTypeName the name of the type.
	   * @return the answer from the application
       */
	  virtual RestrictionStatus ValidateType (const CATUnicodeString &iTypeName,const CATBoolean iIsAValue=FALSE) const = 0; 



};
CATDeclareHandler(CATICkeExpressionRestriction,CATBaseUnknown);

//------------------------------------------------------------------

#endif
