//===================================================================
// COPYRIGHT Dassault Systemes 2018/02/27
//===================================================================
// CATSGMsgLoopJobs.cpp
// Header definition of class CATSGMsgLoopJobs
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2018/02/27 Creation: Code generated by the 3DS wizard
//===================================================================

#ifndef CATSGMsgLoopJobs_H
#define CATSGMsgLoopJobs_H

#include "CATSGUtil.h"

#ifdef SG_COMPOSITES_MULTIOS
#include "CATIOJobQueue.h"

class CATSGContext;

typedef enum {
    CATSGRepCountType_Undefined = 0,
    CATSGRepCountType_VisibleLoadedCGRs,
    CATSGRepCountType_VisibleUnloadedCGRs,
    CATSGRepCountType_VisibleLoadedReps,
    CATSGRepCountType_VisibleUnloadedReps
} CATSGRepCountType;

/**
 * This is needed because there is a gap of ~6 frames between reality and what we get from CullingRest.
 *  Because LDH is called before, in practice we have 7 frames
 * Without delay a object will be loaded and unloaded indefinitely.
 * Delay is 6 frames, but because of how we increment _pastVisiblity we need to take into account thatâ€™s why we need 8 frames before start unload
 * TODO Understand why we need 10 and not 8....
 */
#define LDH_UNLOAD_DELAY 10

class ExportedBySGComposites CATSGMsgLoopJobs
{
public:
    CATSGMsgLoopJobs(CATSGContext* iSGContext = nullptr);
    CATSGMsgLoopJobs(CATSGContext& iSGContext, const CATSGMsgLoopJobs& iMaster);
    CATSGMsgLoopJobs(CATSGMsgLoopJobs&& iOther) = default; // <- default move constructor
    CATSGMsgLoopJobs& operator=(CATSGMsgLoopJobs&& iOther) = default; // <- default move operator
    ~CATSGMsgLoopJobs();

    void InitMaxNbJobs();
    void InitMaxNbJobs(const CATSGMsgLoopJobs& iMaster);

    int     GetNbJobs(const ECATIOMsgLoopJobCategory iCategory);
    int     GetMaxNbJobs(const ECATIOMsgLoopJobCategory iCategory);
    HRESULT SetMaxNbJobs(const ECATIOMsgLoopJobCategory iCategory, const int iNewSizeLimit);
    // return true If some Load or Unload was call during this frame
    bool     GetIsWorking() const;
    bool     GetIsWorkingLoad() const;
    bool     GetIsWorkingUnload() const;
    /*
    * Return true while GetIsWorking() is true with a little margin of a few frames.
    * This is to make sure to wait for some potential unload.
    * See CATKDopOutOfCoreCGR::StreamTo and CATKDopOutOfCore::StreamTo
    */
    bool     GetWasWorking() const;
    bool     GetWasWorkingLoad() const;
    bool     GetWasWorkingUnload() const;
    void     SetIsWorkingUnload();
    void     SetIsWorkingLoad();
    void     ResetIsWorking();

    float   GetThreshold(const ECATIOMsgLoopJobCategory iCategory);

    HRESULT AddMsgLoopJob(CATIOJob& iJob, const ECATIOMsgLoopJobCategory iCategory);

    HRESULT Sort();

    void     Merge(CATSGMsgLoopJobs&& iOtherJobs);

    void     RunJobs();

    void            IncrementRepCount(CATSGRepCountType iType);
    CATSG::uint64   GetRepCount(CATSGRepCountType iType) const;
    void            SetRepCount(CATSGRepCountType iType, CATSG::uint64 iValue);

    CATSG::uint64   GetNbViewers() const;
    void            SetNbViewers(CATSG::uint64 iNbViewers);

    struct TimeStruct
    {
        CATSG::int64    firstStamp;
        CATSG::int64    prevStamp;
        CATSG::int64    lastStamp;
        CATSG::uint64   nbStamps;

        CATSG::uint64   nbWorkStamps;
        CATSG::uint64   workDuration;
    };
    const TimeStruct&   GetTimeStruct() const;
    static double       GetCurrentFramerate(const TimeStruct& iTime);
    static double       GetAverageFramerate(const TimeStruct& iTime);
    static double       GetAverageWorkingFramerate(const TimeStruct& iTime);
    void                UpdateTimeStamp(CATSG::int64 iTimeStamp);

private:
    struct FrameStruct
    {
        CATSG::int64 timeThisFrameDL;
        CATSG::int64 timeThisFrameLoadCGR;
        CATSG::int64 timeThisFrameLoadRep;
        CATSG::int64 timeThisFrameUnloadRep;
        CATSG::int64 timeThisFrameUnloadCGR;

        int doneThisFrameDL;
        int doneThisFrameLoadCGR;
        int doneThisFrameLoadRep;
        int doneThisFrameUnloadRep;
        int doneThisFrameUnloadCGR;

        int nbIOJobsFromLastFrame;
    };
    void UpdateMaxNbJobs();
    void TooManyJobs(const ECATIOMsgLoopJobCategory iCategory, double iFactorNbJobs);
    void NotEnoughJobs(const ECATIOMsgLoopJobCategory iCategory, double iFactorNbJobs);

private:
    CATSGMsgLoopJobs(const CATSGMsgLoopJobs& iOther) = delete;
    CATSGMsgLoopJobs& operator=(const CATSGMsgLoopJobs& iOther) = delete;

private:
    /*
    Reset to false by CATSGRessourcesManagerDefaultImpl before every cycle when we need a collect
    Set to true, by CATKDopOutOfCoreCGR CATKDopOutOfCore, when we do a load or unload
    */
    bool          _isWorkingLoad;
    bool          _isWorkingUnload;
    uint8_t       _noLoadSince;
    uint8_t       _noUnloadSince;
    CATSGContext* _sgContext;

    CATIOJobQueue _msgLoopIODownloadJobs;
    CATIOJobQueue _msgLoopIOLoadCGRJobs;
    CATIOJobQueue _msgLoopIOUnloadCGRJobs;
    CATIOJobQueue _msgLoopIOLoadRepJobs;
    CATIOJobQueue _msgLoopIOUnloadRepJobs;
    CATIOJobQueue _msgLoopIOJobs;

    CATSG::uint64 _nbViewers;

    CATSG::uint64 _nbVisibleLoadedCGRs;
    CATSG::uint64 _nbVisibleUnloadedCGRs;
    CATSG::uint64 _nbVisibleLoadedReps;
    CATSG::uint64 _nbVisibleUnloadedReps;

    TimeStruct _time;
    FrameStruct _frameInfo;
};

#endif // SG_COMPOSITES_MULTIOS
#endif // CATSGMsgLoopJobs_H
