// COPYRIGHT Dassault Systemes 2004
//===================================================================
//
// CATPolyExactArithmetic.h
// Header definition of CATPolyExactArithmetic
//
// THE 3D DELAUNAY HIERARCHY, by Olivier DEVILLERS
// Copyright (c) 1998 Olivier Devillers, INRIA Sophia-Antipolis
//===================================================================
// This file contains the exact predicates Insphere and Orientation3D.
// Notice that using ArithmeticTool to evaluate Insphere requires setting the _PFLAG field
// from the triangulation using the arithmeticTool.
//
//===================================================================
//
// May 2004  Creation: Code generated by the CAA wizard  rxu
//===================================================================
#ifndef CATPolyExactArithmetic_H
#define CATPolyExactArithmetic_H

#include "PolyMathArithmetic.h"

// Mathematics
#include "CATMathPoint.h"
#include "CATMathPoint2D.h"
#include "CATMathInline.h"

// System
#include "CATIAV5Level.h"

/**
 * Class that computes predicates using exact arithmetic for robust geometry.
 */
class ExportedByPolyMathArithmetic CATPolyExactArithmetic
{

public:

  /**
   * Mode defining how the exact arithmetic is computed.
   * For the gridded mode, the numbers must be gridded prior to predicate calls.
   */
  enum Mode
  {
    /** Computation is done with gridded coordinates (integer arithmetic). */   eGridded = 0,
                                                                              //eInteger = 0,
    /** Computation is done with numbers in floating precision. */              eFloat,
    /** Computation is done with numbers in double presison. */                 eDouble
  };

public:

  /**
   * Constructor of an instance of exact arithmetic.
   * By default the exact arithmetic is computed with gridded coordinates.
   */
  CATPolyExactArithmetic (const Mode iMode = eGridded);
  ~CATPolyExactArithmetic ();

  /**
   * Returns the mode in which the computation of the exact arithmetic is done.
   */
  INLINE Mode GetMode () const;

public:

/** @name Gridding Methods
    @{ */

  /**
   * Sets the range of the coordinates.  (Gridded mode.)
   */
  void SetMaxCoord (const float d);

  /**
   * Gets the range of the coordinates.  (Gridded mode.)
   */
  float GetMaxCoord () const;

  /**
   * Returns the maximum coordinate possible after gridding.  (Range of the grid.)
   */
  INLINE float GetMaxNormalizedCoord () const;

  INLINE int IsPointInMAX23Range (const float x, const float y, const float z) const;

  /**
   * Returns the precision of the coordinates after gridding.  This is also the maximum error
   * that can be made after gridding of the coordinates.
   */
  INLINE double GetCoordinatePrecision () const;

public:

  /**
   * Grids a float value.
   */
  void Grid (float& ioValue) const;

  /**
   * Grids a double value.
   */
  void Grid (double& ioValue) const;

  /**
   * For integer arithmetic only (eGridded), grids a float value.
   */
  INLINE void Normalize (float& ioValue) const;

  /**
   * For integer arithmetic only (eGridded), grids a double value.
   */
  INLINE void Normalize (double& ioValue) const;

  /**
   * For integer arithmetic only (eGridded), grids a 3D point.
   */
  void Normalize (CATMathPoint& ioPoint) const;

  /**
   * For integer arithmetic only (eGridded), grids a 2D point.
   */
  void Normalize (CATMathPoint2D& ioPoint) const;

/** @} */

public:

/** @name Comparison Methods
    @{ */

  /**
   * Returns +1 if the two doubles are equal and 0 otherwise.
   */
  static INLINE int Equal (const double a, const double b);

  /**
   * Returns +1 if the two points have the same geometrical position and 0 otherwise.
   */
  static INLINE int Equal (const CATMathPoint2D& A, const CATMathPoint2D& B);

  /**
   * Returns +1 if the two points have the same geometrical position and 0 otherwise.
   */
  static INLINE int Equal (const CATMathPoint& A, const CATMathPoint& B);

  /**
   * Compares the two values a and b.
   * @param a
   *   The first value.
   * @param b
   *   The second value.
   * @return
   * <ul>
   *   <li> +1 if a > b
   *   <li>  0 if a = b
   *   <li> -1 if a < b
   * </ul>
   */
  static int Compare (const double a, const double b);

  /**
   * Compares the x-coordinates of the two points; if the x-coordinates are equal, then compares
   * the y-coordinates of the two points.
   * @param iPoint0
   *   The first point.
   * @param iPoint1
   *   The second point.
   * @return
   * <ul>
   *   <li> +1 if x0 > x1 or x0 = x1 and y0 > y1    (A is right of B)
   *   <li>  0 if x0 = x1 and y0 = y1               (A is equal to B)
   *   <li> -1 if x0 < x1 or x0 = x1 and y0 < y1    (A is left of B)
   * </ul>
   *
   * @see CATPolyCompareLeftRight
   */
  static int CompareLeftRight (const CATMathPoint2D& A, const CATMathPoint2D& B);

  /**
   * Compares the y-coordinates of two points; if the y-coordinates are equal,
   * then compares the x-coordinates of the two points.
   * @param iPoint0
   *   The first point.
   * @param iPoint1
   *   The second point.
   * @return
   * <ul>
   *   <li> +1 if y0 > y1 or y0 = y1 and x0 > x1     (A is above of B)
   *   <li>  0 if y0 = y1 and x0 = x1                (A is equal to B)
   *   <li> -1 if y0 < y1 or y0 = y1 and x0 < x1     (A is below of B)
   * </ul>
   *
   * @see CATPolyCompareBelowAbove
   */
  static int CompareBelowAbove (const CATMathPoint2D& A, const CATMathPoint2D& B);

/** @} */

public:

/** @name Orientation Methods
    @{ */

  /**
   * Computes the orientation of three two-dimensional points.
   * This is equivalent to computing a 2x2 determinant.
   *   @param A
   *     The first point.
   *   @param B
   *     The second point.
   *   @param C
   *     The third point.
   *   @return
   *     <ul>
   *       <li> +1 if A, B, C appear in counterclockwise order.
   *       <li> 0 if A, B, C are aligned.
   *       <li> -1 if A, B, C appear in clockwise order.
   *     </ul>
   */
  static int Orientation2D (const CATMathPoint2D& A, const CATMathPoint2D& B, const CATMathPoint2D& C);

  /**
   * Computes the orientation of three two-dimensional points.
   * This is equivalent to computing a 2x2 determinant.
   *   @param a
   *     The first point.
   *   @param b
   *     The second point.
   *   @param c
   *     The third point.
   *   @return
   *     <ul>
   *       <li> +1 if A, B, C appear in counterclockwise order.
   *       <li> 0 if A, B, C are aligned.
   *       <li> -1 if A, B, C appear in clockwise order.
   *     </ul>
   */
  static int Orientation2D (const double a[2], const double b[2], const double c[2]);

  /**
   * Computes the orientation of four three-dimentional points.
   * This is equivalent to computing a 3X3 determinant.
   *   @param A
   *     The first point.
   *   @param B
   *     The second point.
   *   @param C
   *     The third point.
   *   @param D
   *     The fourth point.
   *   @return
   *     <ul>
   *       <li> +1 if D is above a plane through A, B, C where above is the direction of the right-handed screw
   *            at A that turns from B toward C.
   *       <li>  0 if A, B, C, D are coplanar.
   *       <li> -1 if D is below a plane through A. B. C.
   *     </ul>
   */
  int Orientation3D (const CATMathPoint &A, const CATMathPoint &B, const CATMathPoint &C, const CATMathPoint &D) const;

  /**
   * Computes the orientation of four three-dimentional points.
   * This is equivalent to computing a 3X3 determinant.
   *   @param a
   *     The first point.
   *   @param b
   *     The second point.
   *   @param c
   *     The third point.
   *   @param d
   *     The fourth point.
   *   @return
   *     <ul>
   *       <li> +1 if D is above a plane through A, B, C where above is the direction of the right-handed screw
   *            at A that turns from B toward C.
   *       <li>  0 if A, B, C, D are coplanar.
   *       <li> -1 if D is below a plane through A. B. C.
   *     </ul>
   */
  int Orientation3D (const double a[3], const double b[3], const double c[3], const double d[3]) const;

/** @} */

public:

  /**
  * @brief Given two triangles intersecting a ray along the Z axis, determines which triangle intersects the ray first.
  * @details This function is based on exact predicates, and could be a bit expansive.
  * @param iRayOrigin[in] : a point the ray is going through along the Z axis.
  * @param iFstTriangle[in] : the three points of the first triangle intersecting the ray.
  * @param iSndTriangle[in] : the three points of the second triangle intersecting the ray.
  * @return
  * <ul>
  * <li> 1 if the first triangle intersects the ray lower on the Z axis than the second triangle,
  * <li> -1 if the second triangle intersects the ray lower on the Z axis than the first triangle,
  * <li> 0 if both triangles intersect the ray exactly at the same point.
  * </ul>
  */
  int CompareTrianglesAlongVerticalRay (const CATMathPoint& iRayOrigin, const CATMathPoint iFstTriangle[3], const CATMathPoint iSndTriangle[3]) const;

  /**
  * @brief Compares the position of two triangles sharing a vertex along a meridian line (the geodesic) on an infinitesimally small sphere centered on the common vertex.
  * @details The triangles are supposed to intersect the meridian line, and the intersection should be a single point.
  * This implies that triangle normals should never be orthogonal to the vertical (Z) axis.
  * This method is generally meant as a way to determine which triangle is "above" the other when they share a vertex.
  * @param iCommonPnt[in] : the point shared by both triangles, and the center of the sphere the meridian line is on.
  * @param iGeodesicEndPnt[in] : a point which is not directly above or below the common point and defines which meridian line is used on the sphere through its azimuth.
  * @param iFstTrianglePnt0|in] : first non common point of the first triangle.
  * @param iFstTrianglePnt1|in] : second non common point of the first triangle.
  * @param iSndTrianglePnt0|in] : first non common point of the second triangle.
  * @param iSndTrianglePnt0|in] : second non common point of the second triangle.
  * @return
  * <ul>
  * <li> 1 if the polar angle of the first triangle along the meridian line is larger than that of the second triangle,
  * <li> -1 if the polar angle of the first triangle along the meridian line is smaller than that of the second triangle,
  * <li> 0 if they are equal.
  * </ul>
  */
  int CompareTrianglesAlongGeodesic (const CATMathPoint& iCommonPnt, const CATMathPoint& iGeodesicEndPnt,
                                     const CATMathPoint& iFstTrianglePnt0, const CATMathPoint& iFstTrianglePnt1,
                                     const CATMathPoint& iSndTrianglePnt0, const CATMathPoint& iSndTrianglePnt1) const;
  /**
  * @brief Compares the polar angles of two points in a spherical coordinates system.
  * @details Only the origin of the spherical coordinates system needs to be provided.
  * The vertical axis the polar angle is computed from is the Z axis.
  * @param iOrigin[in] : the origin of the coordinate system in which to compare polar angles.
  * @param iPnt0[in] : first point.
  * @param iPnt1[in] : second point.
  * @return
  * <ul>
  * <li> 1 if the polar angle of the second point is greater than the first point,
  * <li> -1 if the polar angle of the second point is smaller than the first point,
  * <li> 0 if they are equal.
  * </ul>
  */
  int ComparePolarAngles (const CATMathPoint& iOrigin, const CATMathPoint& iPnt0, const CATMathPoint& iPnt1) const;

public:

/** @name InCircle, InSphere Methods
    @{ */

  /**
   * Computes the position of a point with respect to a circle
   * defined by three points.  The coordinates of the points do
   * not need to be gridded.
   *   @param A
   *     The first point.
   *   @param B
   *     The second point.
   *   @param C
   *     The third point.
   *   @param P
   *     The point to check.
   *   @return
   *     <ul>
   *       <li> +1 if P is inside the circle defined by A, B, C.
   *       <li>  0 if P is on the circle defined by A, B, C.
   *       <li> -1 if P is outside the circle defined by A, B, C.
   *     </ul>
   */
  int InCircle (const CATMathPoint2D& A, const CATMathPoint2D& B, const CATMathPoint2D& C, const CATMathPoint2D& P) const;

/** @} */

public:
/** @name CloserTo Methods
    @{ */

    /**
     * Determines whether point P is closer to A or B.
     *   @param P
     *     The point to whom we compute distance.
     *   @param A
     *     The first point.
     *   @param B
     *     The second point.
     *   @return
     *     <ul>
     *       <li> +1 if P is closer to A.
     *       <li>  0 if P is equidistant to A and B.
     *       <li> -1 if P is closer to B.
     *     </ul>
     */
    int CloserTo (const CATMathPoint2D& P, const CATMathPoint2D& A, const CATMathPoint2D& B) const;

    /**
     * Determines whether point P is closer to A or B.
     *   @param P
     *     The point to whom we compute distance.
     *   @param A
     *     The first point.
     *   @param B
     *     The second point.
     *   @return
     *     <ul>
     *       <li> +1 if P is closer to A.
     *       <li>  0 if P is equidistant to A and B.
     *       <li> -1 if P is closer to B.
     *     </ul>
     */
    int CloserTo (const double p[2], const double a[2], const double b[2]) const;

    /**
     * Determines whether the euclidian distance between A and B is shorter than the euclidian distance between C and D or not.
     *   @param A
     *     The first point of the first segment.
     *   @param B
     *     The second point of the first segment.
     *   @param C
     *     The first point of the second segment.
     *   @param D
     *     The second point of the second segment.
     *   @return
     *     <ul>
     *       <li> +1 if norm(A,B) < norm(C, D).
     *       <li>  0 if norm(A,B) = norm(C, D)
     *       <li> -1 if norm(A,B) > norm(C, D)
     *     </ul>
     */
    int CloserTo (const CATMathPoint2D& A, const CATMathPoint2D& B, const CATMathPoint2D& C, const CATMathPoint2D& D) const;
/** @} */

public:
/** @name Colinearity Tests
    @{ */

  /**
  * Test whether three points are colinear in the space using exact predicates.
  *   @param A
  *   @param B
  *   @param C
  *   @return
  *      TRUE if the points are colinear and FALSE otherwise.
  */
  CATBoolean AreColinear(const CATMathPoint& A, const CATMathPoint& B, const CATMathPoint& C) const;
/** @} */

public:

  double Determinant3D(const CATMathPoint &A, const CATMathPoint &B, const CATMathPoint &C, const CATMathPoint &D) const;

  double Determinant3D(const double a[3], const double b[3], const double c[3], const double d[3]) const;

  double Determinant3D(const CATMathVector & D0, const CATMathVector & D1, const CATMathVector & D2) const;

  double Determinant2D(const CATMathPoint2D& A, const CATMathPoint2D& B, const CATMathPoint2D& C) const;

  double Determinant2D(const double a[2], const double b[2], const double c[2]) const;

 public:
   /**
   * Sign of (B-A)*D
   */
   int DotSign(const CATMathPoint & A, const CATMathPoint & B, const CATMathVector & D) const;

 
private:

  double ExactDeterminant3D(const CATMathPoint &A,const CATMathPoint &B, const CATMathPoint &C, const CATMathPoint &D) const;

  double GriddedDeterminant3D (const double a[3], const double b[3], const double c[3], const double d[3]) const;

  double GriddedDeterminant2D (const double a[2], const double b[2], const double c[2]) const;

private:

  void Split (double a, double &a1, double &a0, const double &format) const;

  // Constants and scaled constants.
  // Data are supposed to be an integer on 24 bits * MAX0 see values of constants below.

  double MAX0 ;              // precision on coordinates
  double MAX24 ;             // bounding box size
  double MAX23 ;             // bound on coordinates
  double SNAP_TO_GRID ;      // for rounding of coordinates
  double _split_2_25 ;       // split to bit MAX0^2 * 2^25
  double _split_3_25 ;       // split to bit MAX0^3 * 2^25
  double _split_3_51 ;       // split to bit MAX0^3 * 2^51
  double C1_ORIENTATION_3D ; // static orientation filter
  double C2_ORIENTATION_3D ; // semi-static orientation filter
  double C3_ORIENTATION_3D ; // semi-static orientation filter
  double C0_INSPHERE_3D ;    // static insphere filter with equation
  double C00_INSPHERE_3D ;   // semi-static insphere filter with equation
  double C0a_INSPHERE_3D ;   // semi-static insphere filter with equation
  double C0b_INSPHERE_3D ;   // semi-static insphere filter with equation
  double C1_INSPHERE_3D ;    // static insphere filter
  double C2_INSPHERE_3D ;    // semi-static insphere filter
  double C3_INSPHERE_3D ;    // semi-static insphere filter

  Mode _Mode;
  float _MaxCoord ;
};


INLINE CATPolyExactArithmetic::Mode CATPolyExactArithmetic::GetMode () const
{
  return _Mode;
}

//==============================================================================================================
// Function : Split
// Purpose  : Split a in two numbers.
//            a = a1 + a0, a1 get the most significant digit
//            format specify the range of the input, and how to split if format is _split_i_j it means that a is
//            of degree i (in terms of original coordinates) the splitting bit is MAX0^i*2^j
//==============================================================================================================
INLINE void CATPolyExactArithmetic::Split (double a, double &a1, double &a0, const double &format) const
{
  a1 = (a + format) - format ;
  a0 = a - a1 ;
}

INLINE float CATPolyExactArithmetic::GetMaxCoord () const
{
  return _MaxCoord ;
}

INLINE float CATPolyExactArithmetic::GetMaxNormalizedCoord () const
{
  float coord = _MaxCoord;
  Normalize (coord);
  return coord;
}

INLINE int CATPolyExactArithmetic::IsPointInMAX23Range (float x, float y, float z) const
{
  if ((x > MAX23) || (x < -MAX23) ||
      (y > MAX23) || (y < -MAX23) ||
      (z > MAX23) || (z < -MAX23))
  {
    return 0 ;
  }

  return 1 ;
}

INLINE double CATPolyExactArithmetic::GetCoordinatePrecision () const
{
  return MAX0;
}

INLINE int CATPolyExactArithmetic::Equal (const double a, const double b)
{
  return a == b ? 1 : 0;
}

INLINE int CATPolyExactArithmetic::Equal (const CATMathPoint2D& A, const CATMathPoint2D& B)
{
  return (A.GetX () == B.GetX () && A.GetY () == B.GetY ()) ? 1 : 0;
}

INLINE int CATPolyExactArithmetic::Equal (const CATMathPoint& A, const CATMathPoint& B)
{
  return (A.GetX () == B.GetX () && A.GetY () == B.GetY () && A.GetZ () == B.GetZ ()) ? 1 : 0;
}

INLINE int CATPolyExactArithmetic::Compare (const double a, const double b)
{
  return a < b ? -1 : (a > b ? +1 : 0);
}

INLINE void CATPolyExactArithmetic::Normalize (float& ioValue) const
{
  if (_Mode == eGridded)
    Grid (ioValue);
}


INLINE void CATPolyExactArithmetic::Normalize (double& ioValue) const
{
  if (_Mode == eGridded)
    Grid (ioValue);
}

#endif
