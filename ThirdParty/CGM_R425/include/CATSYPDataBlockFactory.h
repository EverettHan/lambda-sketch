//===================================================================
// COPYRIGHT DASSAULT SYSTEMES 2011/08/04
//===================================================================
// CATSYPDataBlockFactory.h
// Header definition of class CATSYPDataBlockFactory
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2011/08/04 Creation: Code generated by the 3DS wizard  VV6
//===================================================================

#ifndef CATSYPDataBlockFactory_H
#define CATSYPDataBlockFactory_H

#include <IntroInfra.h>
#include <CATBaseUnknown.h>
#include <CATSYPArray.h>
#include <CATSYPPropertyDescriptor.h>
#include <CATSYPEventHandlerDescriptor.h>
#include <CATSYPWRefMethEventHandler.h>
#include <CATSYPEventArgs.h>

class CATUnicodeString;
class CATSYPMetaClass;
class CATSYPDataBlock;

/**
 * The definition of an event handler function object for CATSYPDataBlock.
 * This function object is responsible to return the event handler associated.
 */
class ExportedByIntroInfra CATSYPGetPointerEventHandler : public CATSYPEventHandlerGetter
{
public:
  /**
   * Constructor
   * @param i_pHandler the pointer on an event handler to store inside this
   * function object. The CATSYPGetPointerEventHandler takes the ownership
   * of the given pointer.
   */
  CATSYPGetPointerEventHandler(CATSYPEventHandler * i_pHandler);

  /** Destructor */
  virtual ~CATSYPGetPointerEventHandler();

  /**
   * Get the associated event handler.
   * @param i_pImplementation the object on which the event handler is used.
   * @return the corresponding CATSYPEventHandler.
   */
  virtual CATSYPEventHandler * GetEventHandler(CATBaseUnknown * i_pImplementation);

private:
  /** The embedded event handler */
  CATSYPEventHandler * _pEventHandler;
};


/**
 * Factory class dedicated to build CATSYPDataBlock instances.
 *
 * It behaves to let CATSYPDataBlock objects share the same meta-class as long
 * as they share the same properties.
 * So, as soon as a new property is added or removed from the factory, the
 * CATSYPDataBlock objects built after that will have a totally different meta-class
 * from the previously built CATSYPDataBlock objects.
 *
 * @par Adding a property
 * To be able to generate CATSYPDataBlock objects that hold a particular property,
 * the property description must be registered on the CATSYPDataBlockFactory
 * used to generate the data block objects. This is done using the @ref AddProperty
 * member function. The following pieces of information must be provided:
 *    - The name of the property
 *    - The type of the property
 *    - The access mode of the property (Read-only, ...)
 *    - The tweak type of the property used to generate automatically its view
 *    - The default value of the property (it must be boxed in case of a type
 *      that doesn't inherit from CATBaseUnknown
 *    - The value type flag.
 *
 * @par
 * The following code snippet shows how to register two properties on a
 * CATSYPDataBlockFactory:
 *
 * @par
 * @code
 * CATSYPDataBlockFactory dbFactory;
 *
 * // Register a first property description for the Name property
 * dbFactory.AddProperty("Name", "CATUnicodeString", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfCATUnicodeString::Box("Default"));
 *
 * // Register a second property description for the Age property
 * dbFactory.AddProperty("Age", "int", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfint::Box(0));
 * @endcode
 *
 * @par
 * All the generated datablock using the @ref CreateDataBlock member function of
 * @c dbFactory object will have the two registered properties Name and Age.
 *
 * @par
 * You can use the @ref RemoveProperty member function to remove a previously
 * registered property descripton from a CATSYPDataBlockFactory object.
 *
 * @par Adding an event handler
 * To be able to generate CATSYPDataBlock objects that hold a particular event
 * handler (see @ref CATSYPEventHandler), the event handler description must
 * be registered on the CATSYPDataBlockFactory used to generate the data block
 * objects. This is done using the @ref AddEventHandler member function and
 * giving it a name for the event handler and the @ref CATSYPEventHandler
 * pointer.
 *
 * @par
 * The following sample shows how to register an event handler:
 *
 * @par
 * @code
 * // The definition of the function used as callback
 * void my_static_callback(CATBaseUnknown * i_pSender, CATSYPEventArgs * i_pArgs)
 * {
 *    // its implementation...
 * }
 *
 * // The data blocks factory
 * CATSYPDataBlockFactory dbFactory;
 *
 * // Register directly a CATSYPEventHandler
 * CATSYPStaticEventHandler<CATSYPEventArgs> pStaticEventHandler = new CATSYPStaticEventHandler<CATSYPEventArgs>(my_static_callback);
 * CHECK_POINTER_RET(pStaticEventHandler);
 * dbFactory.AddEventHandler("MyEventHandler", pStaticEventHandler);
 * @endcode
 *
 * @par
 * All the generated datablocks using the @ref CreateDataBlock member function
 * dbFactory object will have access to the event handler registered.
 *
 * @par
 * You can use the @ref RemoveEventHandler to remove a previously registered
 * event handler descripton from a CATSYPDataBlockFactory object.
 *
 * @par Sample to summarize
 * The following sample shows how to use a CATSYPDataBlockFactory to create
 * a datablock by filling it with two properties and an event handler:
 *
 * @par
 * @code
 * // The definition of the function used as callback
 * void my_static_callback(CATBaseUnknown * i_pSender, CATSYPEventArgs * i_pArgs)
 * {
 *    // its implementation...
 * }
 *
 * // The databloc factory object
 * CATSYPDataBlockFactory dbFactory;
 *
 * // Register the two property descriptions
 * dbFactory.AddProperty("Name", "CATUnicodeString", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfCATUnicodeString::Box("Default"));
 * dbFactory.AddProperty("Age", "int", CATSYPDataBlockFactory::ReadWrite, "", CATBoxingOfint::Box(0));
 *
 * // Register the event handler description
 * CATSYPStaticEventHandler<CATSYPEventArgs> * pStaticEventHandler = new CATSYPStaticEventHandler<CATSYPEventArgs>(my_static_callback);
 * CHECK_POINTER_RET(pStaticEventHandler);
 * dbFactory.AddEventHandler("MyEventHandler", pStaticEventHandler);
 *
 * // Create a data block using the factory
 * // The created data block will have the two properties Name and Age and the
 * // event handler MyEventHandler.
 * CATSYPDataBlock * pDataBlock = dbFactory.CreateDataBlock();
 * CHECK_POINTER_RET(pDataBlock);
 *
 * //... use your datablock, for example you can retrieve the value of one of its property
 * CATBaseUnknown_var spValue = pDataBlock->GetProperty("Name");
 * CATUnicodeString nameValue;
 * HRESULT rc = CATBoxingOfCATUnicodeString::Unbox(spValue, nameValue);
 * if (SUCCEEDED(rc))
 * {
 *    // Here, nameValue is equal to "Default"
 * }
 *
 * pDataBlock->Release();
 * pDataBlock = NULL;
 * @endcode
 *
 * @see CATSYPDataBlock
 * @see groupSypEvent
 */
class ExportedByIntroInfra CATSYPDataBlockFactory
{
public:
  /**
   * Enumeration of the access modes of a property (similar as the one inside
   * CATSYPPropertyDescriptor).
   */
  enum Access
  {
    ReadWrite = 0,
    ReadOnly,
    WriteOnly
  };

  /**
   * Default constructor that constructs an empty CATSYPDataBlockFactory
   * object. Properties descriptions and event handlers descriptions can
   * then be registered to this CATSYPDataBlockFactory.
   *
   * Note that two different factories will produce datablocks with
   * different meta-class.
   */
  CATSYPDataBlockFactory ();

  /**
   * Destructor
   */
  virtual ~CATSYPDataBlockFactory ();

  /**
   * Adds a new property into a data block by saving it into the factory.
   *
   * This method creates a new property description and associates the given
   * value to it. The new property can be declared as read-only, i.e., its
   * value cann't be changed after its creation.
   * This method asserts when at least one the parameters has a length equals
   * to 0.
   *
   * Two properties inside a same datablock can't have the same name. If a new
   * property has the same name as a previously registered property, then this
   * new property is not created (and its value is not registered).
   * The property is not created if the given i_type parameter doesn't correspond
   * to the type of the value.
   *
   * Calling this member function will invalidate the built meta-class. So, creating
   * a new instance of a data-block after a call to this member function results in
   * a data block that does not share the same meta-class as the previously built
   * data-block.
   *
   * @param i_name name of the property to add.
   * @param i_type type of the property to add.
   * @param i_access access mode of the property.
   * @param i_value the value to associate to the property.
   * @param i_tweakType name of the tweak type of the property.
   * @param i_value the default value of the property. This value should be
   * boxed for BoxProperty.
   * @param i_valueTypeFlag flag indicating if the property is a semantic of value (=1) or entity (=0).
   */
  void AddProperty(const CATUnicodeString & i_name, const CATUnicodeString & i_type, const CATSYPDataBlockFactory::Access i_access, const CATUnicodeString & i_tweakType, const CATBaseUnknown_var & i_value, int i_valueTypeFlag = 1, int i_uiPriority=0, const CATUnicodeString & i_declarativeName="");
	void AddProperty(const CATUnicodeString & i_name, const CATUnicodeString & i_type, const CATSYPDataBlockFactory::Access i_access, const CATUnicodeString & i_category, const CATUnicodeString & i_tweakType, const CATBaseUnknown_var & i_value, int i_valueTypeFlag = 1, int i_uiPriority=0, const CATUnicodeString & i_declarativeName="");

  /**
   * Adds a new property of type enum into a data block by saving it into
   * the factory.
   *
   * This method creates a new property description and associates the given
   * value to it. The new property can be declared as read-only, i.e., its
   * value cann't be changed after its creation.
   * This method asserts when at least one the parameters has a length equals
   * to 0.
   *
   * Two properties inside a same datablock can't have the same name. If a new
   * property has the same name as a previously registered property, then this
   * new property is not created (and its value is not registered) either the
   * new property is an enum or a type property.
   * As the given type of the property is an enum, the given value must be of type
   * CATBoxingOfint that boxes the correct value for the enum.
   *
   * Calling this member function will invalidate the built meta-class. So, creating
   * a new instance of a data-block after a call to this member function results in
   * a data block that does not share the same meta-class as the previously built
   * data-block.
   *
   * @param i_name name of the property to add.
   * @param i_type type of the property to add.
   * @param i_access access mode of the property.
   * @param i_category name of the category of the property.
   * @param i_tweakType name of the tweak type of the property.
   * @param i_value the default value of the property. This value should be
   * boxed using CATBoxingOfint.
   */
  void AddEnum(const CATUnicodeString & i_name, const CATUnicodeString & i_type, const  CATSYPDataBlockFactory::Access i_access, const CATUnicodeString & i_category, const CATUnicodeString & i_tweakType, const CATBaseUnknown_var & i_value, int i_uiPriority=0, const CATUnicodeString & i_declarativeName="");

  /**
   * Removes from the CATSYPDataBlockFactory a registered property.
   *
   * Calling this member function will invalidate the built meta-class. So, creating
   * a new instance of a data-block after a call to this member function results in
   * a data block that does not share the same meta-class as the previously built
   * data-block.
   *
   * @param i_name the name of the property to remove.
   */
  void RemoveProperty(const CATUnicodeString & i_name);

  /**
   * Shortcut member function that instanciates an event handler that stores
   * a member function pointer on an object. You should rather use
   * the @ref CATSYPDataBlockFactory#AddEventHandler(const CATUnicodeString &, CATSYPEventHandler *)
   * member function and instanciating your own event handler before.
   *
   * All the datablocks generated after an event handler has been added
   * using this member function will be built associated to the handler.
   *
   * Calling this member function will invalidate the built meta-class. So, creating
   * a new instance of a data-block after a call to this member function results in
   * a data block that does not share the same meta-class as the previously built
   * data-block.
   *
   * @param i_eventHandlerName the name of the event handler to register.
   * This name can't be an empty string.
   *
   * @param i_pInstance a pointer on the object on which the given member
   * function must be called. This pointer can't be NULL.
   *
   * @param i_pHandleFct a pointer on the member function to call when the event
   * handler is called. This function must not return a value and must
   * take a pointer on a CATBaseUnknown object, and a pointer on a CATSYPEventArgs
   * object (or inherited class). This pointer can't be NULL
   * (see @ref groupSypEventRegistration).
   *
   */
  template <class T, class ArgsType>
  void AddEventHandler (const CATUnicodeString & i_eventHandlerName,
                        T * i_pInstance,
                        void (T::*i_pHandleFct)(CATBaseUnknown *, ArgsType *))
  {
    CHECK_POINTER_RET(i_pInstance);
    CHECK_TRUE_RET(i_eventHandlerName.GetLengthInChar() > 0);
    CHECK_TRUE_RET(NULL != i_pHandleFct);

    // Register the event descriptor
    CATSYPWRefMethEventHandler<T, ArgsType> * pEventHandler = new CATSYPWRefMethEventHandler<T, ArgsType>(i_pInstance, i_pHandleFct);
    AddEventHandler(i_eventHandlerName, pEventHandler);
  }

  /**
   * Adds an event handler to the datablock factory.
   *
   * All the datablocks generated after an event handler has been added
   * using this member function will be built associated to the handler.
   *
   * Calling this member function will invalidate the built meta-class. So, creating
   * a new instance of a data-block after a call to this member function results in
   * a data block that does not share the same meta-class as the previously built
   * data-block.
   *
   * @param i_eventHandlerName the name of the event handler to register.
   * This name can't be an empty string.
   *
   * @param i_pEventHandler a pointer on the event handler object to register.
   * This event handler object must inherit from the base class
   * CATSYPEventHandler (see @ref groupSypEventRegistration).
   * This pointer can't be NULL.
   */
  void AddEventHandler (const CATUnicodeString & i_eventHandlerName, CATSYPEventHandler * i_pEventHandler);

  /**
   * Removes an event handler from the datablock factory.
   *
   * All the datablocks generated after an event handler has been removed
   * using this member function will be built without being associated
   * to the removed handler. Trying to remove an event handler not registered
   * does nothing.
   *
   * Calling this member function will invalidate the built meta-class. So, creating
   * a new instance of a data-block after a call to this member function results in
   * a data block that does not share the same meta-class as the previously built
   * data-block.
   *
   * @param i_eventHandlerName the name of the event handler to remove.
   * This name can't be an empty string.
   */
  void RemoveEventHandler (const CATUnicodeString & i_eventHandlerName);

  /**
   * Instantiates a new data block defined using the registered properties
   * and event handlers.
   *
   * This new data-block will share the same meta-class as the previously 
   * created one while no properties / event handlers are added or removed 
   * from the factory. The caller is responsible to release the returned object.
   *
   * @return a new CATSYPDataBlock object built with the registered properties
   * and event handlers or a NULL pointer in case of failure.
   */
  CATSYPDataBlock * CreateDataBlock();

  /**
   * Find the property with the given name
   * @param i_name the name of the property to look for.
   * @return the index of the property if found, otherwise -1
   */
  int FindProperty(const CATUnicodeString & i_name);

private:
  struct CATVidPairPropertyDescAndValue
  {
    CATSYPPropertyDescriptor _descriptor;
    CATBaseUnknown_var _value;
  };

  // Copy constructor and assignement operator are not implemented.
  CATSYPDataBlockFactory (CATSYPDataBlockFactory &);
  CATSYPDataBlockFactory& operator=(CATSYPDataBlockFactory&);

  /**
   * Find the event handler with the given name
   * @param i_eventHandlerName the name of the event handler to look for.
   * @return the index of the event handler if found, otherwise -1
   */
  int FindEventHandler(const CATUnicodeString & i_eventHandlerName);

  /**
   * Create the meta-class using the registered properties.
   */
  void CreateMetaClass();

  /** The built meta class */
  CATSYPMetaClass * _pCurrentMetaClass;
  /** The property descriptors used to built the meta-class */
  CATSYPDynArray<CATVidPairPropertyDescAndValue> _propertyDescriptors;
  /** The event handler descriptors used to built the meta-class */
  CATSYPDynArray<CATSYPEventHandlerDescriptor> _eventHandlerDescriptors;
};


#endif
