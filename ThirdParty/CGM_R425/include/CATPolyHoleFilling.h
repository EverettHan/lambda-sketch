
#pragma once

#include "PolyBodyBoolean.h"
#include "CATIPolyMesh.h"
#include "CATIPolyHoleBoundary.h"
#include "CATPolyMeshOptimizer.h"
#include "CATPolyVertexKDTree.h"
#include "CATIPolyVertexPositionConstLayer.h"

#include <unordered_set>
#include <map>
#include <queue>
#include <limits>


class CATProgressCallback;

/**
* Operator that given a closed border and a function,
* generates a mesh with the given border that minimizes the function.
*/
class ExportedByPolyBodyBoolean CATPolyHoleFilling {

public:
	/**
	* Observer to visualize the steps of the hole filling.
	*/
	class Observer
	{
	public:
		virtual void BeginHoleFilling() {}; // With positions information, we could highlight the border we are filling.
		virtual void EndHoleFilling() {}; // End preview info?
		virtual void ReactToStep(CATIPolyMesh& iMesh) {};
	};

public:
	/**
	*  Given some hole boundaries and an empty mesh, it completes the mesh to fill the hole.
	* @param boundaries
	*		reference to a vector of CATPolyHoleBoundary that describes the boundaries of the hole that we want to fill.
	* @param mesh
	*		reference to the empty mesh that the function will fill.
	* @param idBoundaryToIdMesh
	*		if the pointer is not null, the function will fill the vector with the indices in the mesh of the boundary vertices.
	* @param obs
	*		a pointer to the observer. It updates the visualization at each step of the algorithm.
	* @param progressCB
	*		a pointer to the progress callback.
	* @return 
	*		S_OK on success or E_FAIL otherwise.
	*/
	HRESULT Run(CATIPolyMesh& mesh, 
							std::map<const CATIPolyHoleBoundary *, std::vector<int>> & idBoundaryToIdMesh,
							Observer * obs = nullptr, 
							CATProgressCallback * progressCB = nullptr);

public:
	void addBoundary(const CATIPolyHoleBoundary& boundary);

	/**
	* These setters are used to set the parameters of the mesh optimizer.
	*/
	void SetLaplacianType(int type);
	void SetNbMaxIteFirst(int nbIte);
	void SetEpsChange(double eps);
	void SetNbMaxIteSecond(int nbIte);
	void SetTolerance(const CATTolerance& tolerance);
	void AddGrad(std::function<CATMathVector(CATMathPoint)>* grad);

protected:
	/**
	* Member that is used to optimized the smoothness of the mesh.
	*/
	CATPolyMeshOptimizer _meshOptimizer;
	std::vector<const CATIPolyHoleBoundary*> _boundaries;
public:

  /**
  * Class that stores the advancing front. It is a cyclical doubly linked list.
  * It also allows to move the cursor to a given vertex in constant time.
  */
  class CATFront {
  public:
    struct Node {
			static int nbAllocated;
			const int idNode;
			const int id;
      Node* next;
      Node* prev;

			Node(int i, Node* n, Node* p) : id(i), next(n), prev(p), idNode(++nbAllocated) {}

			Node(int i) : id(i), idNode(++nbAllocated) { next = this, prev = this; }
    };
		
    Node* current;
    int nbNodes;

	private:
		std::map<int, Node*> nodes;

		struct GetNodePosition {
			CATIPolyVertexPositionConstLayer& posLayer;

			GetNodePosition(CATIPolyVertexPositionConstLayer& pL) : posLayer(pL) {}
			~GetNodePosition() { posLayer.Release(); }
			HRESULT Get(Node* n, CATMathPoint& pos) const { return posLayer.Get(n->id, pos); }
		};
		
		GetNodePosition getNodePosition;
		CATPolyVertexKDTree<Node*> KDTree;

  public:
		CATFront(CATIPolyMesh& m);

		~CATFront() { for (Iterator it(*this); !it.End(); ++it) delete *it; }

    void append(int i);

		void erase();

    int size() { return nbNodes; }
    int get() { return current->id; }
    Node* getNode() { return current; }
		Node* getNode(int n) { return nodes[n]; }

    void next() { current = current->next; }
    void prev() { current = current->prev; }
    void next(int n) { if (n > 0) { next(); next(n - 1); } }
    void prev(int n) { if (n > 0) { prev(); prev(n - 1); } }

    int get(int n) { next(n); int res = get(); prev(n); return res; }

    void eraseNext() { next(); erase(); }

		void goTo(Node* n) { current = n; }
		void goTo(int n) { current = nodes[n]; }
		void newCycle() { current = nullptr; }

    bool contains(int n) { return nodes.find(n) != nodes.end(); }
    bool contains(Node* n) { return nodes.find(n->idNode) != nodes.end(); }

    struct Iterator {
			std::map<int, Node*>::iterator _itr;
			std::map<int, Node*>::iterator _end;

      Iterator(CATFront& front) : _itr(front.nodes.begin()), _end(front.nodes.end()) {}
      void operator++() { ++_itr; }
			bool End() { return _itr == _end; }
			Node* operator*() { return _itr->second; }
    };

		void initializeKDTree();
		void getCloseVerticesOfBar(double radius, std::vector<Node*>& ids);
  };

	struct Operation;
	/**
	* Structure that describes the score of an operation in the AFM.
	* It uses the minimum angle generated by the operation,
	* the minimal length of the bars in the operation,
	* the internal angle if the operation is Acute and
	* the opposed vertex if the operation is Divide.
	*/
	#undef max
	struct CATScore {
		double min_angle = -4;
		double min_bar_length = std::numeric_limits<double>::max();
		double max_int_angle = CAT2PI;

		int idNode = -1;

		CATMathPoint newP; //For Advance
		int idOpp = -1; //For Divide

		Operation* oper = nullptr;

		double value() const;

		CATScore() {}
		CATScore(Operation* o, int n) : oper(o), idNode(n) {}

		bool operator<(const CATScore& rhs) const { return this->value() < rhs.value(); }

    bool operator ==(const CATScore& rhs) const {
      return min_angle == rhs.min_angle &&
        min_bar_length == rhs.min_bar_length &&
        max_int_angle == rhs.max_int_angle &&
        idNode == rhs.idNode &&
				oper == rhs.oper &&
				idOpp == rhs.idOpp;
    }

		bool operator !=(const CATScore& rhs) const {return !(*this == rhs); }

		Operation& operation() const { return *oper; }
	};


	/**
	* Custom data structure for a priority queue.
	* It stores the scores by decreasing order of value.
	* The priority queue might have multiple scores with the same id, for example when we update the value of an operation that is still in the priority queue.
	* So, it also has a hashmap that maps an ID to the latest added score.
	* So when we retrieve a best score that doesn't match the hashmap, we say that this score is deprecated and we retrieve another one.
	* We also verify that the operation is compatible with the front. For example, we don't accept a score of an operation on a vertex that is not in the front.
	*/
	struct CATPQScores {
	private:

		std::priority_queue<CATScore> scores;
		std::unordered_map<int, CATScore> from_id_to_score;
		CATFront& front;

	public:
		CATPQScores(CATFront& f) : front(f) {}
		void push(const CATScore& score);
		CATScore top();
	};

	/**
	* To generate the mesh we only allow some local operations. 
	* Each operation generates a score for a given sate of the front.
	* Each operation defines a run function that modifies the mesh to fill the hole locally
	*/
	struct Operation
	{
	protected:
		CATIPolyMesh& mesh;
		CATFront& front;

	public:
		Operation(CATIPolyMesh& m, CATFront& f) : mesh(m), front(f) {}
		virtual CATScore score() = 0;
		virtual void run(const CATScore& score) = 0;
	};

	/**
	* If two front bars form an acute angle, add the triangle defined by those bars and advance the front
	*/
	struct Acute : public Operation {
		Acute(CATIPolyMesh& m, CATFront& f) : Operation(m, f) {}
		virtual CATScore score();
		virtual void run(const CATScore& score);
	};

	/**
	* Given four consecutive vertices of the front v1, ..., v4; construct a new vertex newP and three triangles v_iv_{i+1}newP.
	* The point is placed so the new triangles are as much equilateral as possible.
	* We then advance the front.
	*/
	struct Advance : public Operation {
		Advance(CATIPolyMesh& m, CATFront& f) : Operation(m, f) {}
		virtual CATScore score();
		virtual void run(const CATScore& score);
	};


	/**
	* Given a bar v0v1, finds a vertex v2 close to the bar, constructs the triangle v0v1v2 and divides the front in two fronts.
	*/
	struct Divide : public Operation {
		Divide(CATIPolyMesh& m, CATFront& f) : Operation(m, f) {}
		virtual CATScore score();
    virtual void run(const CATScore & score);
  };

  private:
    HRESULT addBoundariesToMesh(CATIPolyMesh & mesh,
                                std::map<const CATIPolyHoleBoundary *, std::vector<int>> & boundariesIDToSV,
                                CATFront & front);

    HRESULT addBoundaryToMesh(CATIPolyMesh & mesh,
                              const CATIPolyHoleBoundary & boundary,
                              std::vector<int> & idToSV,
                              CATFront & front);
};
