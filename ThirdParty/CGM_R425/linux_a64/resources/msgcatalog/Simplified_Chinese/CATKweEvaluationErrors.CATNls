<meta charset="UTF-8"/>
ErrorInApplyAccess="Apply：无法解释 /P1。";
ErrorInExtract="Extract：无法解释 /P1。";
ErrorInSort="Sort ：无法解释 /P1。";
ErrorInAdvancedSort="AdvancedSort：无法解释 /P1。";
FindError="方法 Find 中出现错误。";
FilterError1="方法 Filter 中出现错误：第一个参数 (/P1) 的类型不存在";
FilterError2="方法 Filter 中出现错误：第二个参数 (/P1) 表达式有语法错误";
ApplyError1="方法 Apply 中出现错误：第一个参数 (/P1) 的类型不存在";
ApplyError2="方法 Apply 中出现错误：第二个参数 (/P1) 表达式有语法错误";
ExtractError1="方法 Extract 中出现错误：第一个参数 (/P1) 的类型不存在";
ExtractError2="方法 Extract 中出现错误：第二个参数 (/P1) 的类型不存在";
ExtractError3="方法 Extract 中出现错误：第三个参数不能为空。它必须包含一条规则，对 x 变量中的 y 变量求值";
SortError1="方法 Sort 中出现错误：第二个参数 (/P1) 的类型不存在";
SortError2="方法 Sort 中出现错误：第三个参数 (/P1) 的类型不存在";
SortError3="方法 Sort 中出现错误：第一个参数 (/P1) 的授权值为 < and >";

SubtractError1="方法 Subtract 中出现错误：第二个参数 (/P1) 的类型不存在";
SubtractError2="方法 Subtract 中出现错误：第三个参数 (/P1) 表达式有语法错误";
IntersectError1="方法 Intersect 中出现错误：第二个参数 (/P1) 的类型不存在";
IntersectError2="方法 Intersect 中出现错误：第三个参数 (/P1) 表达式有语法错误";
JunctionError1="方法 Junction 中出现错误：第二个参数 (/P1) 的类型不存在";
JunctionError2="方法 Junction 中出现错误：第三个参数 (/P1) 的类型不存在";
JunctionError3="方法 Junction 中出现错误：第四个参数不能为空。它必须包含一条规则，根据 x.attribute == y.attribute 形式下的 x 和 y 赋值";
JunctionError4="方法 Junction 中出现错误：第四个参数 (/P1) 表达式有语法错误";
SplitError1="方法 Split 中出现错误：第一个参数 (/P1) 的类型不存在";
SplitError2="方法 Split 中出现错误：第二个参数 (/P1) 的类型不存在";
SplitError3="方法 Split 中出现错误：第三个参数不能为空。它必须包含一条规则，对 x 变量中的 y 变量求值";
SplitError4="方法 Split 中出现错误：第三个参数 (/P1) 表达式有语法错误";
AdvancedSortError1="方法 AdvancedSort 中出现错误：第一个参数 (/P1) 的类型不存在";
AdvancedSortError2="方法 AdvancedSort 中出现错误：第三个参数 (/P1) 的类型不存在";
AdvancedSortError3="方法 AdvancedSort 中出现错误：第二个参数 (/P1) 的授权值为 < and >";
AdvancedSortError4="方法 AdvancedSort 中出现错误：第四个参数不能为空。它必须包含一条规则，通过 x 变量对 y 变量求值";
AdvancedSortListEmpty="方法 AdvancedSort 中出现错误：由于参数中给定的列表中有一个为空，无法执行操作。";
AdvancedSortDifferentSize="方法 AdvancedSort 中出现错误：参数中给定的列表大小不同。";

FindError1="方法 Find 中出现错误：第一个参数 (/P1) 的类型不存在";
FindError2="方法 Find 中出现错误：第二个参数 (/P1) 表达式有语法错误";
SyntaxError="执行阶段中出现语法错误： ";
SetAttributeDimension="方法 SetAttributeDimension 中出现错误：最后一个参数 (/P1) 的尺寸类型不存在";
NewError1="函数 new 中出现错误：第一个参数 (/P1) 的类型不存在";
NewError2="函数 new 中出现错误：第一个参数 (/P1) 的类型无法实例化";
NewError3="函数 new 中出现错误：无法在类型 /P3 的对象 /P2 下创建 /P1 类型的对象";
NewError4="函数 new 中出现错误：您没有运行时许可证，无法从语言中执行 new 操作。";
ReplaceError1="替换时出错：无法执行替换，禁止替换对象与所有者对象之间的类型关联 â€“ 使用具有授权类型关联的对象";
RemoveExtensionError1="函数 RemoveExtension 中的错误：无法移除应用程序扩展";
UnableCreate="无法创建类型 /P1 的动态属性";
OperatorPowErrorCase1="运算符 ** 中出现错误（指定阶数的基数）：当阶数是负整数时，基数不能为零。";
OperatorPowErrorCase2="运算符 ** 中出现错误（指定阶数的基数）：如果阶数为正实数，基数必须为正。";
OperatorPowErrorCase3="运算符 ** 中出现错误（指定阶数的基数）：如果阶数为负实数，基数必须为正（不包括 0）。";
ResultOfOperationIsUnset="运算 /P1 的结果未设置。请检查该运算。";

TraceIncorrectLevel="跟踪级别不正确。级别必须在 1 到 9 之间（包括 1 和 9）。";
TraceToCreateFile="无法创建文件 /P1。";
TraceUnableToManipulateFile="无法写入文件 /P1。";
TraceUnableToWriteInFile="无法写入文件 /P1。请检查您在此文件/目录中是否拥有适当的权限。";


UnableToAddItemToList="无法将索引为 /P1 的项填加到列表。对象无效：确认您尝试添加的项存在。";
UnableToAddItemToListBecauseOfIndex="无法向列表中添加项。索引 /P1 超出范围（应该在 0 和 /P2 之间）。";

UnableToInsertItemToList="无法将索引为 /P1 的项插入到列表。对象无效：确认您尝试插入的项存在。";
UnableToInsertItemToListBecauseOfIndex="无法向列表中插入项。索引 /P1 超出范围（应该在 1 和 /P2 之间）。";

UnableToAppendItemToList="无法向列表中附加项。对象无效：确认您尝试插入的项存在。";

UnableToSetItemToList="无法将索引为 /P1 的项设置到列表。对象无效：确认您尝试添加的项存在。";
UnableToSetItemToListBecauseOfIndex="无法向列表中设置项。索引 /P1 超出范围（应该在 1 和 /P2 之间）。";

UnableToRemoveItem="无法从列表中移除索引为 /P1 的项。";
UnableToRemoveItemFromListBecauseOfIndex="无法从列表中移除项。索引 /P1 超出范围（应该在 1 和 /P2 之间）。";
UnableToValuateList="无法使用列表 /P2 为列表 /P1 赋值。";


UnableToRemoveAllItems="无法清空列表。";

ListItemNULL="索引为 /P1 的列表中的项为空。";
ListEmpty="无法对列表执行操作：列表为空。";

UnableToGetItemIndexOutOfRange="无法在列表中获得项。索引 /P1 超出范围（应该在 1 和 /P2 之间）。";

UnableToReorder="无法将该元素从当前位置 /P1 重新排序到位置 /P2。";
UnableToSwap="无法将该元素从当前位置 /P1 重新排序到位置 /P2。";

UnableToCreateList="无法创建列表。";
UnableToAddItemToNewList="无法将索引为 /P1 的项填加到新列表。对象无效：确认您尝试添加的项存在。";
NoItemToAddToNewList="没有要添加到新列表的项。";


SumIsNull="总和中没有加入任何项。总和等于 0。";

ErrorInComputeWrongTypeInItems="计算运算 /P1 时出现问题：未考虑元素 /P2，因为它不是 /P3 类型。";
ErrorInComputeWrongType="无法计算 /P1：类型 /P2 不是参考类型。";
ErrorInComputeCanNotBeEvaluated="无法计算 /P1：无法对此表达式求值（请检查类型或语法）。";
BadOperatorInCompute="Compute 方法无法使用运算符 /P1";
BadReturnedTypeInCompute="计算所得值的类型 /P1 是未授权类型。在 Compute 方法中计算所得值必须是 Real 或 String。";

BadTypeError="正在尝试影响 /P1 类型的参数，应为 /P2 类型的参数";

ObjectModificationInfringement="在此规则上下文中，禁止修改对象 /P1（通过其属性 /P2）";

SolveFailed="对象 /P1 上的方法 Update 失败";
SolveFailedNotImpl="未能在对象 /P1 上执行方法 Update";

ListAttributesError1="方法 ListAttributes 中出现错误：第一个参数 (/P1) 的类型不存在";
AddExtensionError1="方法 AddExtension 中出现错误：第一个参数 (/P1) 的类型不存在";
AddExtensionError2="方法 AddExtension 中出现错误：第一个参数 (/P1) 是不能实例化的类型";
AddExtensionError3="方法 AddExtension 中出现错误：类型 /P3 的对象 /P2 不能用类型 /P1 来扩展";
AddExtensionError4="方法 AddExtension 中出现错误：您没有运行时许可证，无法从语言中执行 new 操作。";

IntegerOverflowError="整数溢出错误。";
ReadAttributeOnNullObject="尝试在空变量上读取属性 /P1";
WriteAttributeOnNullObject="尝试在空变量上写入属性 /P1";

FunctionNotAllowedInBR="业务规则上下文中不允许使用此函数或方法";
QueryError1="方法 Query 中出现错误：第一个参数 (/P1) 的类型不存在";
QueryError2="方法 Query 中出现错误：第二个参数 (/P1) 表达式有语法错误";
QueryError="方法 Query 中出现错误。";
TraceRaised="出现跟踪： ";
MessageRaised="出现消息： ";

IsSupportingError="方法 IsSupporting 中出现错误：第一个参数 (/P1) 的类型不存在";
IsASortOfError="方法 IsASortOf 中出现错误：第一个参数 (/P1) 的类型不存在";
ValuatePointerError="方法 ValuatePointer 中出现错误：第三个参数 (/P1) 的类型不存在";
AccessError="方法 Access 中出现错误：第二个参数 (/P1) 的类型不存在";

SetupDataError1="在表达式对象 /P3 的函数 /P2 中指定作为标识符的字符串 /P1 错误：\n系统无法检索关联的资源";
ARMErrorNoTable="无法找到用于表达式对象 /P3 的函数 /P2 中的资源 /P1\n因为在包含 /P3 的展示中无资源表";
ARMErrorResourceNotFound="在包含 /P3 的展示中定义的资源表中找不到表达式对象 /P3 中函数 /P2 使用的资源  /P1";
UnstackError="无法在之前仅激活 /P2 的情况下，停用 /P1 配置资源。未停用任何对象。";
AccessResourceBadType="方法 AccessResource 中出现错误：第二个参数 (/P1) 的类型不存在";
ImplementsOperation="方法 ImplementsOperation 中出现错误：(/P1) 操作名称无效";
LicCheckERR_0001="许可证 /P1 未授权。";

OpenFilterErrorEmpty="过滤容器 /P1 为空，因此找不到资源 /P2。\n您可能想要更改提供的过滤器。";
ResourceNotFoundInContainer="在容器 /P2 中找不到资源 /P1。";
ResourceNotFoundInLocalResourceTable="在本地资源表中找不到资源 /P1。";
ResourceNotFoundInDataSetup="通过数据设置在 /P2 中找不到资源 /P1。";

OpenFilterContainerError="激活的过滤器与所选 /P1 容器不对应。\n必须选择与容器对应的过滤器。";

TempGeometryInPersistentList="无法在列表 /P1 添加项目。不应将临时几何图形放在永久列表中。";

NotAValidYear="不是日期构造程序中给定的有效年份。";
NotAValidMonth="不是日期构造程序中给定的有效月份。";
NotAValidDay="不是日期构造程序中给定的有效日期。";
NotAValidDayShort="不是日期构造程序中给定的有效简短月份日期。";
NotAValidDayFeb="不是日期构造程序中给定的有效二月份日期。";
NotAValidHour="不是日期和时间构造程序中给定的有效小时。";
NotAValidMinute="不是日期和时间构造程序中给定的有效分钟。";
NotAValidSecond="不是日期和时间构造程序中给定的有效秒。";
NotAValidDate="不是日期和时间构造程序中给定的有效日期。";
NotAValidDate2="不是日期和时间构造程序中给定的有效时间。";
RemoveAttribute="无法移除对象 /P2 上的 /P1 属性，因为它不是动态添加的属性。";
AccessFederatedExtensionNotExisting="无法访问组合的扩展/P1，因为它不存在。";
AccessFederatedExtensionNotImpl="无法访问组合的扩展/P1，因为它没有执行 CATIAttributeComputed。";

MatchPatternNotRecognized="无法识别匹配功能中的模式 /P1。";
SystemInfoNotRecognized="/P1 是未知系统信息。";
PatternRegexError="无法编译阵列 /P1 以生成正则表达式。";
IndexGroupCaptureError="索引超出范围，索引 (/P1) 应大于或等于 0，且严格小于组数 (/P2)。";

CannotInterrogateOnUpdateStatus="无法询问 /P1 对象的更新状态。";

EnableErrors="调用 EnableErrors 时没有调用匹配的 DisableErors";
SilentErrorsMismatch="调用 DisableErrors 和 EnableErrors 的次数不匹配。\n这可能会导致向用户隐藏发生的错误。";
DebuggerBreakNoDebugger="已调用 DebuggerBreak 函数，但当前上下文不允许调试。请先连接知识工程调试器。";

NumbersBetweenWrongNumber="传递到 NumbersBetween 函数中的值数目错误";
NumbersBetweenWrongStep="传递到 NumbersBetweenByStep 函数中的步长值错误";

InitPersist="列表初始化方法只能在可变列表上调用";
QuickSet="提供的访问列表元素的索引列表无效";

